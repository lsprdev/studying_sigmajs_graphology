{"version":3,"sources":["node_modules/graphology-utils/is-graph.js","node_modules/sigma/utils/matrices.js","node_modules/sigma/utils/data.js","node_modules/sigma/utils/index.js","node_modules/sigma/utils/easings.js","node_modules/sigma/utils/animate.js","node_modules/events/events.js","node_modules/sigma/types.js","node_modules/sigma/core/camera.js","node_modules/sigma/core/captors/captor.js","node_modules/sigma/core/captors/mouse.js","node_modules/@yomguithereal/helpers/extend.js","node_modules/sigma/core/quadtree.js","node_modules/sigma/core/labels.js","node_modules/sigma/rendering/canvas/label.js","node_modules/sigma/rendering/canvas/hover.js","node_modules/sigma/rendering/canvas/edge-label.js","node_modules/sigma/rendering/webgl/shaders/node.fast.vert.glsl.js","node_modules/sigma/rendering/webgl/shaders/node.fast.frag.glsl.js","node_modules/sigma/rendering/webgl/shaders/utils.js","node_modules/sigma/rendering/webgl/programs/common/program.js","node_modules/sigma/rendering/webgl/programs/common/node.js","node_modules/sigma/rendering/webgl/programs/node.fast.js","node_modules/sigma/rendering/webgl/shaders/edge.vert.glsl.js","node_modules/sigma/rendering/webgl/shaders/edge.frag.glsl.js","node_modules/sigma/rendering/webgl/programs/common/edge.js","node_modules/sigma/rendering/webgl/programs/edge.js","node_modules/sigma/rendering/webgl/shaders/edge.arrowHead.vert.glsl.js","node_modules/sigma/rendering/webgl/shaders/edge.arrowHead.frag.glsl.js","node_modules/sigma/rendering/webgl/programs/edge.arrowHead.js","node_modules/sigma/rendering/webgl/shaders/edge.clamped.vert.glsl.js","node_modules/sigma/rendering/webgl/programs/edge.clamped.js","node_modules/sigma/rendering/webgl/programs/edge.arrow.js","node_modules/sigma/settings.js","node_modules/sigma/core/captors/touch.js","node_modules/sigma/utils/edge-collisions.js","node_modules/sigma/sigma.js","node_modules/sigma/index.js","../src/utils.js","../../../node_modules/events/events.js","../../../node_modules/obliterator/iterator.js","../../../node_modules/obliterator/support.js","../../../node_modules/obliterator/iter.js","../../../node_modules/obliterator/take.js","../src/errors.js","../src/data.js","../src/attributes/nodes.js","../src/attributes/edges.js","../../../node_modules/obliterator/chain.js","../src/iteration/edges.js","../src/iteration/neighbors.js","../src/iteration/adjacency.js","../src/serialization.js","../src/graph.js","../src/classes.js","node_modules/graphology-layout-forceatlas2/webworker.js","node_modules/graphology-utils/getters.js","node_modules/graphology-layout-forceatlas2/helpers.js","node_modules/graphology-layout-forceatlas2/defaults.js","node_modules/graphology-layout-forceatlas2/worker.js","index.ts","node_modules/parcel-bundler/src/builtins/hmr-runtime.js"],"names":["R","Reflect","ReflectApply","apply","target","receiver","args","Function","prototype","call","ReflectOwnKeys","ownKeys","Object","getOwnPropertySymbols","getOwnPropertyNames","concat","ProcessEmitWarning","warning","console","warn","NumberIsNaN","Number","isNaN","value","EventEmitter","init","module","exports","once","_events","undefined","_eventsCount","_maxListeners","defaultMaxListeners","checkListener","listener","TypeError","defineProperty","enumerable","get","set","arg","RangeError","getPrototypeOf","create","setMaxListeners","n","_getMaxListeners","that","getMaxListeners","emit","type","i","arguments","length","push","doError","events","error","er","Error","err","message","context","handler","len","listeners","arrayClone","_addListener","prepend","m","existing","newListener","unshift","warned","w","String","name","emitter","count","addListener","on","prependListener","onceWrapper","fired","removeListener","wrapFn","_onceWrap","state","wrapped","bind","prependOnceListener","list","position","originalListener","shift","spliceOne","off","removeAllListeners","keys","key","_listeners","unwrap","evlistener","unwrapListeners","rawListeners","listenerCount","eventNames","arr","copy","Array","index","pop","ret","Promise","resolve","reject","errorListener","resolver","slice","eventTargetAgnosticAddListener","addErrorHandlerIfEventEmitter","flags","addEventListener","wrapListener","removeEventListener","assign","l","k","getMatchingEdge","graph","source","sourceData","_nodes","edge","out","undirected","isPlainObject","_typeof","constructor","isEmpty","o","privateProperty","configurable","writable","readOnlyProperty","descriptor","validateHints","hints","attributes","isArray","this","eventsModule","Iterator","next","Symbol","iterator","Iterator$2","of","done","empty","fromSequence","sequence","is","support","ARRAY_BUFFER_SUPPORT","ArrayBuffer","SYMBOL_SUPPORT","require$$0","require$$1","iter","isView","iterOrNull","take","iterable","step","Infinity","array","GraphError","_Error","_this","_inheritsLoose","_wrapNativeSuper","InvalidArgumentsGraphError","_GraphError","_this2","captureStackTrace","NotFoundGraphError","_GraphError2","_this3","UsageGraphError","_GraphError3","_this4","MixedNodeData","clear","DirectedNodeData","UndirectedNodeData","EdgeData","inDegree","outDegree","undirectedDegree","attach","outKey","inKey","attachMulti","adj","head","previous","detach","detachMulti","findRelevantNodeData","method","mode","nodeOrEdge","nameOrEdge","add1","add2","nodeData","edgeData","arg1","arg2","_edges","NODE_ATTRIBUTES_METHODS","element","attacher","Class","_findRelevantNodeData","data","_findRelevantNodeData3","hasOwnProperty","_findRelevantNodeData4","_findRelevantNodeData5","updater","_findRelevantNodeData6","_findRelevantNodeData7","_findRelevantNodeData8","_findRelevantNodeData9","EDGE_ATTRIBUTES_METHODS","multi","chain","iterables","current","EDGES_ITERATION","direction","forEachSimple","breakable","object","callback","avoid","shouldBreak","forEachMulti","createIterator","sourceAttributes","targetAttributes","forEachForKeySimple","targetData","forEachForKeyMulti","createIteratorForKey","createEdgeArray","size","from","undirectedSize","directedSize","mask","values","forEachEdge","shouldFilter","_data","createEdgeIterator","forEachEdgeForNode","found","fn","createEdgeArrayForNode","edges","createEdgeIteratorForNode","forEachEdgeForPath","createEdgeArrayForPath","createEdgeIteratorForPath","NEIGHBORS_ITERATION","CompositeSetWrapper","A","B","forEachInObjectOnce","visited","neighborData","has","forEachNeighbor","wrap","createDedupedObjectIterator","neighbor","attachNeighborArrayCreator","description","node","neighbors","createNeighborArrayForNode","attachNeighborIteratorCreator","iteratorName","createNeighborIterator","forEachAdjacency","assymetric","disconnectedNodes","hasEdges","validateSerializedNode","validateSerializedEdge","INSTANCE_ID","Math","floor","random","TYPES","Set","EMITTER_PROPS","DEFAULTS","allowSelfLoops","unsafeAddNode","NodeDataClass","addEdge","mustGenerateKey","eventData","_edgeKeyGenerator","isSelfLoop","_undirectedSelfLoopCount","_directedSelfLoopCount","_undirectedSize","_directedSize","mergeEdge","asUpdater","alreadyExistingEdgeData","info","oldAttributes","sourceWasAdded","targetWasAdded","dropEdgeFromData","Graph","options","_EventEmitter","_assertThisInitialized","instancePrefix","edgeId","Map","availableEdgeKey","forEach","prop","_options","_resetInstanceCounters","hasNode","hasDirectedEdge","hasUndirectedEdge","hasEdge","directedEdge","undirectedEdge","areDirectedNeighbors","areOutNeighbors","areInNeighbors","areUndirectedNeighbors","areNeighbors","areInboundNeighbors","areOutboundNeighbors","directedDegree","inboundDegree","degree","outboundDegree","inDegreeWithoutSelfLoops","self","loops","outDegreeWithoutSelfLoops","directedDegreeWithoutSelfLoops","undirectedDegreeWithoutSelfLoops","inboundDegreeWithoutSelfLoops","outboundDegreeWithoutSelfLoops","degreeWithoutSelfLoops","extremities","opposite","hasExtremity","isUndirected","isDirected","addNode","mergeNode","updateNode","dropNode","dropEdge","dropDirectedEdge","dropUndirectedEdge","clearEdges","getAttribute","_attributes","getAttributes","hasAttribute","setAttribute","updateAttribute","removeAttribute","replaceAttributes","mergeAttributes","updateAttributes","updateEachNodeAttributes","updateEachEdgeAttributes","forEachAdjacencyEntry","forEachAdjacencyEntryWithOrphans","forEachAssymetricAdjacencyEntry","forEachAssymetricAdjacencyEntryWithOrphans","nodes","forEachNode","findNode","mapNodes","result","order","someNode","everyNode","filterNodes","reduceNodes","initialValue","accumulator","nodeEntries","serialized","serializeNode","serializeEdge","_proto","merge","a","e","s","t","_sa","_ta","u","mergeUndirectedEdgeWithKey","mergeDirectedEdgeWithKey","addUndirectedEdgeWithKey","addDirectedEdgeWithKey","_node","undirectedByDefault","_edge","_edge$undirected","mergeUndirectedEdge","mergeDirectedEdge","addUndirectedEdge","addDirectedEdge","nullCopy","emptyCopy","toJSON","toString","inspect","multiIndex","tmp","label","desc","startsWith","dummy","verb","generateKey","_ref","attachNodeAttributesMethods","attachEdgeAttributesMethods","attachEdgeArrayCreator","forEachName","toUpperCase","mapName","ea","sa","ta","filterName","reduceName","attachForEachEdge","findEdgeName","someName","everyName","attachFindEdge","originalName","attachEdgeIteratorCreator","attachEdgeIterationMethods","attachForEachNeighbor","capitalizedSingular","findName","attachFindNeighbor","attachNeighborIterationMethods","DirectedGraph","finalOptions","_Graph","UndirectedGraph","_Graph2","MultiGraph","_Graph3","MultiDirectedGraph","_Graph4","MultiUndirectedGraph","_Graph5","attachStaticFromMethod","instance","OVERLAY_ID","OldModule","bundle","Module","moduleName","hot","hotData","_acceptCallbacks","_disposeCallbacks","accept","dispose","checkedAssets","assetsToAccept","parent","isParcelRequire","WebSocket","hostname","location","protocol","ws","onmessage","event","JSON","parse","handled","assets","asset","isNew","didAccept","hmrAcceptCheck","global","parcelRequire","id","every","generated","js","hmrApply","v","hmrAcceptRun","reload","close","onclose","log","removeErrorOverlay","stack","overlay","createErrorOverlay","document","body","appendChild","getElementById","remove","createElement","stackTrace","innerText","innerHTML","getParents","modules","parents","d","dep","deps","cached","cache","some","cb"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/XA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;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AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3VA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpEA;;ACAA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9DA;;ACAA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxKA;;ACAA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrIA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACl5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;izDCIA,IAAIgD,EAZJ,WAGE,IAFA,IAAM1H,EAASiD,UAAU,GAEhBD,EAAI,EAAG2E,EAAI1E,UAAUC,OAAQF,EAAI2E,EAAG3E,IAC3C,GAAKC,UAAUD,GAEf,IAAK,IAAM4E,KAAK3E,UAAUD,GAAIhD,EAAO4H,GAAK3E,UAAUD,GAAG4E,GAGzD,OAAO5H,GAoBF,SAAS6H,EAAgBC,EAAOC,EAAQ/H,EAAQ+C,GAC/CiF,IAAAA,EAAaF,EAAMG,OAAO9F,IAAI4F,GAEhCG,EAAO,KAEX,OAAKF,EAGHE,EADW,UAATnF,EAECiF,EAAWG,KAAOH,EAAWG,IAAInI,IACjCgI,EAAWI,YAAcJ,EAAWI,WAAWpI,GAChC,aAAT+C,EACFiF,EAAWG,KAAOH,EAAWG,IAAInI,GAEjCgI,EAAWI,YAAcJ,EAAWI,WAAWpI,GAThCkI,EAqBnB,SAASG,EAAclH,GAC5B,MACmB,WAAjBmH,EAAOnH,IAAgC,OAAVA,GAAkBA,EAAMoH,cAAgB/H,OAUlE,SAASgI,EAAQC,GACtB,IAAIb,EAECA,IAAAA,KAAKa,EAAG,OAAO,EAEpB,OAAO,EAUF,SAASC,EAAgB1I,EAAQyE,EAAMtD,GAC5CX,OAAOyB,eAAejC,EAAQyE,EAAM,CAClCvC,YAAY,EACZyG,cAAc,EACdC,UAAU,EACVzH,MAAAA,IAWG,SAAS0H,EAAiB7I,EAAQyE,EAAMtD,GAC7C,IAAM2H,EAAa,CACjB5G,YAAY,EACZyG,cAAc,GAGK,mBAAVxH,EACT2H,EAAW3G,IAAMhB,GAEjB2H,EAAW3H,MAAQA,EACnB2H,EAAWF,UAAW,GAGxBpI,OAAOyB,eAAejC,EAAQyE,EAAMqE,GAQ/B,SAASC,EAAcC,GAC5B,QAAKX,EAAcW,MAEfA,EAAMC,aAAevC,MAAMwC,QAAQF,EAAMC,aA5GlB,mBAAlBzI,OAAOkH,SAAuBA,EAASlH,OAAOkH,YCErDpH,iBAPAV,EAAuB,iBAAZC,QAAuBA,QAAU,KAC5CC,EAAeF,GAAwB,mBAAZA,EAAEG,MAC7BH,EAAEG,MACF,SAAsBC,EAAQC,EAAUC,GACxC,OAAOC,SAASC,UAAUL,MAAMM,KAAKL,EAAQC,EAAUC,IAKzDI,EADEV,GAA0B,mBAAdA,EAAEW,QACCX,EAAEW,QACVC,OAAOC,sBACC,SAAwBT,GACvC,OAAOQ,OAAOE,oBAAoBV,GAC/BW,OAAOH,OAAOC,sBAAsBT,KAGxB,SAAwBA,GACvC,OAAOQ,OAAOE,oBAAoBV,IAQtC,IAAIgB,EAAcC,OAAOC,OAAS,SAAqBC,GAC9CA,OAAAA,GAAUA,GAGnB,SAASC,IACPA,EAAaC,KAAKhB,KAAK8I,MAEzBC,EAAc7H,QAAGH,EACEiC,EAAA9B,QAAAC,KAwYnB,SAAckD,EAASD,GACrB,OAAO,IAAIqC,SAAQ,SAAUC,EAASC,GAC3BC,SAAAA,EAAcxD,GACrBiB,EAAQO,eAAeR,EAAMyC,GAC7BF,EAAOvD,GAGT,SAASyD,IAC+B,mBAA3BxC,EAAQO,gBACjBP,EAAQO,eAAe,QAASgC,GAElCF,EAAQ,GAAGI,MAAM9G,KAAK4C,YAGxBmE,EAA+B1C,EAASD,EAAMyC,EAAU,CAAE1F,MAAM,IACnD,UAATiD,GAMR,SAAuCC,EAASd,EAAS0D,GAC7B,mBAAf5C,EAAQG,IACjBuC,EAA+B1C,EAAS,QAASd,EAAS0D,GAPxDD,CAA8B3C,EAASuC,EAAe,CAAEzF,MAAM,QArZpEJ,EAAaA,aAAeA,EAE5BA,EAAahB,UAAUqB,aAAUC,EACjCN,EAAahB,UAAUuB,aAAe,EACtCP,EAAahB,UAAUwB,mBAAgBF,EAIvC,IAAIG,EAAsB,GAE1B,SAASC,EAAcC,GACrB,GAAwB,mBAAbA,EACT,MAAM,IAAIC,UAAU,0EAA4ED,GAsCpG,SAASY,EAAiBC,GACpBA,YAAuBlB,IAAvBkB,EAAKhB,cACAR,EAAaS,oBACfe,EAAKhB,cAmDd,SAASoC,EAAahE,EAAQ+C,EAAMhB,EAAUkC,GAC5C,IAAIC,EACAb,EACAc,EA1HsBtD,EAgJtBsD,GApBJrC,EAAcC,QAGCL,KADf2B,EAASrD,EAAOyB,UAEd4B,EAASrD,EAAOyB,QAAUjB,OAAOgC,OAAO,MACxCxC,EAAO2B,aAAe,SAIKD,IAAvB2B,EAAOe,cACTpE,EAAO8C,KAAK,cAAeC,EACfhB,EAASA,SAAWA,EAASA,SAAWA,GAIpDsB,EAASrD,EAAOyB,SAElB0C,EAAWd,EAAON,SAGHrB,IAAbyC,EAEFA,EAAWd,EAAON,GAAQhB,IACxB/B,EAAO2B,kBAeT,GAbwB,mBAAbwC,EAETA,EAAWd,EAAON,GAChBkB,EAAU,CAAClC,EAAUoC,GAAY,CAACA,EAAUpC,GAErCkC,EACTE,EAASE,QAAQtC,GAEjBoC,EAAShB,KAAKpB,IAIhBmC,EAAIvB,EAAiB3C,IACb,GAAKmE,EAASjB,OAASgB,IAAMC,EAASG,OAAQ,CACpDH,EAASG,QAAS,EAGdC,IAAAA,EAAI,IAAIf,MAAM,+CACEW,EAASjB,OAAS,IAAMsB,OAAOzB,GADjC,qEAIlBwB,EAAEE,KAAO,8BACTF,EAAEG,QAAU1E,EACZuE,EAAExB,KAAOA,EACTwB,EAAEI,MAAQR,EAASjB,OA7KGrC,EA8KH0D,EA7KnBzD,SAAWA,QAAQC,MAAMD,QAAQC,KAAKF,GAiL1C,OAAOb,EAcT,SAAS+E,IACH,IAACoE,KAAKnE,MAGR,OAFKhF,KAAAA,OAAOiF,eAAekE,KAAKpG,KAAMoG,KAAKjE,QACtCF,KAAAA,OAAQ,EACY,IAArB/B,UAAUC,OACLiG,KAAKpH,SAAS1B,KAAK8I,KAAKnJ,QAC1BmJ,KAAKpH,SAAShC,MAAMoJ,KAAKnJ,OAAQiD,WAI5C,SAASkC,EAAUnF,EAAQ+C,EAAMhB,GAC/B,IAAIqD,EAAQ,CAAEJ,OAAO,EAAOE,YAAQxD,EAAW1B,OAAQA,EAAQ+C,KAAMA,EAAMhB,SAAUA,GACjFsD,EAAUN,EAAYO,KAAKF,GAG/B,OAFAC,EAAQtD,SAAWA,EACnBqD,EAAMF,OAASG,EACRA,EA0HT,SAASY,EAAWjG,EAAQ+C,EAAMmD,GAChC,IAAI7C,EAASrD,EAAOyB,QAEpB,QAAeC,IAAX2B,EACF,MAAO,GAET,IAAI8C,EAAa9C,EAAON,GACxB,YAAmBrB,IAAfyE,EACK,GAEiB,mBAAfA,EACFD,EAAS,CAACC,EAAWpE,UAAYoE,GAAc,CAACA,GAElDD,EAsDT,SAAyBM,GAEvB,IADIK,IAAAA,EAAM,IAAIH,MAAMF,EAAItD,QACfF,EAAI,EAAGA,EAAI6D,EAAI3D,SAAUF,EAChC6D,EAAI7D,GAAKwD,EAAIxD,GAAGjB,UAAYyE,EAAIxD,GAElC,OAAO6D,EA1DLT,CAAgBD,GAAcpC,EAAWoC,EAAYA,EAAWjD,QAoBpE,SAASoD,EAAcvD,GACjBM,IAAAA,EAAS8F,KAAK1H,QAEd4B,QAAW3B,IAAX2B,EAAsB,CACxB,IAAI8C,EAAa9C,EAAON,GAExB,GAA0B,mBAAfoD,EACT,OAAO,EACF,QAAmBzE,IAAfyE,EACFA,OAAAA,EAAWjD,OAItB,OAAO,EAOT,SAASa,EAAWyC,EAAK9D,GAElB,IADL,IAAI+D,EAAO,IAAIC,MAAMhE,GACZM,EAAI,EAAGA,EAAIN,IAAKM,EACvByD,EAAKzD,GAAKwD,EAAIxD,GAChB,OAAOyD,EA4CT,SAASW,EAA+B1C,EAASD,EAAM1C,EAAUuF,GAC/D,GAA0B,mBAAf5C,EAAQG,GACbyC,EAAM9F,KACRkD,EAAQlD,KAAKiD,EAAM1C,GAEnB2C,EAAQG,GAAGJ,EAAM1C,OAEd,CAAA,GAAwC,mBAA7B2C,EAAQ6C,iBAYxB,MAAM,IAAIvF,UAAU,6EAA+E0C,GATnGA,EAAQ6C,iBAAiB9C,GAAM,SAAS+C,EAAanF,GAG/CiF,EAAM9F,MACRkD,EAAQ+C,oBAAoBhD,EAAM+C,GAEpCzF,EAASM,OC9df,SAASgH,EAASC,GACZ,GAAgB,mBAATA,EACT,MAAM,IAAI9F,MAAM,+CAEb8F,KAAAA,KAAOA,ED0Dd9I,OAAOyB,eAAeb,EAAc,sBAAuB,CACzDc,YAAY,EACZC,IAAK,WACH,OAAON,GAETO,IAAK,SAASC,GACZ,GAAmB,iBAARA,GAAoBA,EAAM,GAAKrB,EAAYqB,GACpD,MAAM,IAAIC,WAAW,kGAAoGD,EAAM,KAEjIR,EAAsBQ,KAI1BjB,EAAaC,KAAO,gBAEGK,IAAjByH,KAAK1H,SACL0H,KAAK1H,UAAYjB,OAAO+B,eAAe4G,MAAM1H,UAC/C0H,KAAK1H,QAAUjB,OAAOgC,OAAO,MACxBb,KAAAA,aAAe,GAGtBwH,KAAKvH,cAAgBuH,KAAKvH,oBAAiBF,GAK7CN,EAAahB,UAAUqC,gBAAkB,SAAyBC,GAChE,GAAiB,iBAANA,GAAkBA,EAAI,GAAK1B,EAAY0B,GAChD,MAAM,IAAIJ,WAAW,gFAAkFI,EAAI,KAG7G,OADKd,KAAAA,cAAgBc,EACdyG,MAST/H,EAAahB,UAAUyC,gBAAkB,WAChCF,OAAAA,EAAiBwG,OAG1B/H,EAAahB,UAAU0C,KAAO,SAAcC,GAErC,IADD7C,IAAAA,EAAO,GACF8C,EAAI,EAAGA,EAAIC,UAAUC,OAAQF,IAAK9C,EAAKiD,KAAKF,UAAUD,IAC/D,IAAII,EAAoB,UAATL,EAEXM,EAAS8F,KAAK1H,QACd4B,QAAW3B,IAAX2B,EACFD,EAAWA,QAA4B1B,IAAjB2B,EAAOC,WAC1B,IAAKF,EACR,OAAO,EAGT,GAAIA,EAAS,CACX,IAAIG,EAGAA,GAFArD,EAAKgD,OAAS,IAChBK,EAAKrD,EAAK,IACRqD,aAAcC,MAGVD,MAAAA,EAGR,IAAIE,EAAM,IAAID,MAAM,oBAAsBD,EAAK,KAAOA,EAAGG,QAAU,IAAM,KAEnED,MADNA,EAAIE,QAAUJ,EACRE,EAGR,IAAIG,EAAUP,EAAON,GAErB,QAAgBrB,IAAZkC,EACF,OAAO,EAET,GAAuB,mBAAZA,EACT9D,EAAa8D,EAASuF,KAAMjJ,OAE5B,CAAA,IAAI2D,EAAMD,EAAQV,OACdY,EAAYC,EAAWH,EAASC,GAC/B,IAAIb,EAAI,EAAGA,EAAIa,IAAOb,EACzBlD,EAAagE,EAAUd,GAAImG,KAAMjJ,GAGrC,OAAO,GAiETkB,EAAahB,UAAUwE,YAAc,SAAqB7B,EAAMhB,GACvDiC,OAAAA,EAAamF,KAAMpG,EAAMhB,GAAU,IAG5CX,EAAahB,UAAUyE,GAAKzD,EAAahB,UAAUwE,YAEnDxD,EAAahB,UAAU0E,gBACnB,SAAyB/B,EAAMhB,GACtBiC,OAAAA,EAAamF,KAAMpG,EAAMhB,GAAU,IAqBhDX,EAAahB,UAAUoB,KAAO,SAAcuB,EAAMhB,GAGhD,OAFAD,EAAcC,GACT8C,KAAAA,GAAG9B,EAAMoC,EAAUgE,KAAMpG,EAAMhB,IAC7BoH,MAGT/H,EAAahB,UAAUmF,oBACnB,SAA6BxC,EAAMhB,GAGjC,OAFAD,EAAcC,GACT+C,KAAAA,gBAAgB/B,EAAMoC,EAAUgE,KAAMpG,EAAMhB,IAC1CoH,MAIb/H,EAAahB,UAAU6E,eACnB,SAAwBlC,EAAMhB,GACxByD,IAAAA,EAAMnC,EAAQoC,EAAUzC,EAAG0C,EAK/B,GAHA5D,EAAcC,QAGCL,KADf2B,EAAS8F,KAAK1H,SAEZ,OAAO0H,KAGT,QAAazH,KADb8D,EAAOnC,EAAON,IAEZ,OAAOoG,KAEL3D,GAAAA,IAASzD,GAAYyD,EAAKzD,WAAaA,EACb,KAAtBoH,KAAKxH,aACTwH,KAAK1H,QAAUjB,OAAOgC,OAAO,cAEtBa,EAAON,GACVM,EAAO4B,gBACTkE,KAAKrG,KAAK,iBAAkBC,EAAMyC,EAAKzD,UAAYA,SAElD,GAAoB,mBAATyD,EAAqB,CAGrC,IAFAC,GAAY,EAEPzC,EAAIwC,EAAKtC,OAAS,EAAGF,GAAK,EAAGA,IAChC,GAAIwC,EAAKxC,KAAOjB,GAAYyD,EAAKxC,GAAGjB,WAAaA,EAAU,CACzD2D,EAAmBF,EAAKxC,GAAGjB,SAC3B0D,EAAWzC,EACX,MAIJ,GAAIyC,EAAW,EACb,OAAO0D,KAEQ,IAAb1D,EACFD,EAAKG,QAiIf,SAAmBH,EAAMmB,GAChBA,KAAAA,EAAQ,EAAInB,EAAKtC,OAAQyD,IAC9BnB,EAAKmB,GAASnB,EAAKmB,EAAQ,GAC7BnB,EAAKoB,MAlIGhB,CAAUJ,EAAMC,GAGE,IAAhBD,EAAKtC,SACPG,EAAON,GAAQyC,EAAK,SAEQ9D,IAA1B2B,EAAO4B,gBACTkE,KAAKrG,KAAK,iBAAkBC,EAAM2C,GAAoB3D,GAG1D,OAAOoH,MAGb/H,EAAahB,UAAUyF,IAAMzE,EAAahB,UAAU6E,eAEpD7D,EAAahB,UAAU0F,mBACnB,SAA4B/C,GAC1B,IAAIe,EAAWT,EAAQL,EAGvB,QAAetB,KADf2B,EAAS8F,KAAK1H,SAEZ,OAAO0H,KAGT,QAA8BzH,IAA1B2B,EAAO4B,eAUT,OATyB,IAArBhC,UAAUC,QACZiG,KAAK1H,QAAUjB,OAAOgC,OAAO,MACxBb,KAAAA,aAAe,QACMD,IAAjB2B,EAAON,KACY,KAAtBoG,KAAKxH,aACTwH,KAAK1H,QAAUjB,OAAOgC,OAAO,aAEtBa,EAAON,IAEXoG,KAIT,GAAyB,IAArBlG,UAAUC,OAAc,CAC1B,IACI8C,EADAD,EAAOvF,OAAOuF,KAAK1C,GAEvB,IAAKL,EAAI,EAAGA,EAAI+C,EAAK7C,SAAUF,EAEjB,oBADZgD,EAAMD,EAAK/C,KAEN8C,KAAAA,mBAAmBE,GAK1B,OAHKF,KAAAA,mBAAmB,kBACxBqD,KAAK1H,QAAUjB,OAAOgC,OAAO,MACxBb,KAAAA,aAAe,EACbwH,KAKT,GAAyB,mBAFzBrF,EAAYT,EAAON,IAGjBoG,KAAKlE,eAAelC,EAAMe,QACrB,QAAkBpC,IAAdoC,EAET,IAAKd,EAAIc,EAAUZ,OAAS,EAAGF,GAAK,EAAGA,IACrCmG,KAAKlE,eAAelC,EAAMe,EAAUd,IAIxC,OAAOmG,MAoBb/H,EAAahB,UAAU0D,UAAY,SAAmBf,GACpD,OAAOkD,EAAWkD,KAAMpG,GAAM,IAGhC3B,EAAahB,UAAUiG,aAAe,SAAsBtD,GAC1D,OAAOkD,EAAWkD,KAAMpG,GAAM,IAGhC3B,EAAakF,cAAgB,SAAS5B,EAAS3B,GAC7C,MAAqC,mBAA1B2B,EAAQ4B,cACV5B,EAAQ4B,cAAcvD,GAEtBuD,EAAcjG,KAAKqE,EAAS3B,IAIvC3B,EAAahB,UAAUkG,cAAgBA,EAiBvClF,EAAahB,UAAUmG,WAAa,WAC3B,OAAA4C,KAAKxH,aAAe,EAAIrB,EAAe6I,KAAK1H,SAAW,ICjZ1C,oBAAX8H,SACTF,EAASjJ,UAAUmJ,OAAOC,UAAY,WACpC,OAAOL,OASHM,EAACC,GAAK,WACRxJ,IAAAA,EAAO+C,UACT0E,EAAIzH,EAAKgD,OACTF,EAAI,EAEC,OAAA,IAAIqG,GAAS,WAClB,OAAIrG,GAAK2E,EAAU,CAACgC,MAAM,GAEnB,CAACA,MAAM,EAAOxI,MAAOjB,EAAK8C,UAS7ByG,EAACG,MAAQ,WAKf,OAJe,IAAIP,GAAS,WACnB,MAAA,CAACM,MAAM,OAYlBN,EAASQ,aAAe,SAAUC,GAC5B9G,IAAAA,EAAI,EACN2E,EAAImC,EAAS5G,OAER,OAAA,IAAImG,GAAS,WAClB,OAAIrG,GAAK2E,EAAU,CAACgC,MAAM,GAEnB,CAACA,MAAM,EAAOxI,MAAO2I,EAAS9G,UAUzCqG,EAASU,GAAK,SAAU5I,GACtB,OAAIA,aAAiBkI,GAGF,iBAAVlI,GACG,OAAVA,GACsB,mBAAfA,EAAMmI,MAOjB,IAAAE,EAAiBH,OC/FjBW,EAAAC,qBAAsD,oBAAhBC,YACtCF,EAAAG,eAA2C,oBAAXZ,OCMhC,IAAIF,EAAWe,EACXJ,EAAUK,EAEVJ,EAAuBD,EAAQC,qBAC/BE,EAAiBH,EAAQG,eAyB7B,IAAAG,EAAiB,SAActK,GAC7B,IAAIwJ,EAxBN,SAAoBxJ,GAElB,MACoB,iBAAXA,GACP0G,MAAMwC,QAAQlJ,IACbiK,GAAwBC,YAAYK,OAAOvK,GAErCqJ,EAASQ,aAAa7J,GAGT,iBAAXA,GAAkC,OAAXA,EAAwB,KAGtDmK,GAAqD,mBAA5BnK,EAAOuJ,OAAOC,UAClCxJ,EAAOuJ,OAAOC,YAGI,mBAAhBxJ,EAAOsJ,KAA4BtJ,EAGvC,KAIQwK,CAAWxK,GAEtB,IAACwJ,EACH,MAAM,IAAIhG,MACR,6DAGJ,OAAOgG,GCpCLc,EAAOF,EASXK,EAAiB,SAAcC,EAAUhI,GAQvC,IAPIiF,IAEFgD,EAFEhD,EAAI1E,UAAUC,OAAS,EAAIR,EAAIkI,EAAAA,EACjCC,EAAQlD,IAAMiD,EAAAA,EAAW,IAAIlE,MAAMiB,GAAK,GAExC3E,EAAI,EAEFwG,EAAWc,EAAKI,KAEP,CACX,GAAI1H,IAAM2E,EAAG,OAAOkD,EAIhBF,IAFJA,EAAOnB,EAASF,QAEPK,KAGP,OAFI3G,IAAMN,IAAGmI,EAAM3H,OAASF,GAErB6H,EAGTA,EAAM7H,KAAO2H,EAAKxJ,QC5BT2J,EAAb,SAAAC,GACE,SAAAD,EAAYpH,GAAS,IAAAsH,EAAA,OACnBA,EAAAD,EAAA1K,KAAA8I,OAAAA,MACK1E,KAAO,aACPf,EAAAA,QAAUA,EAHIsH,EADvB,OAAAC,EAAAH,EAAAC,GAAAD,EAAA,CAAAI,EAAgC1H,QAQnB2H,EAAb,SAAAC,GACE,SAAAD,EAAYzH,GAAS,IAAA2H,EAAA,OACnBA,EAAAD,EAAA/K,KAAA8I,KAAMzF,IAANyF,MACK1E,KAAO,6BAG2B,mBAA5BjB,MAAM8H,mBACf9H,MAAM8H,kBAEJH,EAAAA,GAAAA,EAA2B/K,UAAUmI,aARtB8C,EADvB,OAAAJ,EAAAE,EAAAC,GAAAD,EAAA,CAAgDL,GAcnCS,EAAb,SAAAC,GACE,SAAAD,EAAY7H,GAAS,IAAA+H,EAAA,OACnBA,EAAAD,EAAAnL,KAAA8I,KAAMzF,IAANyF,MACK1E,KAAO,qBAG2B,mBAA5BjB,MAAM8H,mBACf9H,MAAM8H,kBAAwBC,EAAAA,GAAAA,EAAmBnL,UAAUmI,aAN1CkD,EADvB,OAAAR,EAAAM,EAAAC,GAAAD,EAAA,CAAwCT,GAW3BY,EAAb,SAAAC,GACE,SAAAD,EAAYhI,GAAS,IAAAkI,EAAA,OACnBA,EAAAD,EAAAtL,KAAA8I,KAAMzF,IAANyF,MACK1E,KAAO,kBAG2B,mBAA5BjB,MAAM8H,mBACf9H,MAAM8H,kBAAwBI,EAAAA,GAAAA,EAAgBtL,UAAUmI,aANvCqD,EADvB,OAAAX,EAAAS,EAAAC,GAAAD,EAAA,CAAqCZ,GCvB9B,SAASe,EAAc7F,EAAKiD,GAE5BjD,KAAAA,IAAMA,EACNiD,KAAAA,WAAaA,EAElBE,KAAK2C,QAsBA,SAASC,EAAiB/F,EAAKiD,GAE/BjD,KAAAA,IAAMA,EACNiD,KAAAA,WAAaA,EAElBE,KAAK2C,QAoBA,SAASE,EAAmBhG,EAAKiD,GAEjCjD,KAAAA,IAAMA,EACNiD,KAAAA,WAAaA,EAElBE,KAAK2C,QAqBA,SAASG,EAAS7D,EAAYpC,EAAK+B,EAAQ/H,EAAQiJ,GAEnDjD,KAAAA,IAAMA,EACNiD,KAAAA,WAAaA,EAClBE,KAAKf,WAAaA,EAGbL,KAAAA,OAASA,EACT/H,KAAAA,OAASA,EA9EhB6L,EAAczL,UAAU0L,MAAQ,WAEzBI,KAAAA,SAAW,EACXC,KAAAA,UAAY,EACjBhD,KAAKiD,iBAAmB,EAGxBjD,KAAA,GAAU,GACLhB,KAAAA,IAAM,GACNC,KAAAA,WAAa,IAkBpB2D,EAAiB3L,UAAU0L,MAAQ,WAE5BI,KAAAA,SAAW,EAChB/C,KAAKgD,UAAY,EAGjBhD,KAAA,GAAU,GACLhB,KAAAA,IAAM,IAkBb6D,EAAmB5L,UAAU0L,MAAQ,WAEnC3C,KAAKiD,iBAAmB,EAGnBhE,KAAAA,WAAa,IAwBpB6D,EAAS7L,UAAUiM,OAAS,WACtBC,IAAAA,EAAS,MACTC,EAAQ,KAERpD,KAAKf,aAAYkE,EAASC,EAAQ,cAEtC,IAAMxE,EAASoB,KAAKpB,OAAO/B,IACrBhG,EAASmJ,KAAKnJ,OAAOgG,IAG3BmD,KAAKpB,OAAOuE,GAAQtM,GAAUmJ,KAE1BA,KAAKf,YAAcL,IAAW/H,IAGlCmJ,KAAKnJ,OAAOuM,GAAOxE,GAAUoB,OAG/B8C,EAAS7L,UAAUoM,YAAc,WAC3BF,IAAAA,EAAS,MACTC,EAAQ,KAENxE,EAASoB,KAAKpB,OAAO/B,IACrBhG,EAASmJ,KAAKnJ,OAAOgG,IAEvBmD,KAAKf,aAAYkE,EAASC,EAAQ,cAGtC,IAAME,EAAMtD,KAAKpB,OAAOuE,GAClBI,EAAOD,EAAIzM,GAEjB,QAAoB,IAAT0M,EAST,OARAD,EAAIzM,GAAUmJ,UAGRA,KAAKf,YAAcL,IAAW/H,IAElCmJ,KAAKnJ,OAAOuM,GAAOxE,GAAUoB,OAOjCuD,EAAKC,SAAWxD,KAChBA,KAAKG,KAAOoD,EAIZD,EAAIzM,GAAUmJ,KACdA,KAAKnJ,OAAOuM,GAAOxE,GAAUoB,MAG/B8C,EAAS7L,UAAUwM,OAAS,WAC1B,IAAM7E,EAASoB,KAAKpB,OAAO/B,IACrBhG,EAASmJ,KAAKnJ,OAAOgG,IAEvBsG,EAAS,MACTC,EAAQ,KAERpD,KAAKf,aAAYkE,EAASC,EAAQ,qBAE/BpD,KAAKpB,OAAOuE,GAAQtM,UAGpBmJ,KAAKnJ,OAAOuM,GAAOxE,IAG5BkE,EAAS7L,UAAUyM,YAAc,WAC/B,IAAM9E,EAASoB,KAAKpB,OAAO/B,IACrBhG,EAASmJ,KAAKnJ,OAAOgG,IAEvBsG,EAAS,MACTC,EAAQ,KAERpD,KAAKf,aAAYkE,EAASC,EAAQ,mBAGhB7K,IAAlByH,KAAKwD,cAIWjL,IAAdyH,KAAKG,aACAH,KAAKpB,OAAOuE,GAAQtM,UAGpBmJ,KAAKnJ,OAAOuM,GAAOxE,KAG1BoB,KAAKG,KAAKqD,cAAWjL,EAGhBqG,KAAAA,OAAOuE,GAAQtM,GAAUmJ,KAAKG,KAGnCH,KAAKnJ,OAAOuM,GAAOxE,GAAUoB,KAAKG,OAIpCH,KAAKwD,SAASrD,KAAOH,KAAKG,UAGR5H,IAAdyH,KAAKG,OACPH,KAAKG,KAAKqD,SAAWxD,KAAKwD,YCrMhC,SAASG,EACPhF,EACAiF,EACAC,EACAC,EACAC,EACAC,EACAC,GAEA,IAAIC,EAAUC,EAAUC,EAAMC,EAI1BR,GAFJC,EAAa,GAAKA,EAhBP,IAkBPD,EAAe,CAGb,KAFJK,EAAWvF,EAAMG,OAAO9F,IAAI8K,IAG1B,MAAM,IAAI1B,EACCwB,SAAAA,OAAAA,EAA+BE,0BAAAA,OAAAA,EAD1C,yBAIFM,EAAOL,EACPM,EAAOL,OACF,GAzBQ,IAyBJH,EAAmB,CAKxB,GAJJE,EAAa,GAAKA,IAElBI,EAAWxF,EAAM2F,OAAOtL,IAAI+K,IAG1B,MAAM,IAAI3B,EACCwB,SAAAA,OAAAA,EAA+BG,0BAAAA,OAAAA,EAD1C,yBAIF,IAAMnF,EAASuF,EAASvF,OAAO/B,IACzBhG,EAASsN,EAAStN,OAAOgG,IAE3BiH,GAAAA,IAAelF,EACjBsF,EAAWC,EAAStN,WACf,CAAA,GAAIiN,IAAejN,EAGxB,MAAM,IAAIuL,EACCwB,SAAAA,OAAAA,EAAgBE,WAAAA,OAAAA,EAA4CC,mCAAAA,OAAAA,EAAqBnF,YAAAA,OAAAA,EAAW/H,MAAAA,OAAAA,EADvG,OAFAqN,EAAWC,EAASvF,OAOtBwF,EAAOJ,EACPK,EAAOJ,MACF,CAGD,KAFJE,EAAWxF,EAAM2F,OAAOtL,IAAI8K,IAG1B,MAAM,IAAI1B,EACCwB,SAAAA,OAAAA,EAA+BE,0BAAAA,OAAAA,EAD1C,yBAKAI,EA7DS,IA4DPL,EACSM,EAASvF,OAETuF,EAAStN,OAGtBuN,EAAOL,EACPM,EAAOL,EAGT,MAAO,CAACE,EAAUE,EAAMC,GA+N1B,IAAME,EAA0B,CAC9B,CACEjJ,KAAM,SAAAkJ,GAAO,MAAA,MAAAhN,OAAUgN,EAAV,cACbC,SA/NJ,SAAmCC,EAAOd,EAAQC,GAChDa,EAAMzN,UAAU2M,GAAU,SAAUE,EAAYC,EAAYC,GAC1D,IAAAW,EAAqBhB,EACnB3D,KACA4D,EACAC,EACAC,EACAC,EACAC,GANKY,EAAPD,EAAA,GAAarJ,EAAbqJ,EAAA,GASA,OAAOC,EAAK9E,WAAWxE,MAsNzB,CACEA,KAAM,SAAAkJ,GAAO,MAAA,MAAAhN,OAAUgN,EAAV,eACbC,SApNJ,SAAoCC,EAAOd,EAAQC,GACjDa,EAAMzN,UAAU2M,GAAU,SAAUE,EAAYC,GASvCa,OARQjB,EACb3D,KACA4D,EACAC,EACAC,EACAC,GALF,GAQYjE,cA4Md,CACExE,KAAM,SAAAkJ,GAAO,MAAA,MAAAhN,OAAUgN,EAAV,cACbC,SA1MJ,SAAoCC,EAAOd,EAAQC,GACjDa,EAAMzN,UAAU2M,GAAU,SAAUE,EAAYC,EAAYC,GAC1D,IAAAa,EAAqBlB,EACnB3D,KACA4D,EACAC,EACAC,EACAC,EACAC,GANKY,EAAPC,EAAA,GAAavJ,EAAbuJ,EAAA,GASA,OAAOD,EAAK9E,WAAWgF,eAAexJ,MAiMxC,CACEA,KAAM,SAAAkJ,GAAO,MAAA,MAAAhN,OAAUgN,EAAV,cACbC,SA/LJ,SAAmCC,EAAOd,EAAQC,GAChDa,EAAMzN,UAAU2M,GAAU,SAAUE,EAAYC,EAAYC,EAAMC,GAChE,IAAAc,EAA4BpB,EAC1B3D,KACA4D,EACAC,EACAC,EACAC,EACAC,EACAC,GAPKW,EAAPG,EAAA,GAAazJ,EAAbyJ,EAAA,GAAmB/M,EAAnB+M,EAAA,GAoBA,OAVAH,EAAK9E,WAAWxE,GAAQtD,EAGnB2B,KAAAA,KAAK,wBAAyB,CACjCkD,IAAK+H,EAAK/H,IACVjD,KAAM,MACNkG,WAAY8E,EAAK9E,WACjBxE,KAAAA,IAGK0E,QA2KT,CACE1E,KAAM,SAAAkJ,GAAO,MAAA,SAAAhN,OAAagN,EAAb,cACbC,SAzKJ,SAAoCC,EAAOd,EAAQC,GACjDa,EAAMzN,UAAU2M,GAAU,SAAUE,EAAYC,EAAYC,EAAMC,GAChE,IAAAe,EAA8BrB,EAC5B3D,KACA4D,EACAC,EACAC,EACAC,EACAC,EACAC,GAPKW,EAAPI,EAAA,GAAa1J,EAAb0J,EAAA,GAAmBC,EAAnBD,EAAA,GAUI,GAAmB,mBAAZC,EACT,MAAM,IAAIjD,EACC4B,SAAAA,OAAAA,EADX,oCAIF,IAAM9D,EAAa8E,EAAK9E,WAClB9H,EAAQiN,EAAQnF,EAAWxE,IAYjC,OAVAwE,EAAWxE,GAAQtD,EAGd2B,KAAAA,KAAK,wBAAyB,CACjCkD,IAAK+H,EAAK/H,IACVjD,KAAM,MACNkG,WAAY8E,EAAK9E,WACjBxE,KAAAA,IAGK0E,QA6IT,CACE1E,KAAM,SAAAkJ,GAAO,MAAA,SAAAhN,OAAagN,EAAb,cACbC,SA3IJ,SAAoCC,EAAOd,EAAQC,GACjDa,EAAMzN,UAAU2M,GAAU,SAAUE,EAAYC,EAAYC,GAC1D,IAAAkB,EAAqBvB,EACnB3D,KACA4D,EACAC,EACAC,EACAC,EACAC,GANKY,EAAPM,EAAA,GAAa5J,EAAb4J,EAAA,GAmBA,cAVON,EAAK9E,WAAWxE,GAGlB3B,KAAAA,KAAK,wBAAyB,CACjCkD,IAAK+H,EAAK/H,IACVjD,KAAM,SACNkG,WAAY8E,EAAK9E,WACjBxE,KAAAA,IAGK0E,QAwHT,CACE1E,KAAM,SAAAkJ,GAAO,MAAA,UAAAhN,OAAcgN,EAAd,eACbC,SAtHJ,SAAsCC,EAAOd,EAAQC,GACnDa,EAAMzN,UAAU2M,GAAU,SAAUE,EAAYC,EAAYC,GAC1D,IAAAmB,EAA2BxB,EACzB3D,KACA4D,EACAC,EACAC,EACAC,EACAC,GANKY,EAAPO,EAAA,GAAarF,EAAbqF,EAAA,GASI,IAACjG,EAAcY,GACjB,MAAM,IAAIkC,EACC4B,SAAAA,OAAAA,EADX,kDAaF,OATAgB,EAAK9E,WAAaA,EAGbnG,KAAAA,KAAK,wBAAyB,CACjCkD,IAAK+H,EAAK/H,IACVjD,KAAM,UACNkG,WAAY8E,EAAK9E,aAGZE,QA+FT,CACE1E,KAAM,SAAAkJ,GAAO,MAAA,QAAAhN,OAAYgN,EAAZ,eACbC,SA7FJ,SAAoCC,EAAOd,EAAQC,GACjDa,EAAMzN,UAAU2M,GAAU,SAAUE,EAAYC,EAAYC,GAC1D,IAAAoB,EAA2BzB,EACzB3D,KACA4D,EACAC,EACAC,EACAC,EACAC,GANKY,EAAPQ,EAAA,GAAatF,EAAbsF,EAAA,GASI,IAAClG,EAAcY,GACjB,MAAM,IAAIkC,EACC4B,SAAAA,OAAAA,EADX,kDAcF,OAVArF,EAAOqG,EAAK9E,WAAYA,GAGnBnG,KAAAA,KAAK,wBAAyB,CACjCkD,IAAK+H,EAAK/H,IACVjD,KAAM,QACNkG,WAAY8E,EAAK9E,WACjB8E,KAAM9E,IAGDE,QAqET,CACE1E,KAAM,SAAAkJ,GAAO,MAAA,SAAAhN,OAAagN,EAAb,eACbC,SAnEJ,SAAqCC,EAAOd,EAAQC,GAClDa,EAAMzN,UAAU2M,GAAU,SAAUE,EAAYC,EAAYC,GAC1D,IAAAqB,EAAwB1B,EACtB3D,KACA4D,EACAC,EACAC,EACAC,EACAC,GANKY,EAAPS,EAAA,GAAaJ,EAAbI,EAAA,GASI,GAAmB,mBAAZJ,EACT,MAAM,IAAIjD,EACC4B,SAAAA,OAAAA,EADX,0CAaF,OATAgB,EAAK9E,WAAamF,EAAQL,EAAK9E,YAG1BnG,KAAAA,KAAK,wBAAyB,CACjCkD,IAAK+H,EAAK/H,IACVjD,KAAM,SACNkG,WAAY8E,EAAK9E,aAGZE,SCsaX,IAAMsF,EAA0B,CAC9B,CACEhK,KAAM,SAAAkJ,GAAO,MAAA,MAAAhN,OAAUgN,EAAV,cACbC,SA7rBJ,SAAmCC,EAAOd,EAAQhK,GAkBhD8K,EAAMzN,UAAU2M,GAAU,SAAUY,EAASlJ,GAC3C,IAAIsJ,EAEA,GAAc,UAAd5E,KAAKpG,MAA6B,UAATA,GAAoBA,IAASoG,KAAKpG,KAC7D,MAAM,IAAI2I,kBACCqB,EADL,6CAAApM,OACuDwI,KAAKpG,KADlE,YAIF,GAAIE,UAAUC,OAAS,EAAG,CACpB,GAAAiG,KAAKuF,MACP,MAAM,IAAIhD,EAAJ,SAAA/K,OACKoM,EADX,0JAIIhF,IAAAA,EAAS,GAAK4F,EACd3N,EAAS,GAAKyE,EAMpB,GAJAA,EAAOxB,UAAU,KAEjB8K,EAAOlG,EAAgBsB,KAAMpB,EAAQ/H,EAAQ+C,IAG3C,MAAM,IAAIwI,EACCwB,SAAAA,OAAAA,EAAuDhF,kDAAAA,OAAAA,EAAc/H,SAAAA,OAAAA,EADhF,YAGG,CACD+C,GAAS,UAATA,EACF,MAAM,IAAI2I,EACCqB,SAAAA,OAAAA,EADX,+IAOE,GAHJY,EAAU,GAAKA,IACfI,EAAO5E,KAAKsE,OAAOtL,IAAIwL,IAGrB,MAAM,IAAIpC,EACCwB,SAAAA,OAAAA,EAA+BY,0BAAAA,OAAAA,EAD1C,yBAKJ,OAAOI,EAAK9E,WAAWxE,MAqoBzB,CACEA,KAAM,SAAAkJ,GAAO,MAAA,MAAAhN,OAAUgN,EAAV,eACbC,SA5nBJ,SAAoCC,EAAOd,EAAQhK,GAgBjD8K,EAAMzN,UAAU2M,GAAU,SAAUY,GAClC,IAAII,EAEA,GAAc,UAAd5E,KAAKpG,MAA6B,UAATA,GAAoBA,IAASoG,KAAKpG,KAC7D,MAAM,IAAI2I,kBACCqB,EADL,6CAAApM,OACuDwI,KAAKpG,KADlE,YAIF,GAAIE,UAAUC,OAAS,EAAG,CACpB,GAAAiG,KAAKuF,MACP,MAAM,IAAIhD,EAAJ,SAAA/K,OACKoM,EADX,0JAIIhF,IAAAA,EAAS,GAAK4F,EAClB3N,EAAS,GAAKiD,UAAU,GAI1B,KAFA8K,EAAOlG,EAAgBsB,KAAMpB,EAAQ/H,EAAQ+C,IAG3C,MAAM,IAAIwI,EACCwB,SAAAA,OAAAA,EAAuDhF,kDAAAA,OAAAA,EAAc/H,SAAAA,OAAAA,EADhF,YAGG,CACD+C,GAAS,UAATA,EACF,MAAM,IAAI2I,EACCqB,SAAAA,OAAAA,EADX,+IAOE,GAHJY,EAAU,GAAKA,IACfI,EAAO5E,KAAKsE,OAAOtL,IAAIwL,IAGrB,MAAM,IAAIpC,EACCwB,SAAAA,OAAAA,EAA+BY,0BAAAA,OAAAA,EAD1C,yBAKGI,OAAAA,EAAK9E,cAwkBd,CACExE,KAAM,SAAAkJ,GAAO,MAAA,MAAAhN,OAAUgN,EAAV,cACbC,SA/jBJ,SAAoCC,EAAOd,EAAQhK,GAkBjD8K,EAAMzN,UAAU2M,GAAU,SAAUY,EAASlJ,GAC3C,IAAIsJ,EAEA,GAAc,UAAd5E,KAAKpG,MAA6B,UAATA,GAAoBA,IAASoG,KAAKpG,KAC7D,MAAM,IAAI2I,kBACCqB,EADL,6CAAApM,OACuDwI,KAAKpG,KADlE,YAIF,GAAIE,UAAUC,OAAS,EAAG,CACpB,GAAAiG,KAAKuF,MACP,MAAM,IAAIhD,EAAJ,SAAA/K,OACKoM,EADX,0JAIIhF,IAAAA,EAAS,GAAK4F,EACd3N,EAAS,GAAKyE,EAMpB,GAJAA,EAAOxB,UAAU,KAEjB8K,EAAOlG,EAAgBsB,KAAMpB,EAAQ/H,EAAQ+C,IAG3C,MAAM,IAAIwI,EACCwB,SAAAA,OAAAA,EAAuDhF,kDAAAA,OAAAA,EAAc/H,SAAAA,OAAAA,EADhF,YAGG,CACD+C,GAAS,UAATA,EACF,MAAM,IAAI2I,EACCqB,SAAAA,OAAAA,EADX,+IAOE,GAHJY,EAAU,GAAKA,IACfI,EAAO5E,KAAKsE,OAAOtL,IAAIwL,IAGrB,MAAM,IAAIpC,EACCwB,SAAAA,OAAAA,EAA+BY,0BAAAA,OAAAA,EAD1C,yBAKJ,OAAOI,EAAK9E,WAAWgF,eAAexJ,MAugBxC,CACEA,KAAM,SAAAkJ,GAAO,MAAA,MAAAhN,OAAUgN,EAAV,cACbC,SA9fJ,SAAmCC,EAAOd,EAAQhK,GAoBhD8K,EAAMzN,UAAU2M,GAAU,SAAUY,EAASlJ,EAAMtD,GACjD,IAAI4M,EAEA,GAAc,UAAd5E,KAAKpG,MAA6B,UAATA,GAAoBA,IAASoG,KAAKpG,KAC7D,MAAM,IAAI2I,kBACCqB,EADL,6CAAApM,OACuDwI,KAAKpG,KADlE,YAIF,GAAIE,UAAUC,OAAS,EAAG,CACpB,GAAAiG,KAAKuF,MACP,MAAM,IAAIhD,EAAJ,SAAA/K,OACKoM,EADX,0JAIIhF,IAAAA,EAAS,GAAK4F,EACd3N,EAAS,GAAKyE,EAOpB,GALAA,EAAOxB,UAAU,GACjB9B,EAAQ8B,UAAU,KAElB8K,EAAOlG,EAAgBsB,KAAMpB,EAAQ/H,EAAQ+C,IAG3C,MAAM,IAAIwI,EACCwB,SAAAA,OAAAA,EAAuDhF,kDAAAA,OAAAA,EAAc/H,SAAAA,OAAAA,EADhF,YAGG,CACD+C,GAAS,UAATA,EACF,MAAM,IAAI2I,EACCqB,SAAAA,OAAAA,EADX,+IAOE,GAHJY,EAAU,GAAKA,IACfI,EAAO5E,KAAKsE,OAAOtL,IAAIwL,IAGrB,MAAM,IAAIpC,EACCwB,SAAAA,OAAAA,EAA+BY,0BAAAA,OAAAA,EAD1C,yBAeJ,OAVAI,EAAK9E,WAAWxE,GAAQtD,EAGnB2B,KAAAA,KAAK,wBAAyB,CACjCkD,IAAK+H,EAAK/H,IACVjD,KAAM,MACNkG,WAAY8E,EAAK9E,WACjBxE,KAAAA,IAGK0E,QAybT,CACE1E,KAAM,SAAAkJ,GAAO,MAAA,SAAAhN,OAAagN,EAAb,cACbC,SAhbJ,SAAoCC,EAAOd,EAAQhK,GAqBjD8K,EAAMzN,UAAU2M,GAAU,SAAUY,EAASlJ,EAAM2J,GACjD,IAAIL,EAEA,GAAc,UAAd5E,KAAKpG,MAA6B,UAATA,GAAoBA,IAASoG,KAAKpG,KAC7D,MAAM,IAAI2I,kBACCqB,EADL,6CAAApM,OACuDwI,KAAKpG,KADlE,YAIF,GAAIE,UAAUC,OAAS,EAAG,CACpB,GAAAiG,KAAKuF,MACP,MAAM,IAAIhD,EAAJ,SAAA/K,OACKoM,EADX,0JAIIhF,IAAAA,EAAS,GAAK4F,EACd3N,EAAS,GAAKyE,EAOpB,GALAA,EAAOxB,UAAU,GACjBmL,EAAUnL,UAAU,KAEpB8K,EAAOlG,EAAgBsB,KAAMpB,EAAQ/H,EAAQ+C,IAG3C,MAAM,IAAIwI,EACCwB,SAAAA,OAAAA,EAAuDhF,kDAAAA,OAAAA,EAAc/H,SAAAA,OAAAA,EADhF,YAGG,CACD+C,GAAS,UAATA,EACF,MAAM,IAAI2I,EACCqB,SAAAA,OAAAA,EADX,+IAOE,GAHJY,EAAU,GAAKA,IACfI,EAAO5E,KAAKsE,OAAOtL,IAAIwL,IAGrB,MAAM,IAAIpC,EACCwB,SAAAA,OAAAA,EAA+BY,0BAAAA,OAAAA,EAD1C,yBAKA,GAAmB,mBAAZS,EACT,MAAM,IAAIjD,EACC4B,SAAAA,OAAAA,EADX,oCAcF,OAVAgB,EAAK9E,WAAWxE,GAAQ2J,EAAQL,EAAK9E,WAAWxE,IAG3C3B,KAAAA,KAAK,wBAAyB,CACjCkD,IAAK+H,EAAK/H,IACVjD,KAAM,MACNkG,WAAY8E,EAAK9E,WACjBxE,KAAAA,IAGK0E,QAqWT,CACE1E,KAAM,SAAAkJ,GAAO,MAAA,SAAAhN,OAAagN,EAAb,cACbC,SA5VJ,SAAoCC,EAAOd,EAAQhK,GAkBjD8K,EAAMzN,UAAU2M,GAAU,SAAUY,EAASlJ,GAC3C,IAAIsJ,EAEA,GAAc,UAAd5E,KAAKpG,MAA6B,UAATA,GAAoBA,IAASoG,KAAKpG,KAC7D,MAAM,IAAI2I,kBACCqB,EADL,6CAAApM,OACuDwI,KAAKpG,KADlE,YAIF,GAAIE,UAAUC,OAAS,EAAG,CACpB,GAAAiG,KAAKuF,MACP,MAAM,IAAIhD,EAAJ,SAAA/K,OACKoM,EADX,0JAIIhF,IAAAA,EAAS,GAAK4F,EACd3N,EAAS,GAAKyE,EAMpB,GAJAA,EAAOxB,UAAU,KAEjB8K,EAAOlG,EAAgBsB,KAAMpB,EAAQ/H,EAAQ+C,IAG3C,MAAM,IAAIwI,EACCwB,SAAAA,OAAAA,EAAuDhF,kDAAAA,OAAAA,EAAc/H,SAAAA,OAAAA,EADhF,YAGG,CACD+C,GAAS,UAATA,EACF,MAAM,IAAI2I,EACCqB,SAAAA,OAAAA,EADX,+IAOE,GAHJY,EAAU,GAAKA,IACfI,EAAO5E,KAAKsE,OAAOtL,IAAIwL,IAGrB,MAAM,IAAIpC,EACCwB,SAAAA,OAAAA,EAA+BY,0BAAAA,OAAAA,EAD1C,yBAeJ,cAVOI,EAAK9E,WAAWxE,GAGlB3B,KAAAA,KAAK,wBAAyB,CACjCkD,IAAK+H,EAAK/H,IACVjD,KAAM,SACNkG,WAAY8E,EAAK9E,WACjBxE,KAAAA,IAGK0E,QA0RT,CACE1E,KAAM,SAAAkJ,GAAO,MAAA,UAAAhN,OAAcgN,EAAd,eACbC,SAjRJ,SAAsCC,EAAOd,EAAQhK,GAkBnD8K,EAAMzN,UAAU2M,GAAU,SAAUY,EAAS1E,GAC3C,IAAI8E,EAEA,GAAc,UAAd5E,KAAKpG,MAA6B,UAATA,GAAoBA,IAASoG,KAAKpG,KAC7D,MAAM,IAAI2I,kBACCqB,EADL,6CAAApM,OACuDwI,KAAKpG,KADlE,YAIF,GAAIE,UAAUC,OAAS,EAAG,CACpB,GAAAiG,KAAKuF,MACP,MAAM,IAAIhD,EAAJ,SAAA/K,OACKoM,EADX,0JAIIhF,IAAAA,EAAS,GAAK4F,EAClB3N,EAAS,GAAKiJ,EAMhB,GAJAA,EAAahG,UAAU,KAEvB8K,EAAOlG,EAAgBsB,KAAMpB,EAAQ/H,EAAQ+C,IAG3C,MAAM,IAAIwI,EACCwB,SAAAA,OAAAA,EAAuDhF,kDAAAA,OAAAA,EAAc/H,SAAAA,OAAAA,EADhF,YAGG,CACD+C,GAAS,UAATA,EACF,MAAM,IAAI2I,EACCqB,SAAAA,OAAAA,EADX,+IAOE,GAHJY,EAAU,GAAKA,IACfI,EAAO5E,KAAKsE,OAAOtL,IAAIwL,IAGrB,MAAM,IAAIpC,EACCwB,SAAAA,OAAAA,EAA+BY,0BAAAA,OAAAA,EAD1C,yBAKA,IAACtF,EAAcY,GACjB,MAAM,IAAIkC,EACC4B,SAAAA,OAAAA,EADX,kDAaF,OATAgB,EAAK9E,WAAaA,EAGbnG,KAAAA,KAAK,wBAAyB,CACjCkD,IAAK+H,EAAK/H,IACVjD,KAAM,UACNkG,WAAY8E,EAAK9E,aAGZE,QA2MT,CACE1E,KAAM,SAAAkJ,GAAO,MAAA,QAAAhN,OAAYgN,EAAZ,eACbC,SAlMJ,SAAoCC,EAAOd,EAAQhK,GAkBjD8K,EAAMzN,UAAU2M,GAAU,SAAUY,EAAS1E,GAC3C,IAAI8E,EAEA,GAAc,UAAd5E,KAAKpG,MAA6B,UAATA,GAAoBA,IAASoG,KAAKpG,KAC7D,MAAM,IAAI2I,kBACCqB,EADL,6CAAApM,OACuDwI,KAAKpG,KADlE,YAIF,GAAIE,UAAUC,OAAS,EAAG,CACpB,GAAAiG,KAAKuF,MACP,MAAM,IAAIhD,EAAJ,SAAA/K,OACKoM,EADX,0JAIIhF,IAAAA,EAAS,GAAK4F,EAClB3N,EAAS,GAAKiJ,EAMhB,GAJAA,EAAahG,UAAU,KAEvB8K,EAAOlG,EAAgBsB,KAAMpB,EAAQ/H,EAAQ+C,IAG3C,MAAM,IAAIwI,EACCwB,SAAAA,OAAAA,EAAuDhF,kDAAAA,OAAAA,EAAc/H,SAAAA,OAAAA,EADhF,YAGG,CACD+C,GAAS,UAATA,EACF,MAAM,IAAI2I,EACCqB,SAAAA,OAAAA,EADX,+IAOE,GAHJY,EAAU,GAAKA,IACfI,EAAO5E,KAAKsE,OAAOtL,IAAIwL,IAGrB,MAAM,IAAIpC,EACCwB,SAAAA,OAAAA,EAA+BY,0BAAAA,OAAAA,EAD1C,yBAKA,IAACtF,EAAcY,GACjB,MAAM,IAAIkC,EACC4B,SAAAA,OAAAA,EADX,kDAcF,OAVArF,EAAOqG,EAAK9E,WAAYA,GAGnBnG,KAAAA,KAAK,wBAAyB,CACjCkD,IAAK+H,EAAK/H,IACVjD,KAAM,QACNkG,WAAY8E,EAAK9E,WACjB8E,KAAM9E,IAGDE,QA2HT,CACE1E,KAAM,SAAAkJ,GAAO,MAAA,SAAAhN,OAAagN,EAAb,eACbC,SAlHJ,SAAqCC,EAAOd,EAAQhK,GAkBlD8K,EAAMzN,UAAU2M,GAAU,SAAUY,EAASS,GAC3C,IAAIL,EAEA,GAAc,UAAd5E,KAAKpG,MAA6B,UAATA,GAAoBA,IAASoG,KAAKpG,KAC7D,MAAM,IAAI2I,kBACCqB,EADL,6CAAApM,OACuDwI,KAAKpG,KADlE,YAIF,GAAIE,UAAUC,OAAS,EAAG,CACpB,GAAAiG,KAAKuF,MACP,MAAM,IAAIhD,EAAJ,SAAA/K,OACKoM,EADX,0JAIIhF,IAAAA,EAAS,GAAK4F,EAClB3N,EAAS,GAAKoO,EAMhB,GAJAA,EAAUnL,UAAU,KAEpB8K,EAAOlG,EAAgBsB,KAAMpB,EAAQ/H,EAAQ+C,IAG3C,MAAM,IAAIwI,EACCwB,SAAAA,OAAAA,EAAuDhF,kDAAAA,OAAAA,EAAc/H,SAAAA,OAAAA,EADhF,YAGG,CACD+C,GAAS,UAATA,EACF,MAAM,IAAI2I,EACCqB,SAAAA,OAAAA,EADX,+IAOE,GAHJY,EAAU,GAAKA,IACfI,EAAO5E,KAAKsE,OAAOtL,IAAIwL,IAGrB,MAAM,IAAIpC,EACCwB,SAAAA,OAAAA,EAA+BY,0BAAAA,OAAAA,EAD1C,yBAKA,GAAmB,mBAAZS,EACT,MAAM,IAAIjD,EACC4B,SAAAA,OAAAA,EADX,0CAaF,OATAgB,EAAK9E,WAAamF,EAAQL,EAAK9E,YAG1BnG,KAAAA,KAAK,wBAAyB,CACjCkD,IAAK+H,EAAK/H,IACVjD,KAAM,SACNkG,WAAY8E,EAAK9E,aAGZE,SChsBX,IAAIE,EAAWe,EACXE,EAAOD,EAQXsE,GAAiB,WACXC,IAAAA,EAAY3L,UACZ4L,EAAU,KACV7L,GAAK,EAGT,OAAO,IAAIqG,GAAS,WAGf,IAFCsB,IAAAA,EAAO,OAER,CACGkE,GAAY,OAAZA,EAAkB,CAGpB,KAFA7L,GAES4L,EAAU1L,OAAQ,MAAO,CAACyG,MAAM,GAEzCkF,EAAUvE,EAAKsE,EAAU5L,IAK3B,IAAkB,KAFlB2H,EAAOkE,EAAQvF,QAENK,KAKT,MAJEkF,EAAU,KAOd,OAAOlE,MC3BLmE,GAAkB,CACtB,CACErK,KAAM,QACN1B,KAAM,SAER,CACE0B,KAAM,UACN1B,KAAM,WACNgM,UAAW,MAEb,CACEtK,KAAM,WACN1B,KAAM,WACNgM,UAAW,OAEb,CACEtK,KAAM,eACN1B,KAAM,QACNgM,UAAW,MAEb,CACEtK,KAAM,gBACN1B,KAAM,QACNgM,UAAW,OAEb,CACEtK,KAAM,gBACN1B,KAAM,YAER,CACE0B,KAAM,kBACN1B,KAAM,eAUV,SAASiM,GAAcC,EAAWC,EAAQC,EAAUC,GAC9CC,IAAAA,GAAc,EAElB,IAAK,IAAMzH,KAAKsH,EACVtH,GAAAA,IAAMwH,EAANxH,CAEJ,IAAM0F,EAAW4B,EAAOtH,GAYxB,GAVAyH,EAAcF,EACZ7B,EAAStH,IACTsH,EAASrE,WACTqE,EAASvF,OAAO/B,IAChBsH,EAAStN,OAAOgG,IAChBsH,EAASvF,OAAOkB,WAChBqE,EAAStN,OAAOiJ,WAChBqE,EAASlF,YAGP6G,GAAaI,EAAa,OAAO/B,EAAStH,KAMlD,SAASsJ,GAAaL,EAAWC,EAAQC,EAAUC,GACjD,IAAI9B,EAAUvF,EAAQ/H,EAElBqP,GAAc,EAElB,IAAK,IAAMzH,KAAKsH,EACVtH,GAAAA,IAAMwH,EAANxH,CAEJ0F,EAAW4B,EAAOtH,GAEf,EAAA,CAcD,GAbAG,EAASuF,EAASvF,OAClB/H,EAASsN,EAAStN,OAElBqP,EAAcF,EACZ7B,EAAStH,IACTsH,EAASrE,WACTlB,EAAO/B,IACPhG,EAAOgG,IACP+B,EAAOkB,WACPjJ,EAAOiJ,WACPqE,EAASlF,YAGP6G,GAAaI,EAAa,OAAO/B,EAAStH,IAE9CsH,EAAWA,EAAShE,gBACA5H,IAAb4L,IAYb,SAASiC,GAAeL,EAAQE,GAC9B,IAGI9B,EAHEvH,EAAOvF,OAAOuF,KAAKmJ,GACnBvH,EAAI5B,EAAK7C,OAGXF,EAAI,EAER,OAAO,IAAIqG,GAAS,WACf,GACG,GAACiE,EAYHA,EAAWA,EAAShE,SAZP,CACb,GAAItG,GAAK2E,EAAG,MAAO,CAACgC,MAAM,GAE1B,IAAM/B,EAAI7B,EAAK/C,KAEX4E,GAAAA,IAAMwH,EAAO,CACf9B,OAAW5L,EACX,SAGF4L,EAAW4B,EAAOtH,WAIZ0F,GAEH,MAAA,CACL3D,MAAM,EACNxI,MAAO,CACL+G,KAAMoF,EAAStH,IACfiD,WAAYqE,EAASrE,WACrBlB,OAAQuF,EAASvF,OAAO/B,IACxBhG,OAAQsN,EAAStN,OAAOgG,IACxBwJ,iBAAkBlC,EAASvF,OAAOkB,WAClCwG,iBAAkBnC,EAAStN,OAAOiJ,WAClCb,WAAYkF,EAASlF,gBAc7B,SAASsH,GAAoBT,EAAWC,EAAQtH,EAAGuH,GACjD,IAAM7B,EAAW4B,EAAOtH,GAEpB,GAAC0F,EAAD,CAEJ,IAAMtF,EAAasF,EAASvF,OACtB4H,EAAarC,EAAStN,OAE5B,OACEmP,EACE7B,EAAStH,IACTsH,EAASrE,WACTjB,EAAWhC,IACX2J,EAAW3J,IACXgC,EAAWiB,WACX0G,EAAW1G,WACXqE,EAASlF,aAEX6G,EAEO3B,EAAStH,SAZlB,GAeF,SAAS4J,GAAmBX,EAAWC,EAAQtH,EAAGuH,GAChD,IAAI7B,EAAW4B,EAAOtH,GAElB,GAAC0F,EAAD,CAEA+B,IAAAA,GAAc,EAEf,EAAA,CAWD,GAVAA,EAAcF,EACZ7B,EAAStH,IACTsH,EAASrE,WACTqE,EAASvF,OAAO/B,IAChBsH,EAAStN,OAAOgG,IAChBsH,EAASvF,OAAOkB,WAChBqE,EAAStN,OAAOiJ,WAChBqE,EAASlF,YAGP6G,GAAaI,EAAa,OAAO/B,EAAStH,IAE9CsH,EAAWA,EAAShE,gBACA5H,IAAb4L,IAYX,SAASuC,GAAqBX,EAAQtH,GACpC,IAAI0F,EAAW4B,EAAOtH,GAEtB,YAAsBlG,IAAlB4L,EAAShE,KACJ,IAAID,GAAS,WACd,IAACiE,EAAU,MAAO,CAAC3D,MAAM,GAE7B,IAAMxI,EAAQ,CACZ+G,KAAMoF,EAAStH,IACfiD,WAAYqE,EAASrE,WACrBlB,OAAQuF,EAASvF,OAAO/B,IACxBhG,OAAQsN,EAAStN,OAAOgG,IACxBwJ,iBAAkBlC,EAASvF,OAAOkB,WAClCwG,iBAAkBnC,EAAStN,OAAOiJ,WAClCb,WAAYkF,EAASlF,YAKhB,OAFPkF,EAAWA,EAAShE,KAEb,CACLK,MAAM,EACNxI,MAAAA,MAKCkI,EAASK,GAAG,CACjBxB,KAAMoF,EAAStH,IACfiD,WAAYqE,EAASrE,WACrBlB,OAAQuF,EAASvF,OAAO/B,IACxBhG,OAAQsN,EAAStN,OAAOgG,IACxBwJ,iBAAkBlC,EAASvF,OAAOkB,WAClCwG,iBAAkBnC,EAAStN,OAAOiJ,WAClCb,WAAYkF,EAASlF,aAWzB,SAAS0H,GAAgBhI,EAAO/E,GAC9B,GAAmB,IAAf+E,EAAMiI,KAAY,MAAO,GAEzBhN,GAAS,UAATA,GAAoBA,IAAS+E,EAAM/E,KACrC,MAA0B,mBAAf2D,MAAMsJ,KACRtJ,MAAMsJ,KAAKlI,EAAM2F,OAAO1H,QAE1B0E,EAAK3C,EAAM2F,OAAO1H,OAAQ+B,EAAM2F,OAAOsC,MAchD,IAXA,IASIpF,EAAMoD,EATJgC,EACK,eAAThN,EAAwB+E,EAAMmI,eAAiBnI,EAAMoI,aAEjD1K,EAAO,IAAIkB,MAAMqJ,GACrBI,EAAgB,eAATpN,EAEHyG,EAAW1B,EAAM2F,OAAO2C,SAE1BpN,EAAI,GAGwC,KAAvC2H,EAAOnB,EAASF,QAAcK,OACrCoE,EAAOpD,EAAKxJ,OAEHiH,aAAe+H,IAAM3K,EAAKxC,KAAO+K,EAAK/H,KAGjD,OAAOR,EAWT,SAAS6K,GAAYpB,EAAWnH,EAAO/E,EAAMoM,GAC3C,GAAmB,IAAfrH,EAAMiI,KASV,IAPMO,IAGF3F,EAAMoD,EAHJuC,EAAwB,UAATvN,GAAoBA,IAAS+E,EAAM/E,KAClDoN,EAAgB,eAATpN,EAGTsM,GAAc,EACZ7F,EAAW1B,EAAM2F,OAAO2C,UAEkB,KAAvCzF,EAAOnB,EAASF,QAAcK,MAGrC,GAFAoE,EAAOpD,EAAKxJ,OAERmP,GAAgBvC,EAAK3F,aAAe+H,EAAxC,CAEA,IAAAI,EAA0CxC,EAAnC/H,IAAAA,IAAKiD,IAAAA,WAAYlB,IAAAA,OAAQ/H,IAAAA,OAYhC,GAVAqP,EAAcF,EACZnJ,EACAiD,EACAlB,EAAO/B,IACPhG,EAAOgG,IACP+B,EAAOkB,WACPjJ,EAAOiJ,WACP8E,EAAK3F,YAGH6G,GAAaI,EAAa,OAAOrJ,GAazC,SAASwK,GAAmB1I,EAAO/E,GAC7B+E,GAAe,IAAfA,EAAMiI,KAAY,OAAO1G,EAASO,QAEhC0G,IAAAA,EAAwB,UAATvN,GAAoBA,IAAS+E,EAAM/E,KAClDoN,EAAgB,eAATpN,EAEPyG,EAAW1B,EAAM2F,OAAO2C,SAE9B,OAAO,IAAI/G,GAAS,WAIlB,IAHA,IAAIsB,EAAMoD,IAGG,CAGX,IAFApD,EAAOnB,EAASF,QAEPK,KAAM,OAAOgB,EAItB,GAFAoD,EAAOpD,EAAKxJ,OAERmP,GAAgBvC,EAAK3F,aAAe+H,EAExC,MAaK,MAAA,CAAChP,MAVM,CACZ+G,KAAM6F,EAAK/H,IACXiD,WAAY8E,EAAK9E,WACjBlB,OAAQgG,EAAKhG,OAAO/B,IACpBhG,OAAQ+N,EAAK/N,OAAOgG,IACpBwJ,iBAAkBzB,EAAKhG,OAAOkB,WAC9BwG,iBAAkB1B,EAAK/N,OAAOiJ,WAC9Bb,WAAY2F,EAAK3F,YAGJuB,MAAM,MAazB,SAAS8G,GACPxB,EACAP,EACA3L,EACAgM,EACA1B,EACA8B,GAEA,IAEIuB,EAFEC,EAAKjC,EAAQY,GAAeN,GAI9BjM,GAAS,eAATA,EAAuB,CACrBgM,GAAc,QAAdA,IACF2B,EAAQC,EAAG1B,EAAW5B,EAAQ,GAAK8B,GAE/BF,GAAayB,GAAO,OAAOA,EAE7B3B,GAAc,OAAdA,IACF2B,EAAQC,EACN1B,EACA5B,EAASlF,IACTgH,EACCJ,OAA2BrN,EAAf2L,EAASrH,KAGpBiJ,GAAayB,GAAO,OAAOA,EAI/B3N,GAAS,aAATA,IACF2N,EAAQC,EAAG1B,EAAW5B,EAASjF,WAAY+G,GAEvCF,GAAayB,GAAO,OAAOA,EAenC,SAASE,GAAuBlC,EAAO3L,EAAMgM,EAAW1B,GACtD,IAAMwD,EAAQ,GAMd,OAJAJ,IAAmB,EAAO/B,EAAO3L,EAAMgM,EAAW1B,GAAU,SAAUrH,GACpE6K,EAAM1N,KAAK6C,MAGN6K,EAWT,SAASC,GAA0B/N,EAAMgM,EAAW1B,GAClD,IAAI7D,EAAWH,EAASO,QAgBxB,MAda,eAAT7G,IACgB,QAAdgM,QAA8C,IAAhB1B,EAAQ,KACxC7D,EAAWmF,GAAMnF,EAAU+F,GAAelC,EAAD,MACzB,OAAd0B,QAA8C,IAAjB1B,EAASlF,MACxCqB,EAAWmF,GACTnF,EACA+F,GAAelC,EAASlF,IAAM4G,OAA2BrN,EAAf2L,EAASrH,QAI5C,aAATjD,QAAsD,IAAxBsK,EAASjF,aACzCoB,EAAWmF,GAAMnF,EAAU+F,GAAelC,EAASjF,cAG9CoB,EAcT,SAASuH,GACP9B,EACAlM,EACA2L,EACAK,EACA/G,EACAhI,EACAmP,GAEA,IAEIuB,EAFEC,EAAKjC,EAAQkB,GAAqBF,GAIpC3M,GAAS,eAATA,EAAuB,CACrB,QAAyB,IAAlBiF,EAAP,IAAsD,QAAd+G,IAC1C2B,EAAQC,EAAG1B,EAAWjH,EAAU,GAAKhI,EAAQmP,GAEzCF,GAAayB,GAAO,OAAOA,EAGjC,QAC4B,IAAnB1I,EAAWG,KACJ,OAAd4G,IACCA,GAAa/G,EAAWhC,MAAQhG,KAEjC0Q,EAAQC,EAAG1B,EAAWjH,EAAWG,IAAKnI,EAAQmP,GAE1CF,GAAayB,GAAO,OAAOA,EAI/B3N,GAAS,aAATA,QACmC,IAA1BiF,EAAWI,aACpBsI,EAAQC,EAAG1B,EAAWjH,EAAWI,WAAYpI,EAAQmP,GAEjDF,GAAayB,GAAO,OAAOA,EAiBrC,SAASM,GAAuBjO,EAAM2L,EAAOK,EAAW/G,EAAYhI,GAClE,IAAM6Q,EAAQ,GAcd,OAZAE,IACE,EACAhO,EACA2L,EACAK,EACA/G,EACAhI,GACA,SAAUgG,GACR6K,EAAM1N,KAAK6C,MAIR6K,EAYT,SAASI,GAA0BlO,EAAMgM,EAAW/G,EAAYhI,GAC9D,IAAIwJ,EAAWH,EAASO,QA8BxB,MA5Ba,eAAT7G,SAEyB,IAAlBiF,EAAP,IACc,QAAd+G,GACA/O,KAAUgI,EAAU,KAEpBwB,EAAWmF,GAAMnF,EAAUqG,GAAqB7H,EAAD,GAAgBhI,UAGrC,IAAnBgI,EAAWG,KACJ,OAAd4G,GACA/O,KAAUgI,EAAWG,MACpB4G,GAAa/G,EAAWhC,MAAQhG,KAEjCwJ,EAAWmF,GAAMnF,EAAUqG,GAAqB7H,EAAWG,IAAKnI,MAGvD,aAAT+C,QAEiC,IAA1BiF,EAAWI,YAClBpI,KAAUgI,EAAWI,aAErBoB,EAAWmF,GACTnF,EACAqG,GAAqB7H,EAAWI,WAAYpI,KAI3CwJ,ECzkBT,IAAM0H,GAAsB,CAC1B,CACEzM,KAAM,YACN1B,KAAM,SAER,CACE0B,KAAM,cACN1B,KAAM,WACNgM,UAAW,MAEb,CACEtK,KAAM,eACN1B,KAAM,WACNgM,UAAW,OAEb,CACEtK,KAAM,mBACN1B,KAAM,QACNgM,UAAW,MAEb,CACEtK,KAAM,oBACN1B,KAAM,QACNgM,UAAW,OAEb,CACEtK,KAAM,oBACN1B,KAAM,YAER,CACE0B,KAAM,sBACN1B,KAAM,eAOV,SAASoO,KACFC,KAAAA,EAAI,KACJC,KAAAA,EAAI,KAuBX,SAASC,GAAoBrC,EAAWsC,EAASlE,EAAU6B,EAAQC,GACjE,IAAK,IAAMvH,KAAKsH,EAAQ,CACtB,IAAM5B,EAAW4B,EAAOtH,GAElBI,EAAasF,EAASvF,OACtB4H,EAAarC,EAAStN,OAEtBwR,EAAexJ,IAAeqF,EAAWsC,EAAa3H,EAExDuJ,IAAAA,IAAWA,EAAQE,IAAID,EAAaxL,KAApCuL,CAEElC,IAAAA,EAAcF,EAASqC,EAAaxL,IAAKwL,EAAavI,YAE5D,GAAIgG,GAAaI,EAAa,OAAOmC,EAAaxL,MAMtD,SAAS0L,GAAgBzC,EAAWlM,EAAMgM,EAAW1B,EAAU8B,GAEzDpM,GAAS,UAATA,EAAkB,CACpB,GAAa,eAATA,EACF,OAAOuO,GACLrC,EACA,KACA5B,EACAA,EAASjF,WACT+G,GAGA,GAAqB,iBAAdJ,EACT,OAAOuC,GACLrC,EACA,KACA5B,EACAA,EAAS0B,GACTI,GAMN,IAEIuB,EAFEa,EAAU,IAAIJ,GAIhBpO,GAAS,eAATA,EAAuB,CACrBgM,GAAc,QAAdA,EAAqB,CASvB,GARA2B,EAAQY,GACNrC,EACA,KACA5B,EACAA,EAJyB,GAKzB8B,GAGEF,GAAayB,EAAO,OAAOA,EAE/Ba,EAAQI,KAAKtE,EAAb,IAEE0B,GAAc,OAAdA,EAAoB,CAStB,GARA2B,EAAQY,GACNrC,EACAsC,EACAlE,EACAA,EAASlF,IACTgH,GAGEF,GAAayB,EAAO,OAAOA,EAE/Ba,EAAQI,KAAKtE,EAASlF,MAItBpF,GAAS,aAATA,IACF2N,EAAQY,GACNrC,EACAsC,EACAlE,EACAA,EAASjF,WACT+G,GAGEF,GAAayB,GAAO,OAAOA,EAuCnC,SAASkB,GAA4BL,EAASlE,EAAU6B,GACtD,IAAMnJ,EAAOvF,OAAOuF,KAAKmJ,GACnBvH,EAAI5B,EAAK7C,OAEXF,EAAI,EAER,OAAO,IAAIqG,GAAS,WACdmI,IAAAA,EAAe,KAEhB,EAAA,CACGxO,GAAAA,GAAK2E,EAEA,OADH4J,GAASA,EAAQI,KAAKzC,GACnB,CAACvF,MAAM,GAGV2D,IAAAA,EAAW4B,EAAOnJ,EAAK/C,MAEvBgF,EAAasF,EAASvF,OACtB4H,EAAarC,EAAStN,OAE5BwR,EAAexJ,IAAeqF,EAAWsC,EAAa3H,EAElDuJ,GAAWA,EAAQE,IAAID,EAAaxL,OACtCwL,EAAe,YAGO,OAAjBA,GAEF,MAAA,CACL7H,MAAM,EACNxI,MAAO,CAAC0Q,SAAUL,EAAaxL,IAAKiD,WAAYuI,EAAavI,gBAoDnE,SAAS6I,GAA2BjE,EAAOkE,GACzC,IAAOtN,EAAyBsN,EAAzBtN,KAAM1B,EAAmBgP,EAAnBhP,KAAMgM,EAAagD,EAAbhD,UAUnBlB,EAAMzN,UAAUqE,GAAQ,SAAUuN,GAEhC,GAAa,UAATjP,GAAkC,UAAdoG,KAAKpG,MAAoBA,IAASoG,KAAKpG,KAC7D,MAAO,GAETiP,EAAO,GAAKA,EAEN3E,IAAAA,EAAWlE,KAAKlB,OAAO9F,IAAI6P,GAEjC,QAAwB,IAAb3E,EACT,MAAM,IAAI9B,EAAJ,SAAA5K,OACK8D,EADL,0BAAA9D,OACkCqR,EADlC,yBAKR,OArIJ,SAAoCjP,EAAMgM,EAAW1B,GAE/CtK,GAAS,UAATA,EAAkB,CACpB,GAAa,eAATA,EAAuB,OAAOvC,OAAOuF,KAAKsH,EAASjF,YAEvD,GAAyB,iBAAd2G,EAAwB,OAAOvO,OAAOuF,KAAKsH,EAAS0B,IAG3DkD,IAAAA,EAAY,GAMlB,OAJAP,IAAgB,EAAO3O,EAAMgM,EAAW1B,GAAU,SAAUrH,GAC1DiM,EAAU9O,KAAK6C,MAGViM,EAuHEC,CACI,UAATnP,EAAmBoG,KAAKpG,KAAOA,EAC/BgM,EACA1B,IAkNN,SAAS8E,GAA8BtE,EAAOkE,GAC5C,IAAOtN,EAAyBsN,EAAzBtN,KAAM1B,EAAmBgP,EAAnBhP,KAAMgM,EAAagD,EAAbhD,UAEbqD,EAAe3N,EAAK0C,MAAM,GAAI,GAAK,UAUzC0G,EAAMzN,UAAUgS,GAAgB,SAAUJ,GAExC,GAAa,UAATjP,GAAkC,UAAdoG,KAAKpG,MAAoBA,IAASoG,KAAKpG,KAC7D,OAAOsG,EAASO,QAElBoI,EAAO,GAAKA,EAEN3E,IAAAA,EAAWlE,KAAKlB,OAAO9F,IAAI6P,GAEjC,QAAwB,IAAb3E,EACT,MAAM,IAAI9B,EAAJ,SAAA5K,OACKyR,EADL,0BAAAzR,OAC0CqR,EAD1C,yBAKR,OA1TJ,SAAgCjP,EAAMgM,EAAW1B,GAE3CtK,GAAS,UAATA,EAAkB,CACpB,GAAa,eAATA,EACF,OAAO6O,GAA4B,KAAMvE,EAAUA,EAASjF,YAE9D,GAAyB,iBAAd2G,EACT,OAAO6C,GAA4B,KAAMvE,EAAUA,EAAS0B,IAGhE,IAAIvF,EAAWH,EAASO,QAIlB2H,EAAU,IAAIJ,GAwBpB,MAtBa,eAATpO,IACgB,QAAdgM,IACFvF,EAAWmF,GACTnF,EACAoI,GAA4BL,EAASlE,EAAUA,EAAQ,MAGzC,OAAd0B,IACFvF,EAAWmF,GACTnF,EACAoI,GAA4BL,EAASlE,EAAUA,EAASlF,QAKjD,aAATpF,IACFyG,EAAWmF,GACTnF,EACAoI,GAA4BL,EAASlE,EAAUA,EAASjF,cAIrDoB,EAoRE6I,CACI,UAATtP,EAAmBoG,KAAKpG,KAAOA,EAC/BgM,EACA1B,ICzhBC,SAASiF,GACdrD,EACAsD,EACAC,EACA1K,EACAqH,GAQA,IANA,IAIIxE,EAAM3C,EAAY6J,EAAUpF,EAAKa,EAAUqC,EAAYN,EAJrD7F,EAAW1B,EAAMG,OAAOmI,SAExBrN,EAAO+E,EAAM/E,MAI6B,KAAvC4H,EAAOnB,EAASF,QAAcK,MAAgB,CACjD8I,IAAAA,GAAW,EAIX1P,GAFJiF,EAAa2C,EAAKxJ,MAEL,eAAT4B,EAGG8O,IAAAA,KAFLpF,EAAMzE,EAAWG,IAEK,CACpBmF,EAAWb,EAAIoF,GAEZ,EAAA,CAcD,GAbAlC,EAAarC,EAAStN,OAEtByS,GAAW,EACXpD,EAAcF,EACZnH,EAAWhC,IACX2J,EAAW3J,IACXgC,EAAWiB,WACX0G,EAAW1G,WACXqE,EAAStH,IACTsH,EAASrE,WACTqE,EAASlF,YAGP6G,GAAaI,EAAa,OAAO/B,EAErCA,EAAWA,EAAShE,WACbgE,GAITvK,GAAS,aAATA,EAGG8O,IAAAA,KAFLpF,EAAMzE,EAAWI,WAGf,KAAImK,GAAcvK,EAAWhC,IAAM6L,GAAnC,CAEAvE,EAAWb,EAAIoF,GAEZ,EAAA,CAgBD,IAfAlC,EAAarC,EAAStN,QAEPgG,MAAQ6L,IAAUlC,EAAarC,EAASvF,QAEvD0K,GAAW,EACXpD,EAAcF,EACZnH,EAAWhC,IACX2J,EAAW3J,IACXgC,EAAWiB,WACX0G,EAAW1G,WACXqE,EAAStH,IACTsH,EAASrE,WACTqE,EAASlF,YAGP6G,GAAaI,EAAa,OAAO/B,EAErCA,EAAWA,EAAShE,WACbgE,GAIb,GAAIkF,IAAsBC,IACxBpD,EAAcF,EACZnH,EAAWhC,IACX,KACAgC,EAAWiB,WACX,KACA,KACA,KACA,MAGEgG,GAAaI,GAAa,OAAO,MClDpC,SAASqD,GAAuBvR,GACjC,IAACkH,EAAclH,GACjB,MAAM,IAAIgK,EACR,qHAGA,KAAE,QAAShK,GACb,MAAM,IAAIgK,EACR,qDAIF,GAAA,eAAgBhK,KACdkH,EAAclH,EAAM8H,aAAoC,OAArB9H,EAAM8H,YAE3C,MAAM,IAAIkC,EACR,2FAUC,SAASwH,GAAuBxR,GACjC,IAACkH,EAAclH,GACjB,MAAM,IAAIgK,EACR,mIAGA,KAAE,WAAYhK,GAChB,MAAM,IAAIgK,EACR,wDAGA,KAAE,WAAYhK,GAChB,MAAM,IAAIgK,EACR,wDAIF,GAAA,eAAgBhK,KACdkH,EAAclH,EAAM8H,aAAoC,OAArB9H,EAAM8H,YAE3C,MAAM,IAAIkC,EACR,2FAGJ,GAAI,eAAgBhK,GAAqC,kBAArBA,EAAMiH,WACxC,MAAM,IAAI+C,EACR,8FFhDNgG,GAAoB/Q,UAAUuR,KAAO,SAAUvP,GAC9B,OAAX+G,KAAKiI,EAAYjI,KAAKiI,EAAIhP,EACV,OAAX+G,KAAKkI,IAAYlI,KAAKkI,EAAIjP,IAGrC+O,GAAoB/Q,UAAUqR,IAAM,SAAUzL,GACxC,OAAW,OAAXmD,KAAKiI,GAAcpL,KAAOmD,KAAKiI,GACpB,OAAXjI,KAAKkI,GAAcrL,KAAOmD,KAAKkI,GGfrC,IfiGMrO,GejGA4P,IfiGA5P,GAAsC,IAAlC6P,KAAKC,MAAsB,IAAhBD,KAAKE,UAEjB,WACL,OAAO/P,Oe/FLgQ,GAAQ,IAAIC,IAAI,CAAC,WAAY,aAAc,UAE3CC,GAAgB,IAAID,IAAI,CAC5B,SACA,UACA,eACA,kBAkCIE,GAAW,CACfC,gBAAgB,EAChB1E,OAAO,EACP3L,KAAM,SAgDR,SAASsQ,GAAcvL,EAAOkK,EAAM/I,GAC5B8E,IAAAA,EAAO,IAAIjG,EAAMwL,cAActB,EAAM/I,GAS3C,OAPAnB,EAAMG,OAAO7F,IAAI4P,EAAMjE,GAEvBjG,EAAMhF,KAAK,YAAa,CACtBkD,IAAKgM,EACL/I,WAAAA,IAGK8E,EAqBT,SAASwF,GACPzL,EACArD,EACA+O,EACApL,EACAF,EACAH,EACA/H,EACAiJ,GAGA,IAAKb,GAA6B,eAAfN,EAAM/E,KACvB,MAAM,IAAI2I,EAAJ,SAAA/K,OACK8D,EADX,+GAIF,GAAI2D,GAA6B,aAAfN,EAAM/E,KACtB,MAAM,IAAI2I,EAAJ,SAAA/K,OACK8D,EADX,6GAIF,GAAIwE,IAAeZ,EAAcY,GAC/B,MAAM,IAAIkC,EACC1G,SAAAA,OAAAA,gEAA0DwE,EAD/D,MASR,GAJAlB,EAAS,GAAKA,EACd/H,EAAS,GAAKA,EACdiJ,EAAaA,GAAc,IAEtBnB,EAAMsL,gBAAkBrL,IAAW/H,EACtC,MAAM,IAAI0L,EAAJ,SAAA/K,OACK8D,EADL,qCAAA9D,OAC6CoH,EADnD,uGAIIC,IAAAA,EAAaF,EAAMG,OAAO9F,IAAI4F,GAClC4H,EAAa7H,EAAMG,OAAO9F,IAAInC,GAE5B,IAACgI,EACH,MAAM,IAAIuD,EACC9G,SAAAA,OAAAA,EAAsBsD,mBAAAA,OAAAA,EADjC,iBAIF,IAAK4H,EACH,MAAM,IAAIpE,EACC9G,SAAAA,OAAAA,EAAsBzE,mBAAAA,OAAAA,EADjC,iBAKF,IAAMyT,EAAY,CAChBzN,IAAK,KACLoC,WAAAA,EACAL,OAAAA,EACA/H,OAAAA,EACAiJ,WAAAA,GAGF,GAAIuK,EAGFtL,EAAOJ,EAAM4L,yBAMb,GAHAxL,EAAO,GAAKA,EAGRJ,EAAM2F,OAAOgE,IAAIvJ,GACnB,MAAM,IAAIwD,EAAJ,SAAA/K,OACK8D,EADL,WAAA9D,OACmBuH,EADzB,wCAOF,IAACJ,EAAM4G,QACNtG,OAC4C,IAAlCJ,EAAWI,WAAWpI,QACK,IAA3BgI,EAAWG,IAAInI,IAEpB,MAAA,IAAI0L,EACCjH,SAAAA,OAAAA,gCAA0BsD,EAD/B,UAAApH,OAC8CX,EADpD,kJAMF,IAAMsN,EAAW,IAAIrB,EACnB7D,EACAF,EACAF,EACA2H,EACA1G,GAIFnB,EAAM2F,OAAOrL,IAAI8F,EAAMoF,GAGvB,IAAMqG,EAAa5L,IAAW/H,EA0B9B,OAxBIoI,GACFJ,EAAWoE,mBACXuD,EAAWvD,mBAEPuH,GAAY7L,EAAM8L,6BAEtB5L,EAAWmE,YACXwD,EAAWzD,WAEPyH,GAAY7L,EAAM+L,0BAIpB/L,EAAM4G,MAAOpB,EAASd,cACrBc,EAASjB,SAEVjE,EAAYN,EAAMgM,kBACjBhM,EAAMiM,gBAGXN,EAAUzN,IAAMkC,EAEhBJ,EAAMhF,KAAK,YAAa2Q,GAEjBvL,EAsBT,SAAS8L,GACPlM,EACArD,EACA+O,EACApL,EACAF,EACAH,EACA/H,EACAiJ,EACAgL,GAGA,IAAK7L,GAA6B,eAAfN,EAAM/E,KACvB,MAAM,IAAI2I,EAAJ,SAAA/K,OACK8D,EADX,uIAIF,GAAI2D,GAA6B,aAAfN,EAAM/E,KACtB,MAAM,IAAI2I,EAAJ,SAAA/K,OACK8D,EADX,qIAIF,GAAIwE,EACF,GAAIgL,GACF,GAA0B,mBAAfhL,EACT,MAAM,IAAIkC,EACC1G,SAAAA,OAAAA,EAAiEwE,8DAAAA,OAAAA,EAD5E,WAIF,IAAKZ,EAAcY,GACjB,MAAM,IAAIkC,EAAJ,SAAAxK,OACK8D,EADL,uDAAA9D,OAC+DsI,EADrE,MAUN,IAAImF,EAOJ,GAVArG,EAAS,GAAKA,EACd/H,EAAS,GAAKA,EAIViU,IACF7F,EAAUnF,EACVA,OAAavH,IAGVoG,EAAMsL,gBAAkBrL,IAAW/H,EACtC,MAAM,IAAI0L,EAAJ,SAAA/K,OACK8D,EADL,qCAAA9D,OAC6CoH,EADnD,uGAIEC,IAEAsF,EAGA4G,EALAlM,EAAaF,EAAMG,OAAO9F,IAAI4F,GAC9B4H,EAAa7H,EAAMG,OAAO9F,IAAInC,GAM9B,IAACwT,IACHlG,EAAWxF,EAAM2F,OAAOtL,IAAI+F,IAEd,CAGZ,KAAIoF,EAASvF,OAAO/B,MAAQ+B,GAAUuF,EAAStN,OAAOgG,MAAQhG,GAGzDoI,GACDkF,EAASvF,OAAO/B,MAAQhG,GACxBsN,EAAStN,OAAOgG,MAAQ+B,GAGlB,MAAA,IAAI2D,EACCjH,SAAAA,OAAAA,oEAA8DyD,EADnE,iBAAAvH,OACuFoH,EADvF,gBAAApH,OAC4GX,EAD5G,mBAAAW,OACoI2M,EAASvF,OAAO/B,IADpJ,QAAArF,OAC8J2M,EAAStN,OAAOgG,IADpL,QAMJkO,EAA0B5G,EAY9B,GAPK4G,GAA4BpM,EAAM4G,QAAS1G,IAC9CkM,EAA0B9L,EACtBJ,EAAWI,WAAWpI,GACtBgI,EAAWG,IAAInI,IAIjBkU,EAAyB,CAC3B,IAAMC,EAAO,CAACD,EAAwBlO,KAAK,GAAO,GAAO,GAGrDiO,GAAAA,GAAa7F,GAAWnF,EAAY,OAAOkL,EAG/C,GAAIF,EAAW,CACb,IAAMG,EAAgBF,EAAwBjL,WAC9CiL,EAAwBjL,WAAamF,EAAQgG,GAE7CtM,EAAMhF,KAAK,wBAAyB,CAClCC,KAAM,UACNiD,IAAKkO,EAAwBlO,IAC7BiD,WAAYiL,EAAwBjL,kBAMtCvB,EAAOwM,EAAwBjL,WAAYA,GAE3CnB,EAAMhF,KAAK,wBAAyB,CAClCC,KAAM,QACNiD,IAAKkO,EAAwBlO,IAC7BiD,WAAYiL,EAAwBjL,WACpC8E,KAAM9E,IAIV,OAAOkL,EAGTlL,EAAaA,GAAc,GAEvBgL,GAAa7F,IAASnF,EAAamF,EAAQnF,IAG/C,IAAMwK,EAAY,CAChBzN,IAAK,KACLoC,WAAAA,EACAL,OAAAA,EACA/H,OAAAA,EACAiJ,WAAAA,GAGF,GAAIuK,EAGFtL,EAAOJ,EAAM4L,yBAMb,GAHAxL,EAAO,GAAKA,EAGRJ,EAAM2F,OAAOgE,IAAIvJ,GACnB,MAAM,IAAIwD,EAAJ,SAAA/K,OACK8D,EADL,WAAA9D,OACmBuH,EADzB,wCAKAmM,IAAAA,GAAiB,EACjBC,GAAiB,EAEhBtM,IACHA,EAAaqL,GAAcvL,EAAOC,EAAQ,IAC1CsM,GAAiB,EAEbtM,IAAW/H,IACb2P,EAAa3H,EACbsM,GAAiB,IAGhB3E,IACHA,EAAa0D,GAAcvL,EAAO9H,EAAQ,IAC1CsU,GAAiB,GAInBhH,EAAW,IAAIrB,EAAS7D,EAAYF,EAAMF,EAAY2H,EAAY1G,GAGlEnB,EAAM2F,OAAOrL,IAAI8F,EAAMoF,GAGvB,IAAMqG,EAAa5L,IAAW/H,EA0BvB,OAxBHoI,GACFJ,EAAWoE,mBACXuD,EAAWvD,mBAEPuH,GAAY7L,EAAM8L,6BAEtB5L,EAAWmE,YACXwD,EAAWzD,WAEPyH,GAAY7L,EAAM+L,0BAIpB/L,EAAM4G,MAAOpB,EAASd,cACrBc,EAASjB,SAEVjE,EAAYN,EAAMgM,kBACjBhM,EAAMiM,gBAGXN,EAAUzN,IAAMkC,EAEhBJ,EAAMhF,KAAK,YAAa2Q,GAEjB,CAACvL,GAAM,EAAMmM,EAAgBC,GAStC,SAASC,GAAiBzM,EAAOwF,GAE/BxF,EAAM2F,OAAN,OAAoBH,EAAStH,KAG7B,IAAegC,EAA8CsF,EAAtDvF,OAA4B4H,EAA0BrC,EAAlCtN,OAAoBiJ,EAAcqE,EAAdrE,WAEzCb,EAAakF,EAASlF,WAEtBuL,EAAa3L,IAAe2H,EAE9BvH,GACFJ,EAAWoE,mBACXuD,EAAWvD,mBAEPuH,GAAY7L,EAAM8L,6BAEtB5L,EAAWmE,YACXwD,EAAWzD,WAEPyH,GAAY7L,EAAM+L,0BAIpB/L,EAAM4G,MAAOpB,EAAST,cACrBS,EAASV,SAEVxE,EAAYN,EAAMgM,kBACjBhM,EAAMiM,gBAGXjM,EAAMhF,KAAK,cAAe,CACxBkD,IAAKsH,EAAStH,IACdiD,WAAAA,EACAlB,OAAQC,EAAWhC,IACnBhG,OAAQ2P,EAAW3J,IACnBoC,WAAAA,QAgBiBoM,eACnB,SAAAA,EAAYC,GAAS,IAAAzJ,EAOnB,GANAA,EAAA0J,EAAArU,KAAA8I,OAAAA,KAM6B,kBAH7BsL,EAAU/M,EAAO,GAAIyL,GAAUsB,IAGZ/F,MACjB,MAAM,IAAIvD,EAAJ,4EAAAxK,OACuE8T,EAAQ/F,MADrF,OAIF,IAAKsE,GAAMvB,IAAIgD,EAAQ1R,MACrB,MAAM,IAAIoI,sHACmGsJ,EAAQ1R,KADrH,OAIF,GAAsC,kBAA3B0R,EAAQrB,eACjB,MAAM,IAAIjI,8FAC4EsJ,EAAQrB,eADxF,OAOR,IAAME,EACa,UAAjBmB,EAAQ1R,KACJ8I,EACiB,aAAjB4I,EAAQ1R,KACRgJ,EACAC,EAENtD,EAAsBiM,EAAA3J,GAAA,gBAAiBsI,GAavC,IAAMsB,EAAiB,QAAUhC,KAAgB,IAC7CiC,EAAS,EA9CM,OA2DnBnM,EAAeiM,EAAA3J,GAAO,cAAe,IACrCtC,EAAsBiM,EAAA3J,GAAA,SAAU,IAAI8J,KACpCpM,EAAsBiM,EAAA3J,GAAA,SAAU,IAAI8J,KACpCpM,EAAeiM,EAAA3J,GAAO,gBAAiB,GACvCtC,EAAeiM,EAAA3J,GAAO,kBAAmB,GACzCtC,EAAeiM,EAAA3J,GAAO,yBAA0B,GAChDtC,EAAeiM,EAAA3J,GAAO,2BAA4B,GAClDtC,EAAsBiM,EAAA3J,GAAA,qBAlBG,WACvB,IAAI+J,EAED,GACDA,EAAmBH,EAAiBC,UAC7B7J,EAAKyC,OAAOgE,IAAIsD,IAEzB,OAAOA,KAcTrM,EAAsBiM,EAAA3J,GAAA,WAAYyJ,GAGlCvB,GAAc8B,SAAQ,SAAAC,GAAI,OAAIvM,EAAsBuM,EAAAA,GAAAA,EAAMjK,EAAKiK,OAG/DpM,EAAuB8L,EAAA3J,GAAA,SAAS,WAAM,OAAAA,EAAK/C,OAAO8H,QAClDlH,EAAuB8L,EAAA3J,GAAA,QAAQ,WAAM,OAAAA,EAAKyC,OAAOsC,QACjDlH,EAAuB8L,EAAA3J,GAAA,gBAAgB,WAAA,OAAMA,EAAK+I,iBAClDlL,EAAuB8L,EAAA3J,GAAA,kBAAkB,WAAA,OAAMA,EAAK8I,mBACpDjL,EAEE8L,EAAA3J,GAAA,iBACA,WAAA,OAAMA,EAAK6I,uBAAyB7I,EAAK4I,4BAE3C/K,EAEE8L,EAAA3J,GAAA,yBACA,WAAA,OAAMA,EAAK6I,0BAEbhL,EAEE8L,EAAA3J,GAAA,2BACA,WAAA,OAAMA,EAAK4I,4BAEb/K,OAAuB,QAASmC,EAAKkK,SAASxG,OAC9C7F,OAAuB,OAAQmC,EAAKkK,SAASnS,MAC7C8F,OAAuB,iBAAkBmC,EAAKkK,SAAS9B,gBACvDvK,EAAuB8L,EAAA3J,GAAA,kBAAkB,WAAA,MAAM,gBAjG5BA,kCAoGrBmK,EAAAA,uBAAA,WACOpB,KAAAA,cAAgB,EAChBD,KAAAA,gBAAkB,EAClBD,KAAAA,uBAAyB,EACzBD,KAAAA,yBAA2B,KAclCwB,QAAA,SAAQpD,GACN,OAAO7I,KAAKlB,OAAOwJ,IAAI,GAAKO,IAiB9BqD,EAAAA,gBAAA,SAAgBtN,EAAQ/H,GAEtB,GAAkB,eAAdmJ,KAAKpG,KAAuB,OAAO,EAEvC,GAAyB,IAArBE,UAAUC,OAAc,CACpBgF,IAAAA,EAAO,GAAKH,EAEZuF,EAAWnE,KAAKsE,OAAOtL,IAAI+F,GAEjC,QAASoF,IAAaA,EAASlF,WAC1B,GAAyB,IAArBnF,UAAUC,OAAc,CACjC6E,EAAS,GAAKA,EACd/H,EAAS,GAAKA,EAGRqN,IAAAA,EAAWlE,KAAKlB,OAAO9F,IAAI4F,GAEjC,IAAKsF,EAAU,OAAO,EAGtB,IAAMwD,EAAQxD,EAASlF,IAAInI,GAE3B,QAAK6Q,KAEE1H,KAAKuF,SAAUmC,EAAMd,MAG9B,MAAM,IAAI5E,EAAJ,yCAAAxK,OACqCsC,UAAUC,OADrD,0HAmBFoS,EAAAA,kBAAA,SAAkBvN,EAAQ/H,GAExB,GAAkB,aAAdmJ,KAAKpG,KAAqB,OAAO,EAErC,GAAyB,IAArBE,UAAUC,OAAc,CACpBgF,IAAAA,EAAO,GAAKH,EAEZuF,EAAWnE,KAAKsE,OAAOtL,IAAI+F,GAEjC,QAASoF,GAAYA,EAASlF,WACzB,GAAyB,IAArBnF,UAAUC,OAAc,CACjC6E,EAAS,GAAKA,EACd/H,EAAS,GAAKA,EAGRqN,IAAAA,EAAWlE,KAAKlB,OAAO9F,IAAI4F,GAEjC,IAAKsF,EAAU,OAAO,EAGtB,IAAMwD,EAAQxD,EAASjF,WAAWpI,GAElC,QAAK6Q,KAEE1H,KAAKuF,SAAUmC,EAAMd,MAG9B,MAAM,IAAI5E,EAAJ,yCAAAxK,OACqCsC,UAAUC,OADrD,0HAmBFqS,EAAAA,QAAA,SAAQxN,EAAQ/H,GACd,GAAyB,IAArBiD,UAAUC,OAAc,CACpBgF,IAAAA,EAAO,GAAKH,EAElB,OAAOoB,KAAKsE,OAAOgE,IAAIvJ,GAClB,GAAyB,IAArBjF,UAAUC,OAAc,CACjC6E,EAAS,GAAKA,EACd/H,EAAS,GAAKA,EAGRqN,IAAAA,EAAWlE,KAAKlB,OAAO9F,IAAI4F,GAEjC,IAAKsF,EAAU,OAAO,EAGtB,IAAIwD,OAAgC,IAAjBxD,EAASlF,KAAuBkF,EAASlF,IAAInI,GAOhE,OALK6Q,IACHA,OACiC,IAAxBxD,EAASjF,YAChBiF,EAASjF,WAAWpI,MAEnB6Q,KAEE1H,KAAKuF,SAAUmC,EAAMd,MAG9B,MAAM,IAAI5E,EAAJ,iCAAAxK,OAC6BsC,UAAUC,OAD7C,0HAgBFsS,EAAAA,aAAA,SAAazN,EAAQ/H,GACnB,GAAkB,eAAdmJ,KAAKpG,KAAT,CAKI,GAHJgF,EAAS,GAAKA,EACd/H,EAAS,GAAKA,EAEVmJ,KAAKuF,MACP,MAAM,IAAIhD,EACR,4JAGE1D,IAAAA,EAAamB,KAAKlB,OAAO9F,IAAI4F,GAE/B,IAACC,EACH,MAAM,IAAIuD,EAAJ,2CAAA5K,OACuCoH,EAD7C,gCAIF,IAAKoB,KAAKlB,OAAOwJ,IAAIzR,GACnB,MAAM,IAAIuL,EAAJ,2CAAA5K,OACuCX,EAD7C,gCAIF,IAAMsN,EAAYtF,EAAWG,KAAOH,EAAWG,IAAInI,SAAY0B,EAE/D,OAAI4L,EAAiBA,EAAStH,SAA9B,IAcFyP,EAAAA,eAAA,SAAe1N,EAAQ/H,GACrB,GAAkB,aAAdmJ,KAAKpG,KAAT,CAKI,GAHJgF,EAAS,GAAKA,EACd/H,EAAS,GAAKA,EAEVmJ,KAAKuF,MACP,MAAM,IAAIhD,EACR,gKAGE1D,IAAAA,EAAamB,KAAKlB,OAAO9F,IAAI4F,GAE/B,IAACC,EACH,MAAM,IAAIuD,EAAJ,6CAAA5K,OACyCoH,EAD/C,gCAIF,IAAKoB,KAAKlB,OAAOwJ,IAAIzR,GACnB,MAAM,IAAIuL,EAAJ,6CAAA5K,OACyCX,EAD/C,gCAIF,IAAMsN,EACHtF,EAAWI,YAAcJ,EAAWI,WAAWpI,SAAY0B,EAE9D,OAAI4L,EAAiBA,EAAStH,SAA9B,IAcFkC,EAAAA,KAAA,SAAKH,EAAQ/H,GACP,GAAAmJ,KAAKuF,MACP,MAAM,IAAIhD,EACR,4IAGJ3D,EAAS,GAAKA,EACd/H,EAAS,GAAKA,EAERgI,IAAAA,EAAamB,KAAKlB,OAAO9F,IAAI4F,GAE/B,IAACC,EACH,MAAM,IAAIuD,EAAJ,mCAAA5K,OAC+BoH,EADrC,gCAIF,IAAKoB,KAAKlB,OAAOwJ,IAAIzR,GACnB,MAAM,IAAIuL,EAAJ,mCAAA5K,OAC+BX,EADrC,gCAIIsN,IAAAA,EACHtF,EAAWG,KAAOH,EAAWG,IAAInI,IACjCgI,EAAWI,YAAcJ,EAAWI,WAAWpI,SAChD0B,EAEF,GAAI4L,EAAU,OAAOA,EAAStH,KAYhC0P,EAAAA,qBAAA,SAAqB1D,EAAMH,GACzBG,EAAO,GAAKA,EACZH,EAAW,GAAKA,EAEVxE,IAAAA,EAAWlE,KAAKlB,OAAO9F,IAAI6P,GAE7B,IAAC3E,EACH,MAAM,IAAI9B,EAAJ,mDAAA5K,OAC+CqR,EADrD,yBAIF,MAAkB,eAAd7I,KAAKpG,OAEF8O,KAAYxE,EAAQ,IAAOwE,KAAYxE,EAASlF,MAYzDwN,EAAAA,gBAAA,SAAgB3D,EAAMH,GACpBG,EAAO,GAAKA,EACZH,EAAW,GAAKA,EAEVxE,IAAAA,EAAWlE,KAAKlB,OAAO9F,IAAI6P,GAE7B,IAAC3E,EACH,MAAM,IAAI9B,EAAJ,8CAAA5K,OAC0CqR,EADhD,yBAIF,MAAkB,eAAd7I,KAAKpG,MAEF8O,KAAYxE,EAASlF,KAY9ByN,EAAAA,eAAA,SAAe5D,EAAMH,GACnBG,EAAO,GAAKA,EACZH,EAAW,GAAKA,EAEVxE,IAAAA,EAAWlE,KAAKlB,OAAO9F,IAAI6P,GAE7B,IAAC3E,EACH,MAAM,IAAI9B,EAAJ,6CAAA5K,OACyCqR,EAD/C,yBAIF,MAAkB,eAAd7I,KAAKpG,MAEF8O,KAAYxE,EAAnB,IAYFwI,EAAAA,uBAAA,SAAuB7D,EAAMH,GAC3BG,EAAO,GAAKA,EACZH,EAAW,GAAKA,EAEVxE,IAAAA,EAAWlE,KAAKlB,OAAO9F,IAAI6P,GAE7B,IAAC3E,EACH,MAAM,IAAI9B,EAAJ,qDAAA5K,OACiDqR,EADvD,yBAIF,MAAkB,aAAd7I,KAAKpG,MAEF8O,KAAYxE,EAASjF,YAY9B0N,EAAAA,aAAA,SAAa9D,EAAMH,GACjBG,EAAO,GAAKA,EACZH,EAAW,GAAKA,EAEVxE,IAAAA,EAAWlE,KAAKlB,OAAO9F,IAAI6P,GAE7B,IAAC3E,EACH,MAAM,IAAI9B,EAAJ,2CAAA5K,OACuCqR,EAD7C,yBAIF,MAAkB,eAAd7I,KAAKpG,OACH8O,KAAYxE,EAAQ,IAAOwE,KAAYxE,EAASlF,MAGpC,aAAdgB,KAAKpG,MACH8O,KAAYxE,EAASjF,YAe7B2N,EAAAA,oBAAA,SAAoB/D,EAAMH,GACxBG,EAAO,GAAKA,EACZH,EAAW,GAAKA,EAEVxE,IAAAA,EAAWlE,KAAKlB,OAAO9F,IAAI6P,GAE7B,IAAC3E,EACH,MAAM,IAAI9B,EAAJ,kDAAA5K,OAC8CqR,EADpD,yBAIF,MAAkB,eAAd7I,KAAKpG,MACH8O,KAAYxE,EAAhB,IAGgB,aAAdlE,KAAKpG,MACH8O,KAAYxE,EAASjF,YAe7B4N,EAAAA,qBAAA,SAAqBhE,EAAMH,GACzBG,EAAO,GAAKA,EACZH,EAAW,GAAKA,EAEVxE,IAAAA,EAAWlE,KAAKlB,OAAO9F,IAAI6P,GAE7B,IAAC3E,EACH,MAAM,IAAI9B,EAAJ,mDAAA5K,OAC+CqR,EADrD,yBAIF,MAAkB,eAAd7I,KAAKpG,MACH8O,KAAYxE,EAASlF,KAGT,aAAdgB,KAAKpG,MACH8O,KAAYxE,EAASjF,cAc7B8D,SAAA,SAAS8F,GACPA,EAAO,GAAKA,EAEN3E,IAAAA,EAAWlE,KAAKlB,OAAO9F,IAAI6P,GAE7B,IAAC3E,EACH,MAAM,IAAI9B,EAAJ,uCAAA5K,OACmCqR,EADzC,yBAIF,MAAkB,eAAd7I,KAAKpG,KAA8B,EAEhCsK,EAASnB,YAWlBC,UAAA,SAAU6F,GACRA,EAAO,GAAKA,EAEN3E,IAAAA,EAAWlE,KAAKlB,OAAO9F,IAAI6P,GAE7B,IAAC3E,EACH,MAAM,IAAI9B,EAAJ,wCAAA5K,OACoCqR,EAD1C,yBAIF,MAAkB,eAAd7I,KAAKpG,KAA8B,EAEhCsK,EAASlB,aAWlB8J,eAAA,SAAejE,GACbA,EAAO,GAAKA,EAEN3E,IAAAA,EAAWlE,KAAKlB,OAAO9F,IAAI6P,GAE7B,IAAC3E,EACH,MAAM,IAAI9B,EAAJ,6CAAA5K,OACyCqR,EAD/C,yBAIF,MAAkB,eAAd7I,KAAKpG,KAA8B,EAEhCsK,EAASnB,SAAWmB,EAASlB,aAWtCC,iBAAA,SAAiB4F,GACfA,EAAO,GAAKA,EAEN3E,IAAAA,EAAWlE,KAAKlB,OAAO9F,IAAI6P,GAE7B,IAAC3E,EACH,MAAM,IAAI9B,EAAJ,+CAAA5K,OAC2CqR,EADjD,yBAIF,MAAkB,aAAd7I,KAAKpG,KAA4B,EAE9BsK,EAASjB,oBAWlB8J,cAAA,SAAclE,GACZA,EAAO,GAAKA,EAEN3E,IAAAA,EAAWlE,KAAKlB,OAAO9F,IAAI6P,GAE7B,IAAC3E,EACH,MAAM,IAAI9B,EAAJ,4CAAA5K,OACwCqR,EAD9C,yBAIEmE,IAAAA,EAAS,EAUb,MARkB,aAAdhN,KAAKpG,OACPoT,GAAU9I,EAASjB,kBAGH,eAAdjD,KAAKpG,OACPoT,GAAU9I,EAASnB,UAGdiK,KAWTC,eAAA,SAAepE,GACbA,EAAO,GAAKA,EAEN3E,IAAAA,EAAWlE,KAAKlB,OAAO9F,IAAI6P,GAE7B,IAAC3E,EACH,MAAM,IAAI9B,EAAJ,6CAAA5K,OACyCqR,EAD/C,yBAIEmE,IAAAA,EAAS,EAUb,MARkB,aAAdhN,KAAKpG,OACPoT,GAAU9I,EAASjB,kBAGH,eAAdjD,KAAKpG,OACPoT,GAAU9I,EAASlB,WAGdgK,KAWTA,OAAA,SAAOnE,GACLA,EAAO,GAAKA,EAEN3E,IAAAA,EAAWlE,KAAKlB,OAAO9F,IAAI6P,GAE7B,IAAC3E,EACH,MAAM,IAAI9B,EAAJ,qCAAA5K,OACiCqR,EADvC,yBAIEmE,IAAAA,EAAS,EAUb,MARkB,aAAdhN,KAAKpG,OACPoT,GAAU9I,EAASjB,kBAGH,eAAdjD,KAAKpG,OACPoT,GAAU9I,EAASnB,SAAWmB,EAASlB,WAGlCgK,KAWTE,yBAAA,SAAyBrE,GACvBA,EAAO,GAAKA,EAEN3E,IAAAA,EAAWlE,KAAKlB,OAAO9F,IAAI6P,GAE7B,IAAC3E,EACH,MAAM,IAAI9B,EAAJ,uDAAA5K,OACmDqR,EADzD,yBAIF,GAAkB,eAAd7I,KAAKpG,KAAuB,OAAO,EAEvC,IAAMuT,EAAOjJ,EAAA,GAAY2E,GACnBuE,EAAQD,EAAQnN,KAAKuF,MAAQ4H,EAAKvG,KAAO,EAAK,EAEpD,OAAO1C,EAASnB,SAAWqK,KAW7BC,0BAAA,SAA0BxE,GACxBA,EAAO,GAAKA,EAEN3E,IAAAA,EAAWlE,KAAKlB,OAAO9F,IAAI6P,GAE7B,IAAC3E,EACH,MAAM,IAAI9B,EAAJ,wDAAA5K,OACoDqR,EAD1D,yBAIF,GAAkB,eAAd7I,KAAKpG,KAAuB,OAAO,EAEvC,IAAMuT,EAAOjJ,EAASlF,IAAI6J,GACpBuE,EAAQD,EAAQnN,KAAKuF,MAAQ4H,EAAKvG,KAAO,EAAK,EAEpD,OAAO1C,EAASlB,UAAYoK,KAW9BE,+BAAA,SAA+BzE,GAC7BA,EAAO,GAAKA,EAEN3E,IAAAA,EAAWlE,KAAKlB,OAAO9F,IAAI6P,GAE7B,IAAC3E,EACH,MAAM,IAAI9B,EAAJ,6DAAA5K,OACyDqR,EAD/D,yBAIF,GAAkB,eAAd7I,KAAKpG,KAAuB,OAAO,EAEvC,IAAMuT,EAAOjJ,EAASlF,IAAI6J,GACpBuE,EAAQD,EAAQnN,KAAKuF,MAAQ4H,EAAKvG,KAAO,EAAK,EAE7C1C,OAAAA,EAASnB,SAAWmB,EAASlB,UAAoB,EAARoK,KAWlDG,iCAAA,SAAiC1E,GAC/BA,EAAO,GAAKA,EAEN3E,IAAAA,EAAWlE,KAAKlB,OAAO9F,IAAI6P,GAE7B,IAAC3E,EACH,MAAM,IAAI9B,EAAJ,+DAAA5K,OAC2DqR,EADjE,yBAIF,GAAkB,aAAd7I,KAAKpG,KAAqB,OAAO,EAErC,IAAMuT,EAAOjJ,EAASjF,WAAW4J,GAC3BuE,EAAQD,EAAQnN,KAAKuF,MAAQ4H,EAAKvG,KAAO,EAAK,EAEpD,OAAO1C,EAASjB,iBAA2B,EAARmK,KAWrCI,8BAAA,SAA8B3E,GAC5BA,EAAO,GAAKA,EAEN3E,IAOFiJ,EAPEjJ,EAAWlE,KAAKlB,OAAO9F,IAAI6P,GAE7B,IAAC3E,EACH,MAAM,IAAI9B,EAAJ,4DAAA5K,OACwDqR,EAD9D,yBAKEmE,IAAAA,EAAS,EACTI,EAAQ,EAgBLJ,MAdW,aAAdhN,KAAKpG,OACPoT,GAAU9I,EAASjB,iBAGnBmK,GAAqD,IADrDD,EAAOjJ,EAASjF,WAAW4J,IACT7I,KAAKuF,MAAQ4H,EAAKvG,KAAO,EAAK,IAGhC,eAAd5G,KAAKpG,OACPoT,GAAU9I,EAASnB,SAGnBqK,IADAD,EAAOjJ,EAASlF,IAAI6J,IACH7I,KAAKuF,MAAQ4H,EAAKvG,KAAO,EAAK,GAG1CoG,EAASI,KAWlBK,+BAAA,SAA+B5E,GAC7BA,EAAO,GAAKA,EAEN3E,IAOFiJ,EAPEjJ,EAAWlE,KAAKlB,OAAO9F,IAAI6P,GAE7B,IAAC3E,EACH,MAAM,IAAI9B,EAAJ,6DAAA5K,OACyDqR,EAD/D,yBAKEmE,IAAAA,EAAS,EACTI,EAAQ,EAgBLJ,MAdW,aAAdhN,KAAKpG,OACPoT,GAAU9I,EAASjB,iBAGnBmK,GAAqD,IADrDD,EAAOjJ,EAASjF,WAAW4J,IACT7I,KAAKuF,MAAQ4H,EAAKvG,KAAO,EAAK,IAGhC,eAAd5G,KAAKpG,OACPoT,GAAU9I,EAASlB,UAGnBoK,IADAD,EAAOjJ,EAAA,GAAY2E,IACF7I,KAAKuF,MAAQ4H,EAAKvG,KAAO,EAAK,GAG1CoG,EAASI,KAWlBM,uBAAA,SAAuB7E,GACrBA,EAAO,GAAKA,EAEN3E,IAOFiJ,EAPEjJ,EAAWlE,KAAKlB,OAAO9F,IAAI6P,GAE7B,IAAC3E,EACH,MAAM,IAAI9B,EAAJ,qDAAA5K,OACiDqR,EADvD,yBAKEmE,IAAAA,EAAS,EACTI,EAAQ,EAgBLJ,MAdW,aAAdhN,KAAKpG,OACPoT,GAAU9I,EAASjB,iBAGnBmK,GAAqD,IADrDD,EAAOjJ,EAASjF,WAAW4J,IACT7I,KAAKuF,MAAQ4H,EAAKvG,KAAO,EAAK,IAGhC,eAAd5G,KAAKpG,OACPoT,GAAU9I,EAASnB,SAAWmB,EAASlB,UAGvCoK,GAAqD,IADrDD,EAAOjJ,EAASlF,IAAI6J,IACF7I,KAAKuF,MAAQ4H,EAAKvG,KAAO,EAAK,IAG3CoG,EAASI,KAWlBxO,OAAA,SAAOG,GACLA,EAAO,GAAKA,EAEN6F,IAAAA,EAAO5E,KAAKsE,OAAOtL,IAAI+F,GAEzB,IAAC6F,EACH,MAAM,IAAIxC,EAAJ,qCAAA5K,OACiCuH,EADvC,yBAIF,OAAO6F,EAAKhG,OAAO/B,OAWrBhG,OAAA,SAAOkI,GACLA,EAAO,GAAKA,EAEN6F,IAAAA,EAAO5E,KAAKsE,OAAOtL,IAAI+F,GAEzB,IAAC6F,EACH,MAAM,IAAIxC,EAAJ,qCAAA5K,OACiCuH,EADvC,yBAIF,OAAO6F,EAAK/N,OAAOgG,OAWrB8Q,YAAA,SAAY5O,GACVA,EAAO,GAAKA,EAENoF,IAAAA,EAAWnE,KAAKsE,OAAOtL,IAAI+F,GAE7B,IAACoF,EACH,MAAM,IAAI/B,EAAJ,0CAAA5K,OACsCuH,EAD5C,yBAIF,MAAO,CAACoF,EAASvF,OAAO/B,IAAKsH,EAAStN,OAAOgG,MAa/C+Q,EAAAA,SAAA,SAAS/E,EAAM9J,GACb8J,EAAO,GAAKA,EACZ9J,EAAO,GAAKA,EAEN6F,IAAAA,EAAO5E,KAAKsE,OAAOtL,IAAI+F,GAEzB,IAAC6F,EACH,MAAM,IAAIxC,EAAJ,uCAAA5K,OACmCuH,EADzC,yBAIF,IAAMH,EAASgG,EAAKhG,OAAO/B,IACrBhG,EAAS+N,EAAK/N,OAAOgG,IAE3B,GAAIgM,IAASjK,EAAQ,OAAO/H,EAC5B,GAAIgS,IAAShS,EAAQ,OAAO+H,EAEtB,MAAA,IAAIwD,EAAJ,wBAAA5K,OACoBqR,EADpB,mCAAArR,OAC0DuH,EAAeH,YAAAA,OAAAA,EAAW/H,MAAAA,OAAAA,EAD1F,QAcFgX,EAAAA,aAAA,SAAa9O,EAAM8J,GACjB9J,EAAO,GAAKA,EACZ8J,EAAO,GAAKA,EAENjE,IAAAA,EAAO5E,KAAKsE,OAAOtL,IAAI+F,GAEzB,IAAC6F,EACH,MAAM,IAAIxC,EAAJ,2CAAA5K,OACuCuH,EAD7C,yBAIF,OAAO6F,EAAKhG,OAAO/B,MAAQgM,GAAQjE,EAAK/N,OAAOgG,MAAQgM,KAWzDiF,aAAA,SAAa/O,GACXA,EAAO,GAAKA,EAEN6F,IAAAA,EAAO5E,KAAKsE,OAAOtL,IAAI+F,GAEzB,IAAC6F,EACH,MAAM,IAAIxC,EAAJ,2CAAA5K,OACuCuH,EAD7C,yBAIK6F,OAAAA,EAAK3F,cAWd8O,WAAA,SAAWhP,GACTA,EAAO,GAAKA,EAEN6F,IAAAA,EAAO5E,KAAKsE,OAAOtL,IAAI+F,GAEzB,IAAC6F,EACH,MAAM,IAAIxC,EAAJ,yCAAA5K,OACqCuH,EAD3C,yBAIK,OAAC6F,EAAK3F,cAWfuL,WAAA,SAAWzL,GACTA,EAAO,GAAKA,EAEN6F,IAAAA,EAAO5E,KAAKsE,OAAOtL,IAAI+F,GAEzB,IAAC6F,EACH,MAAM,IAAIxC,EAAJ,yCAAA5K,OACqCuH,EAD3C,yBAIF,OAAO6F,EAAKhG,SAAWgG,EAAK/N,QAkB9BmX,EAAAA,QAAA,SAAQnF,EAAM/I,GACNoE,IAAAA,EAjnDV,SAAiBvF,EAAOkK,EAAM/I,GAC5B,GAAIA,IAAeZ,EAAcY,GAC/B,MAAM,IAAIkC,EAAJ,mEAAAxK,OAC+DsI,EAD/D,MAQR,GAHA+I,EAAO,GAAKA,EACZ/I,EAAaA,GAAc,GAEvBnB,EAAMG,OAAOwJ,IAAIO,GACnB,MAAM,IAAItG,EAAJ,uBAAA/K,OACmBqR,EADzB,uCAIF,IAAMjE,EAAO,IAAIjG,EAAMwL,cAActB,EAAM/I,GAW3C,OARAnB,EAAMG,OAAO7F,IAAI4P,EAAMjE,GAGvBjG,EAAMhF,KAAK,YAAa,CACtBkD,IAAKgM,EACL/I,WAAAA,IAGK8E,EAulDYoJ,CAAQhO,KAAM6I,EAAM/I,GAE9BoE,OAAAA,EAASrH,KAUlBoR,EAAAA,UAAA,SAAUpF,EAAM/I,GACd,GAAIA,IAAeZ,EAAcY,GAC/B,MAAM,IAAIkC,EAAJ,qEAAAxK,OACiEsI,EADjE,MAKR+I,EAAO,GAAKA,EACZ/I,EAAaA,GAAc,GAGvB8E,IAAAA,EAAO5E,KAAKlB,OAAO9F,IAAI6P,GAE3B,OAAIjE,GACE9E,IACFvB,EAAOqG,EAAK9E,WAAYA,GAEnBnG,KAAAA,KAAK,wBAAyB,CACjCC,KAAM,QACNiD,IAAKgM,EACL/I,WAAY8E,EAAK9E,WACjB8E,KAAM9E,KAGH,CAAC+I,GAAM,KAGhBjE,EAAO,IAAI5E,KAAKmK,cAActB,EAAM/I,GAG/BhB,KAAAA,OAAO7F,IAAI4P,EAAMjE,GAGjBjL,KAAAA,KAAK,YAAa,CACrBkD,IAAKgM,EACL/I,WAAAA,IAGK,CAAC+I,GAAM,KAWhBqF,EAAAA,WAAA,SAAWrF,EAAM5D,GACf,GAAIA,GAA8B,mBAAZA,EACpB,MAAM,IAAIjD,EAAJ,6EAAAxK,OACyEyN,EADzE,MAKR4D,EAAO,GAAKA,EAGRjE,IAAAA,EAAO5E,KAAKlB,OAAO9F,IAAI6P,GAE3B,GAAIjE,EAAM,CACR,GAAIK,EAAS,CACX,IAAMgG,EAAgBrG,EAAK9E,WAC3B8E,EAAK9E,WAAamF,EAAQgG,GAErBtR,KAAAA,KAAK,wBAAyB,CACjCC,KAAM,UACNiD,IAAKgM,EACL/I,WAAY8E,EAAK9E,aAGrB,MAAO,CAAC+I,GAAM,GAGV/I,IAAAA,EAAamF,EAAUA,EAAQ,IAAM,GAa3C,OAXAL,EAAO,IAAI5E,KAAKmK,cAActB,EAAM/I,GAG/BhB,KAAAA,OAAO7F,IAAI4P,EAAMjE,GAGjBjL,KAAAA,KAAK,YAAa,CACrBkD,IAAKgM,EACL/I,WAAAA,IAGK,CAAC+I,GAAM,MAWhBsF,SAAA,SAAStF,GACPA,EAAO,GAAKA,EAEN3E,IAOFC,EAPED,EAAWlE,KAAKlB,OAAO9F,IAAI6P,GAE7B,IAAC3E,EACH,MAAM,IAAI9B,EAAJ,uCAAA5K,OACmCqR,EADzC,yBAQF,GAAkB,eAAd7I,KAAKpG,KAAuB,CAC9B,IAAK,IAAM8O,KAAYxE,EAASlF,IAAK,CACnCmF,EAAWD,EAASlF,IAAI0J,GAErB,GACD0C,GAAiBpL,KAAMmE,GACvBA,EAAWA,EAAShE,WACbgE,GAGX,IAAK,IAAMuE,KAAYxE,KAAa,CAClCC,EAAWD,EAAA,GAAYwE,GAEpB,GACD0C,GAAiBpL,KAAMmE,GACvBA,EAAWA,EAAShE,WACbgE,IAIb,GAAkB,aAAdnE,KAAKpG,KACP,IAAK,IAAM8O,KAAYxE,EAASjF,WAAY,CAC1CkF,EAAWD,EAASjF,WAAWyJ,GAE5B,GACD0C,GAAiBpL,KAAMmE,GACvBA,EAAWA,EAAShE,WACbgE,GAKbnE,KAAKlB,OAAL,OAAmB+J,GAGdlP,KAAAA,KAAK,cAAe,CACvBkD,IAAKgM,EACL/I,WAAYoE,EAASpE,gBAkBzBsO,SAAA,SAASrP,GACP,IAAIoF,EAEJ,GAAIrK,UAAUC,OAAS,EAAG,CACxB,IAAM6E,EAAS,GAAK9E,UAAU,GACxBjD,EAAS,GAAKiD,UAAU,GAI1B,KAFJqK,EAAWzF,EAAgBsB,KAAMpB,EAAQ/H,EAAQmJ,KAAKpG,OAGpD,MAAM,IAAIwI,EAC+BxD,uCAAAA,OAAAA,EAAe/H,UAAAA,OAAAA,EADxD,8BAQE,GAJJkI,EAAO,GAAKA,IAEZoF,EAAWnE,KAAKsE,OAAOtL,IAAI+F,IAGzB,MAAM,IAAIqD,EAAJ,uCAAA5K,OACmCuH,EADzC,yBAOJ,OAFAqM,GAAiBpL,KAAMmE,GAEhBnE,MAaTqO,EAAAA,iBAAA,SAAiBzP,EAAQ/H,GACnBiD,GAAAA,UAAUC,OAAS,EACrB,MAAM,IAAIwI,EACR,iLAGA,GAAAvC,KAAKuF,MACP,MAAM,IAAIhD,EACR,sLAME4B,IAAAA,EAAWzF,EAAgBsB,KAHjCpB,EAAS,GAAKA,EACd/H,EAAS,GAAKA,EAEyC,YAEnD,IAACsN,EACH,MAAM,IAAI/B,EACqCxD,6CAAAA,OAAAA,EAAe/H,UAAAA,OAAAA,EAD9D,yBAMF,OAFAuU,GAAiBpL,KAAMmE,GAEhBnE,MAaTsO,EAAAA,mBAAA,SAAmB1P,EAAQ/H,GACrBiD,GAAAA,UAAUC,OAAS,EACrB,MAAM,IAAIwI,EACR,2KAGA,GAAAvC,KAAKuF,MACP,MAAM,IAAIhD,EACR,wLAGE4B,IAAAA,EAAWzF,EAAgBsB,KAAMpB,EAAQ/H,EAAQ,cAEnD,IAACsN,EACH,MAAM,IAAI/B,EACuCxD,+CAAAA,OAAAA,EAAe/H,UAAAA,OAAAA,EADhE,yBAMF,OAFAuU,GAAiBpL,KAAMmE,GAEhBnE,MAQT2C,EAAAA,MAAA,WAEE3C,KAAKsE,OAAO3B,QAGZ3C,KAAKlB,OAAO6D,QAGPqJ,KAAAA,yBAGArS,KAAAA,KAAK,YAQZ4U,EAAAA,WAAA,WAME,IAJA,IAEI/M,EAFEnB,EAAWL,KAAKlB,OAAOmI,UAImB,KAAvCzF,EAAOnB,EAASF,QAAcK,MACrCgB,EAAKxJ,MAAM2K,QAIb3C,KAAKsE,OAAO3B,QAGPqJ,KAAAA,yBAGArS,KAAAA,KAAK,mBAcZ6U,aAAA,SAAalT,GACX,OAAO0E,KAAKyO,YAAYnT,IAQ1BoT,EAAAA,cAAA,WACE,OAAO1O,KAAKyO,eASdE,aAAA,SAAarT,GACX,OAAO0E,KAAKyO,YAAY3J,eAAexJ,IAUzCsT,EAAAA,aAAA,SAAatT,EAAMtD,GAUjB,OATAgI,KAAKyO,YAAYnT,GAAQtD,EAGpB2B,KAAAA,KAAK,oBAAqB,CAC7BC,KAAM,MACNkG,WAAYE,KAAKyO,YACjBnT,KAAAA,IAGK0E,MAUT6O,EAAAA,gBAAA,SAAgBvT,EAAM2J,GAChB,GAAmB,mBAAZA,EACT,MAAM,IAAIjD,EACR,wDAGJ,IAAMhK,EAAQgI,KAAKyO,YAAYnT,GAW/B,OATKmT,KAAAA,YAAYnT,GAAQ2J,EAAQjN,GAG5B2B,KAAAA,KAAK,oBAAqB,CAC7BC,KAAM,MACNkG,WAAYE,KAAKyO,YACjBnT,KAAAA,IAGK0E,QAST8O,gBAAA,SAAgBxT,GAUd,cATO0E,KAAKyO,YAAYnT,GAGnB3B,KAAAA,KAAK,oBAAqB,CAC7BC,KAAM,SACNkG,WAAYE,KAAKyO,YACjBnT,KAAAA,IAGK0E,QAWT+O,kBAAA,SAAkBjP,GACZ,IAACZ,EAAcY,GACjB,MAAM,IAAIkC,EACR,wEAWJ,OARAhC,KAAKyO,YAAc3O,EAGdnG,KAAAA,KAAK,oBAAqB,CAC7BC,KAAM,UACNkG,WAAYE,KAAKyO,cAGZzO,QAWTgP,gBAAA,SAAgBlP,GACV,IAACZ,EAAcY,GACjB,MAAM,IAAIkC,EACR,sEAYJ,OATAzD,EAAOyB,KAAKyO,YAAa3O,GAGpBnG,KAAAA,KAAK,oBAAqB,CAC7BC,KAAM,QACNkG,WAAYE,KAAKyO,YACjB7J,KAAM9E,IAGDE,QAWTiP,iBAAA,SAAiBhK,GACX,GAAmB,mBAAZA,EACT,MAAM,IAAIjD,EACR,+DAWJ,OARKyM,KAAAA,YAAcxJ,EAAQjF,KAAKyO,aAG3B9U,KAAAA,KAAK,oBAAqB,CAC7BC,KAAM,SACNkG,WAAYE,KAAKyO,cAGZzO,MASTkP,EAAAA,yBAAA,SAAyBjK,EAASpF,GAC5B,GAAmB,mBAAZoF,EACT,MAAM,IAAIjD,EACR,kEAGJ,GAAInC,IAAUD,EAAcC,GAC1B,MAAM,IAAImC,EACR,0HAOJ,IAJA,IAEIR,EAAM0C,EAFJ7D,EAAWL,KAAKlB,OAAOmI,UAImB,KAAvCzF,EAAOnB,EAASF,QAAcK,OACrC0D,EAAW1C,EAAKxJ,OACP8H,WAAamF,EAAQf,EAASrH,IAAKqH,EAASpE,YAGlDnG,KAAAA,KAAK,4BAA6B,CACrCkG,MAAOA,GAAgB,QAU3BsP,EAAAA,yBAAA,SAAyBlK,EAASpF,GAC5B,GAAmB,mBAAZoF,EACT,MAAM,IAAIjD,EACR,kEAGJ,GAAInC,IAAUD,EAAcC,GAC1B,MAAM,IAAImC,EACR,0HAOJ,IAJA,IAEIR,EAAM2C,EAAUtF,EAAY2H,EAF1BnG,EAAWL,KAAKsE,OAAO2C,UAImB,KAAvCzF,EAAOnB,EAASF,QAAcK,MAErC3B,GADAsF,EAAW3C,EAAKxJ,OACM4G,OACtB4H,EAAarC,EAAStN,OAEtBsN,EAASrE,WAAamF,EACpBd,EAAStH,IACTsH,EAASrE,WACTjB,EAAWhC,IACX2J,EAAW3J,IACXgC,EAAWiB,WACX0G,EAAW1G,WACXqE,EAASlF,YAIRtF,KAAAA,KAAK,4BAA6B,CACrCkG,MAAOA,GAAgB,UAc3BuP,sBAAA,SAAsBpJ,GAChB,GAAoB,mBAAbA,EACT,MAAM,IAAIhE,EACR,sDAGJmH,IAAiB,GAAO,GAAO,EAAOnJ,KAAMgG,MAE9CqJ,iCAAA,SAAiCrJ,GAC3B,GAAoB,mBAAbA,EACT,MAAM,IAAIhE,EACR,iEAGJmH,IAAiB,GAAO,GAAO,EAAMnJ,KAAMgG,MAQ7CsJ,gCAAA,SAAgCtJ,GAC1B,GAAoB,mBAAbA,EACT,MAAM,IAAIhE,EACR,gEAGJmH,IAAiB,GAAO,GAAM,EAAOnJ,KAAMgG,MAE7CuJ,2CAAA,SAA2CvJ,GACrC,GAAoB,mBAAbA,EACT,MAAM,IAAIhE,EACR,2EAGJmH,IAAiB,GAAO,GAAM,EAAMnJ,KAAMgG,IAQ5CwJ,EAAAA,MAAA,WACE,MAA0B,mBAAfjS,MAAMsJ,KAA4BtJ,MAAMsJ,KAAK7G,KAAKlB,OAAOlC,QAE7D0E,EAAKtB,KAAKlB,OAAOlC,OAAQoD,KAAKlB,OAAO8H,SAQ9C6I,YAAA,SAAYzJ,GACN,GAAoB,mBAAbA,EACT,MAAM,IAAIhE,EACR,4CAOJ,IAJA,IAEIR,EAAM0C,EAFJ7D,EAAWL,KAAKlB,OAAOmI,UAImB,KAAvCzF,EAAOnB,EAASF,QAAcK,MAErCwF,GADA9B,EAAW1C,EAAKxJ,OACE6E,IAAKqH,EAASpE,eAUpC4P,SAAA,SAAS1J,GACH,GAAoB,mBAAbA,EACT,MAAM,IAAIhE,EACR,yCAOJ,IAJA,IAEIR,EAAM0C,EAFJ7D,EAAWL,KAAKlB,OAAOmI,UAImB,KAAvCzF,EAAOnB,EAASF,QAAcK,MAGrC,GAAIwF,GAFJ9B,EAAW1C,EAAKxJ,OAEM6E,IAAKqH,EAASpE,YAAa,OAAOoE,EAASrH,OAWrE8S,SAAA,SAAS3J,GACH,GAAoB,mBAAbA,EACT,MAAM,IAAIhE,EACR,wCAUJ,IAPA,IAEIR,EAAM0C,EAFJ7D,EAAWL,KAAKlB,OAAOmI,SAIvB2I,EAAS,IAAIrS,MAAMyC,KAAK6P,OAC1BhW,EAAI,GAEwC,KAAvC2H,EAAOnB,EAASF,QAAcK,MACrC0D,EAAW1C,EAAKxJ,MAChB4X,EAAO/V,KAAOmM,EAAS9B,EAASrH,IAAKqH,EAASpE,YAGhD,OAAO8P,KAQTE,SAAA,SAAS9J,GACH,GAAoB,mBAAbA,EACT,MAAM,IAAIhE,EACR,yCAOJ,IAJA,IAEIR,EAAM0C,EAFJ7D,EAAWL,KAAKlB,OAAOmI,UAImB,KAAvCzF,EAAOnB,EAASF,QAAcK,MAGrC,GAAIwF,GAFJ9B,EAAW1C,EAAKxJ,OAEM6E,IAAKqH,EAASpE,YAAa,OAAO,EAG1D,OAAO,KAQTiQ,UAAA,SAAU/J,GACJ,GAAoB,mBAAbA,EACT,MAAM,IAAIhE,EACR,0CAOJ,IAJA,IAEIR,EAAM0C,EAFJ7D,EAAWL,KAAKlB,OAAOmI,UAImB,KAAvCzF,EAAOnB,EAASF,QAAcK,MAGrC,IAAKwF,GAFL9B,EAAW1C,EAAKxJ,OAEO6E,IAAKqH,EAASpE,YAAa,OAAO,EAG3D,OAAO,KAQTkQ,YAAA,SAAYhK,GACN,GAAoB,mBAAbA,EACT,MAAM,IAAIhE,EACR,4CASJ,IANA,IAEIR,EAAM0C,EAFJ7D,EAAWL,KAAKlB,OAAOmI,SAIvB2I,EAAS,IAEiC,KAAvCpO,EAAOnB,EAASF,QAAcK,MAGjCwF,GAFJ9B,EAAW1C,EAAKxJ,OAEM6E,IAAKqH,EAASpE,aAClC8P,EAAO5V,KAAKkK,EAASrH,KAGzB,OAAO+S,GAQTK,EAAAA,YAAA,SAAYjK,EAAUkK,GAChB,GAAoB,mBAAblK,EACT,MAAM,IAAIhE,EACR,4CAGAlI,GAAAA,UAAUC,OAAS,EACrB,MAAM,IAAIiI,EACR,qNASJ,IANImO,IAIA3O,EAAM0C,EAJNiM,EAAcD,EAEZ7P,EAAWL,KAAKlB,OAAOmI,UAImB,KAAvCzF,EAAOnB,EAASF,QAAcK,MAErC2P,EAAcnK,EAASmK,GADvBjM,EAAW1C,EAAKxJ,OAC6B6E,IAAKqH,EAASpE,YAG7D,OAAOqQ,GAQTC,EAAAA,YAAA,WACE,IAAM/P,EAAWL,KAAKlB,OAAOmI,SAEtB,OAAA,IAAI/G,GAAS,WAClB,IAAMsB,EAAOnB,EAASF,OAEtB,GAAIqB,EAAKhB,KAAM,OAAOgB,EAEtB,IAAMoD,EAAOpD,EAAKxJ,MAEX,MAAA,CACLA,MAAO,CAAC6Q,KAAMjE,EAAK/H,IAAKiD,WAAY8E,EAAK9E,YACzCU,MAAM,gBAeZ,WAAS,IAAA0B,EAAAlC,KACDwP,EAAQ,IAAIjS,MAAMyC,KAAKlB,OAAO8H,MAEhC/M,EAAI,EAEHiF,KAAAA,OAAO+M,SAAQ,SAACjH,EAAM/H,GACzB2S,EAAM3V,KDhiFL,SAAuBgD,EAAK+H,GACjC,IAAMyL,EAAa,CAACxT,IAAAA,GAKpB,OAHKwC,EAAQuF,EAAK9E,cAChBuQ,EAAWvQ,WAAavB,EAAO,GAAIqG,EAAK9E,aAEnCuQ,EC0hFUC,CAAczT,EAAK+H,MAG5B8C,IAAAA,EAAQ,IAAInK,MAAMyC,KAAKsE,OAAOsC,MAQ7B,OANP/M,EAAI,EAECyK,KAAAA,OAAOuH,SAAQ,SAACjH,EAAM/H,GACzB6K,EAAM7N,KDvhFL,SAAuBD,EAAMiD,EAAK+H,GACvC,IAAMyL,EAAa,CACjBxT,IAAAA,EACA+B,OAAQgG,EAAKhG,OAAO/B,IACpBhG,OAAQ+N,EAAK/N,OAAOgG,KAQtB,OALKwC,EAAQuF,EAAK9E,cAChBuQ,EAAWvQ,WAAavB,EAAO,GAAIqG,EAAK9E,aAE7B,UAATlG,GAAoBgL,EAAK3F,aAAYoR,EAAWpR,YAAa,GAE1DoR,EC2gFUE,CAAcrO,EAAKtI,KAAMiD,EAAK+H,MAGtC,CACL0G,QAAS,CACP1R,KAAMoG,KAAKpG,KACX2L,MAAOvF,KAAKuF,MACZ0E,eAAgBjK,KAAKiK,gBAEvBnK,WAAYE,KAAK0O,gBACjBc,MAAAA,EACA9H,MAAAA,IAWJ8I,EAAA,OAAA,SAAO5L,GAAqB,IAuCtB/K,EAAG2E,EAAGnC,EAAMwM,EAAM9J,EAvCIuD,EAAAtC,KAAfyQ,0DAEP7L,GAAAA,aAAgByG,EAkBlB,OAhBAzG,EAAK6K,aAAY,SAAClW,EAAGmX,GACfD,EAAOnO,EAAK2L,UAAU1U,EAAGmX,GACxBpO,EAAK0L,QAAQzU,EAAGmX,MAIvB9L,EAAKsC,aAAY,SAACyJ,EAAGD,EAAGE,EAAGC,EAAGC,EAAKC,EAAKC,GAClCP,EACEO,EAAG1O,EAAK2O,2BAA2BN,EAAGC,EAAGC,EAAGH,GAC3CpO,EAAK4O,yBAAyBP,EAAGC,EAAGC,EAAGH,GAExCM,EAAG1O,EAAK6O,yBAAyBR,EAAGC,EAAGC,EAAGH,GACzCpO,EAAK8O,uBAAuBT,EAAGC,EAAGC,EAAGH,MAIvC1Q,KAIL,IAACd,EAAc0F,GACjB,MAAM,IAAI5C,EACR,qGAGA4C,GAAAA,EAAK9E,WAAY,CACnB,IAAKZ,EAAc0F,EAAK9E,YACtB,MAAM,IAAIkC,EACR,+DAGAyO,EAAOzQ,KAAKgP,gBAAgBpK,EAAK9E,YAChCE,KAAK+O,kBAAkBnK,EAAK9E,YAK/B8E,GAAAA,EAAK4K,MAAO,CAGd,GAFAnT,EAAOuI,EAAK4K,OAEPjS,MAAMwC,QAAQ1D,GACjB,MAAM,IAAI2F,EACR,oDAGJ,IAAKnI,EAAI,EAAG2E,EAAInC,EAAKtC,OAAQF,EAAI2E,EAAG3E,IAAK,CAIvC0P,GAHAV,EAAOxM,EAAKxC,IAMZ,IAAAwX,EAA0BxI,EAAnBhM,IAAAA,IAAKiD,IAAAA,WAER2Q,EAAOzQ,KAAKiO,UAAUpR,EAAKiD,GAC1BE,KAAKgO,QAAQnR,EAAKiD,IAIvB8E,GAAAA,EAAK8C,MAAO,CACV4J,IAAAA,GAAsB,EAQ1B,GANkB,eAAdtR,KAAKpG,OACP0X,GAAsB,GAGxBjV,EAAOuI,EAAK8C,OAEPnK,MAAMwC,QAAQ1D,GACjB,MAAM,IAAI2F,EACR,oDAGJ,IAAKnI,EAAI,EAAG2E,EAAInC,EAAKtC,OAAQF,EAAI2E,EAAG3E,IAAK,CAIvC2P,GAHAzK,EAAO1C,EAAKxC,IAMZ,IAAA0X,EAKIxS,EAJFH,IAAAA,OACA/H,IAAAA,OACAiJ,IAAAA,WAHF0R,EAAAD,EAIEtS,WAAAA,aAAaqS,EAJfE,EASI,QAASzS,GACF0R,EACLxR,EACEe,KAAKiR,2BACLjR,KAAKkR,yBACPjS,EACAe,KAAKmR,yBACLnR,KAAKoR,wBAEFla,KAAK8I,KAAMjB,EAAKlC,IAAK+B,EAAQ/H,EAAQiJ,IAEnC2Q,EACLxR,EACEe,KAAKyR,oBACLzR,KAAK0R,kBACPzS,EACAe,KAAK2R,kBACL3R,KAAK4R,iBAEF1a,KAAK8I,KAAMpB,EAAQ/H,EAAQiJ,IAKxC,OAAOE,QAeT6R,SAAA,SAASvG,GACP,IAAM3M,EAAQ,IAAI0M,EAAM9M,EAAO,GAAIyB,KAAK+L,SAAUT,IAElD,OADA3M,EAAMoQ,kBAAkBxQ,EAAO,GAAIyB,KAAK0O,kBACjC/P,KAUTmT,UAAA,SAAUxG,GACR,IAAM3M,EAAQqB,KAAK6R,SAASvG,GAU5B,OARKxM,KAAAA,OAAO+M,SAAQ,SAAC3H,EAAUrH,GACvBiD,IAAAA,EAAavB,EAAO,GAAI2F,EAASpE,YAGvCoE,EAAW,IAAIvF,EAAMwL,cAActN,EAAKiD,GACxCnB,EAAMG,OAAO7F,IAAI4D,EAAKqH,MAGjBvF,KASTrB,KAAA,SAAKgO,GAGH,GAC0B,iBAH1BA,EAAUA,GAAW,IAGJ1R,MACf0R,EAAQ1R,OAASoG,KAAKpG,MACL,UAAjB0R,EAAQ1R,KAER,MAAM,IAAI2I,EACgD,wDAAA/K,OAAAwI,KAAKpG,KADzD,eAAApC,OAC2E8T,EAAQ1R,KADzF,0EAKA,GAAyB,kBAAlB0R,EAAQ/F,OACf+F,EAAQ/F,QAAUvF,KAAKuF,QACL,IAAlB+F,EAAQ/F,MAER,MAAM,IAAIhD,EACR,mKAIF,GAAkC,kBAA3B+I,EAAQrB,gBACfqB,EAAQrB,iBAAmBjK,KAAKiK,iBACL,IAA3BqB,EAAQrB,eAER,MAAM,IAAI1H,EACR,4KASJ,IANA,IAIIf,EAAM2C,EAJJxF,EAAQqB,KAAK8R,UAAUxG,GAEvBjL,EAAWL,KAAKsE,OAAO2C,UAImB,KAAvCzF,EAAOnB,EAASF,QAAcK,MAIrC4J,GACEzL,EACA,QACA,GANFwF,EAAW3C,EAAKxJ,OAOLiH,WACTkF,EAAStH,IACTsH,EAASvF,OAAO/B,IAChBsH,EAAStN,OAAOgG,IAChB0B,EAAO,GAAI4F,EAASrE,aAIxB,OAAOnB,GAaToT,EAAAA,OAAA,WACE,OAAO/R,KAAP,UAMFgS,EAAAA,SAAA,WACE,MAAO,kBAQTC,EAAAA,QAAA,WAAU,IAAAxP,EAAAzC,KACFwP,EAAQ,GACT1Q,KAAAA,OAAO+M,SAAQ,SAACjH,EAAM/H,GACzB2S,EAAM3S,GAAO+H,EAAK9E,cAGd4H,IAAAA,EAAQ,GACZwK,EAAa,GAEV5N,KAAAA,OAAOuH,SAAQ,SAACjH,EAAM/H,GACnB+I,IAMFuM,EANEvM,EAAYhB,EAAK3F,WAAa,KAAO,KAEvCmT,EAAQ,GAERxT,EAASgG,EAAKhG,OAAO/B,IACrBhG,EAAS+N,EAAK/N,OAAOgG,IAGrB+H,EAAK3F,YAAcL,EAAS/H,IAC9Bsb,EAAMvT,EACNA,EAAS/H,EACTA,EAASsb,GAGX,IAAME,EAAWzT,IAAAA,OAAAA,cAAUgH,EAAjB,KAAApO,OAA8BX,EAAxC,KAEKgG,EAAIyV,WAAW,SAET7P,EAAK8C,aACkB,IAArB2M,EAAWG,GACpBH,EAAWG,GAAQ,EAEnBH,EAAWG,KAGbD,GAAYF,GAAAA,OAAAA,EAAWG,GAAvB,OARAD,GAAavV,IAAAA,OAAAA,EAAb,OAaF6K,EAFA0K,GAASC,GAEMzN,EAAK9E,cAGhByS,IAAAA,EAAQ,GAEd,IAAK,IAAM9T,KAAKuB,KAEZA,KAAK8E,eAAerG,KACnBsL,GAAczB,IAAI7J,IACA,mBAAZuB,KAAKvB,IACC,WAAbU,EAAOV,KAEP8T,EAAM9T,GAAKuB,KAAKvB,IASpB,OANA8T,EAAMzS,WAAaE,KAAKyO,YACxB8D,EAAM/C,MAAQA,EACd+C,EAAM7K,MAAQA,EAEdnI,EAAgBgT,EAAO,cAAevS,KAAKZ,aAEpCmT,MAvzEwBta,wBAs0Eb,oBAAXmI,SACTiL,GAAMpU,UAAUmJ,OAAA,IAAW,+BACzBiL,GAAMpU,UAAUgb,SAl1FK,CACvB,CACE3W,KAAM,SAAAkX,GAAI,MAAA,GAAAhb,OAAOgb,EAAP,SACVC,aAAa,GAEf,CACEnX,KAAM,SAAAkX,GAAI,MAAA,GAAAhb,OAAOgb,EAAP,iBACVC,aAAa,EACb7Y,KAAM,YAER,CACE0B,KAAM,SAAAkX,GAAI,MAAA,GAAAhb,OAAOgb,EAAP,mBACVC,aAAa,EACb7Y,KAAM,cAER,CACE0B,KAAM,SAAAkX,GAAI,MAAA,GAAAhb,OAAOgb,EAAP,iBAEZ,CACElX,KAAM,SAAAkX,GAAI,MAAA,GAAAhb,OAAOgb,EAAP,wBACV5Y,KAAM,YAER,CACE0B,KAAM,SAAAkX,GAAI,MAAA,GAAAhb,OAAOgb,EAAP,0BACV5Y,KAAM,eA+zFOiS,SAAQ,SAAAjI,GACtB,CAAA,MAAO,QAAS,UAAUiI,SAAQ,SAAA2G,GACjC,IAAMlX,EAAOsI,EAAOtI,KAAKkX,GACnBhL,EAAc,QAATgL,EAAiBpI,GAAUS,GAElCjH,EAAO6O,YACTpH,GAAMpU,UAAUqE,GAAQ,SAAUsD,EAAQ/H,EAAQiJ,GAChD,OAAO0H,EACLxH,KACA1E,GACA,EAC+B,gBAA9BsI,EAAOhK,MAAQoG,KAAKpG,MACrB,KACAgF,EACA/H,EACAiJ,EACS,WAAT0S,IAIJnH,GAAMpU,UAAUqE,GAAQ,SAAUyD,EAAMH,EAAQ/H,EAAQiJ,GACtD,OAAO0H,EACLxH,KACA1E,GACA,EAC+B,gBAA9BsI,EAAOhK,MAAQoG,KAAKpG,MACrBmF,EACAH,EACA/H,EACAiJ,EACS,WAAT0S,UP3lFK,SAAqCnH,GAClD9G,EAAwBsH,SAAQ,SAA4B6G,GAAjBpX,IAAAA,IAAAA,KAAMmJ,IAAAA,SAE/CA,EAAS4G,EAAO/P,EAAK,QArVZ,GAwVTmJ,EAAS4G,EAAO/P,EAAK,UAvVV,GA0VXmJ,EAAS4G,EAAO/P,EAAK,UAzVV,GA4VXmJ,EAAS4G,EAAO/P,EAAK,YA3VR,MOo7FjBqX,CAA4BtH,INtsEb,SAAqCA,GAClD/F,EAAwBuG,SAAQ,SAA4B6G,GAAjBpX,IAAAA,IAAAA,KAAMmJ,IAAAA,SAE/CA,EAAS4G,EAAO/P,EAAK,QAAS,SAG9BmJ,EAAS4G,EAAO/P,EAAK,gBAAiB,YAGtCmJ,EAAS4G,EAAO/P,EAAK,kBAAmB,iBM8rE5CsX,CAA4BvH,IJ9wDb,SAAoCA,GACjD1F,GAAgBkG,SAAQ,SAAAjD,IAllB1B,SAAgClE,EAAOkE,GACrC,IAAOtN,EAAyBsN,EAAzBtN,KAAM1B,EAAmBgP,EAAnBhP,KAAMgM,EAAagD,EAAbhD,UAkBnBlB,EAAMzN,UAAUqE,GAAQ,SAAUsD,EAAQ/H,GAExC,GAAa,UAAT+C,GAAkC,UAAdoG,KAAKpG,MAAoBA,IAASoG,KAAKpG,KAC7D,MAAO,GAEL,IAACE,UAAUC,OAAQ,OAAO4M,GAAgB3G,KAAMpG,GAEpD,GAAyB,IAArBE,UAAUC,OAAc,CAC1B6E,EAAS,GAAKA,EAERsF,IAAAA,EAAWlE,KAAKlB,OAAO9F,IAAI4F,GAEjC,QAAwB,IAAbsF,EACT,MAAM,IAAI9B,EAAJ,SAAA5K,OACK8D,EADL,0BAAA9D,OACkCoH,EADlC,yBAKR,OAAO6I,GACLzH,KAAKuF,MACI,UAAT3L,EAAmBoG,KAAKpG,KAAOA,EAC/BgM,EACA1B,GAIJ,GAAyB,IAArBpK,UAAUC,OAAc,CAC1B6E,EAAS,GAAKA,EACd/H,EAAS,GAAKA,EAERgI,IAAAA,EAAamB,KAAKlB,OAAO9F,IAAI4F,GAE/B,IAACC,EACH,MAAM,IAAIuD,EACC9G,SAAAA,OAAAA,EAA8BsD,2BAAAA,OAAAA,EADzC,gCAIF,IAAKoB,KAAKlB,OAAOwJ,IAAIzR,GACnB,MAAM,IAAIuL,EACC9G,SAAAA,OAAAA,oCAA8BzE,EADnC,gCAKR,OAAOgR,GACLjO,EACAoG,KAAKuF,MACLK,EACA/G,EACAhI,GAIE,MAAA,IAAImL,EACC1G,SAAAA,OAAAA,+DAAyDxB,UAAUC,OAD9E,QA4gBA8Y,CAAuBxH,EAAOzC,GAhgBlC,SAA2BlE,EAAOkE,GAChC,IAAOtN,EAAyBsN,EAAzBtN,KAAM1B,EAAmBgP,EAAnBhP,KAAMgM,EAAagD,EAAbhD,UAEbkN,EAAc,UAAYxX,EAAK,GAAGyX,cAAgBzX,EAAK0C,MAAM,GAAI,GAsBvE0G,EAAMzN,UAAU6b,GAAe,SAAUlU,EAAQ/H,EAAQmP,GAEvD,GAAa,UAATpM,GAAkC,UAAdoG,KAAKpG,MAAoBA,IAASoG,KAAKpG,KAA/D,CAEA,GAAyB,IAArBE,UAAUC,OAELmN,OAAAA,IAAY,EAAOlH,KAAMpG,EADhCoM,EAAWpH,GAIb,GAAyB,IAArB9E,UAAUC,OAAc,CAC1B6E,EAAS,GAAKA,EACdoH,EAAWnP,EAELqN,IAAAA,EAAWlE,KAAKlB,OAAO9F,IAAI4F,GAEjC,QAAwB,IAAbsF,EACT,MAAM,IAAI9B,EAAJ,SAAA5K,OACKsb,EADL,0BAAAtb,OACyCoH,EADzC,yBAMD0I,OAAAA,IACL,EACAtH,KAAKuF,MACI,UAAT3L,EAAmBoG,KAAKpG,KAAOA,EAC/BgM,EACA1B,EACA8B,GAIJ,GAAyB,IAArBlM,UAAUC,OAAc,CAC1B6E,EAAS,GAAKA,EACd/H,EAAS,GAAKA,EAERgI,IAAAA,EAAamB,KAAKlB,OAAO9F,IAAI4F,GAE/B,IAACC,EACH,MAAM,IAAIuD,EACC0Q,SAAAA,OAAAA,EAAqClU,2BAAAA,OAAAA,EADhD,gCAIF,IAAKoB,KAAKlB,OAAOwJ,IAAIzR,GACnB,MAAM,IAAIuL,EACC0Q,SAAAA,OAAAA,oCAAqCjc,EAD1C,gCAKR,OAAO+Q,IACL,EACAhO,EACAoG,KAAKuF,MACLK,EACA/G,EACAhI,EACAmP,GAIE,MAAA,IAAIhE,EACC8Q,SAAAA,OAAAA,+DAAgEhZ,UAAUC,OADrF,SAyBF,IAAMiZ,EAAU,MAAQ1X,EAAK,GAAGyX,cAAgBzX,EAAK0C,MAAM,GAE3D0G,EAAMzN,UAAU+b,GAAW,WACnBjc,IAGF6Y,EAHE7Y,EAAOwG,MAAMtG,UAAU+G,MAAM9G,KAAK4C,WAClCkM,EAAWjP,EAAK0G,MAKtB,GAAoB,IAAhB1G,EAAKgD,OAAc,CACjBA,IAAAA,EAAS,EAEA,aAATH,IAAqBG,GAAUiG,KAAK8G,gBAC3B,eAATlN,IAAuBG,GAAUiG,KAAK+G,cAE1C6I,EAAS,IAAIrS,MAAMxD,GAEfF,IAAAA,EAAI,EAER9C,EAAKiD,MAAK,SAAC2W,EAAGsC,EAAIrC,EAAGC,EAAGqC,EAAIC,EAAInC,GAC9BpB,EAAO/V,KAAOmM,EAAS2K,EAAGsC,EAAIrC,EAAGC,EAAGqC,EAAIC,EAAInC,WAO9CpB,EAAS,GAET7Y,EAAKiD,MAAK,SAAC2W,EAAGsC,EAAIrC,EAAGC,EAAGqC,EAAIC,EAAInC,GAC9BpB,EAAO5V,KAAKgM,EAAS2K,EAAGsC,EAAIrC,EAAGC,EAAGqC,EAAIC,EAAInC,OAM9C,OAFAhR,KAAK8S,GAAalc,MAAMoJ,KAAMjJ,GAEvB6Y,GAuBT,IAAMwD,EAAa,SAAW9X,EAAK,GAAGyX,cAAgBzX,EAAK0C,MAAM,GAEjE0G,EAAMzN,UAAUmc,GAAc,WACtBrc,IAAAA,EAAOwG,MAAMtG,UAAU+G,MAAM9G,KAAK4C,WAClCkM,EAAWjP,EAAK0G,MAEhBmS,EAAS,GAQf,OANA7Y,EAAKiD,MAAK,SAAC2W,EAAGsC,EAAIrC,EAAGC,EAAGqC,EAAIC,EAAInC,GAC1BhL,EAAS2K,EAAGsC,EAAIrC,EAAGC,EAAGqC,EAAIC,EAAInC,IAAIpB,EAAO5V,KAAK2W,MAGpD3Q,KAAK8S,GAAalc,MAAMoJ,KAAMjJ,GAEvB6Y,GA0BT,IAAMyD,EAAa,SAAW/X,EAAK,GAAGyX,cAAgBzX,EAAK0C,MAAM,GAEjE0G,EAAMzN,UAAUoc,GAAc,WACxBtc,IAiBAiP,EACAkK,EAlBAnZ,EAAOwG,MAAMtG,UAAU+G,MAAM9G,KAAK4C,WAElC/C,GAAAA,EAAKgD,OAAS,GAAKhD,EAAKgD,OAAS,EAC7B,MAAA,IAAIiI,EACCqR,SAAAA,OAAAA,wEAAwEtc,EAAKgD,OADxF,OAMA,GAAiC,mBAA1BhD,EAAKA,EAAKgD,OAAS,IACO,mBAA1BhD,EAAKA,EAAKgD,OAAS,GAE1B,MAAM,IAAIiI,EACCqR,SAAAA,OAAAA,EADX,qMAQkB,IAAhBtc,EAAKgD,QACPiM,EAAWjP,EAAK,GAChBmZ,EAAenZ,EAAK,GACpBA,EAAO,IACkB,IAAhBA,EAAKgD,QACdiM,EAAWjP,EAAK,GAChBmZ,EAAenZ,EAAK,GACpBA,EAAO,CAACA,EAAK,KACY,IAAhBA,EAAKgD,SACdiM,EAAWjP,EAAK,GAChBmZ,EAAenZ,EAAK,GACpBA,EAAO,CAACA,EAAK,GAAIA,EAAK,KAGpBoZ,IAAAA,EAAcD,EAQlB,OANAnZ,EAAKiD,MAAK,SAAC2W,EAAGsC,EAAIrC,EAAGC,EAAGqC,EAAIC,EAAInC,GAC9Bb,EAAcnK,EAASmK,EAAaQ,EAAGsC,EAAIrC,EAAGC,EAAGqC,EAAIC,EAAInC,MAG3DhR,KAAK8S,GAAalc,MAAMoJ,KAAMjJ,GAEvBoZ,GAmQPmD,CAAkBjI,EAAOzC,GAxP7B,SAAwBlE,EAAOkE,GAC7B,IAAOtN,EAAyBsN,EAAzBtN,KAAM1B,EAAmBgP,EAAnBhP,KAAMgM,EAAagD,EAAbhD,UAEb2N,EAAe,OAASjY,EAAK,GAAGyX,cAAgBzX,EAAK0C,MAAM,GAAI,GAsBrE0G,EAAMzN,UAAUsc,GAAgB,SAAU3U,EAAQ/H,EAAQmP,GAExD,GAAa,UAATpM,GAAkC,UAAdoG,KAAKpG,MAAoBA,IAASoG,KAAKpG,KAC7D,OAAO,EAET,GAAyB,IAArBE,UAAUC,OAELmN,OAAAA,IAAY,EAAMlH,KAAMpG,EAD/BoM,EAAWpH,GAIb,GAAyB,IAArB9E,UAAUC,OAAc,CAC1B6E,EAAS,GAAKA,EACdoH,EAAWnP,EAELqN,IAAAA,EAAWlE,KAAKlB,OAAO9F,IAAI4F,GAEjC,QAAwB,IAAbsF,EACT,MAAM,IAAI9B,EAAJ,SAAA5K,OACK+b,EADL,0BAAA/b,OAC0CoH,EAD1C,yBAMD0I,OAAAA,IACL,EACAtH,KAAKuF,MACI,UAAT3L,EAAmBoG,KAAKpG,KAAOA,EAC/BgM,EACA1B,EACA8B,GAIJ,GAAyB,IAArBlM,UAAUC,OAAc,CAC1B6E,EAAS,GAAKA,EACd/H,EAAS,GAAKA,EAERgI,IAAAA,EAAamB,KAAKlB,OAAO9F,IAAI4F,GAE/B,IAACC,EACH,MAAM,IAAIuD,EACCmR,SAAAA,OAAAA,EAAsC3U,2BAAAA,OAAAA,EADjD,gCAIF,IAAKoB,KAAKlB,OAAOwJ,IAAIzR,GACnB,MAAM,IAAIuL,EACCmR,SAAAA,OAAAA,oCAAsC1c,EAD3C,gCAKR,OAAO+Q,IACL,EACAhO,EACAoG,KAAKuF,MACLK,EACA/G,EACAhI,EACAmP,GAIE,MAAA,IAAIhE,EACCuR,SAAAA,OAAAA,+DAAiEzZ,UAAUC,OADtF,QAyBF,IAAMyZ,EAAW,OAASlY,EAAK,GAAGyX,cAAgBzX,EAAK0C,MAAM,GAAI,GAEjE0G,EAAMzN,UAAUuc,GAAY,WACpBzc,IAAAA,EAAOwG,MAAMtG,UAAU+G,MAAM9G,KAAK4C,WAClCkM,EAAWjP,EAAK0G,MAQlB8J,OANJxQ,EAAKiD,MAAK,SAAC2W,EAAGsC,EAAIrC,EAAGC,EAAGqC,EAAIC,EAAInC,GAC9B,OAAOhL,EAAS2K,EAAGsC,EAAIrC,EAAGC,EAAGqC,EAAIC,EAAInC,QAGzBhR,KAAKuT,GAAc3c,MAAMoJ,KAAMjJ,IA2B/C,IAAM0c,EAAY,QAAUnY,EAAK,GAAGyX,cAAgBzX,EAAK0C,MAAM,GAAI,GAEnE0G,EAAMzN,UAAUwc,GAAa,WACrB1c,IAAAA,EAAOwG,MAAMtG,UAAU+G,MAAM9G,KAAK4C,WAClCkM,EAAWjP,EAAK0G,MAQlB8J,OANJxQ,EAAKiD,MAAK,SAAC2W,EAAGsC,EAAIrC,EAAGC,EAAGqC,EAAIC,EAAInC,GAC9B,OAAQhL,EAAS2K,EAAGsC,EAAIrC,EAAGC,EAAGqC,EAAIC,EAAInC,OAG1BhR,KAAKuT,GAAc3c,MAAMoJ,KAAMjJ,IA2F7C2c,CAAerI,EAAOzC,GA7E1B,SAAmClE,EAAOkE,GACxC,IAAa+K,EAAiC/K,EAAvCtN,KAAoB1B,EAAmBgP,EAAnBhP,KAAMgM,EAAagD,EAAbhD,UAE3BtK,EAAOqY,EAAa3V,MAAM,GAAI,GAAK,UAkBzC0G,EAAMzN,UAAUqE,GAAQ,SAAUsD,EAAQ/H,GAExC,GAAa,UAAT+C,GAAkC,UAAdoG,KAAKpG,MAAoBA,IAASoG,KAAKpG,KAC7D,OAAOsG,EAASO,QAEd,IAAC3G,UAAUC,OAAQ,OAAOsN,GAAmBrH,KAAMpG,GAEvD,GAAyB,IAArBE,UAAUC,OAAc,CAC1B6E,EAAS,GAAKA,EAERC,IAAAA,EAAamB,KAAKlB,OAAO9F,IAAI4F,GAEnC,IAAKC,EACH,MAAM,IAAIuD,EACC9G,SAAAA,OAAAA,EAA6BsD,0BAAAA,OAAAA,EADxC,yBAKF,OAAO+I,GAA0B/N,EAAMgM,EAAW/G,GAGpD,GAAyB,IAArB/E,UAAUC,OAAc,CAC1B6E,EAAS,GAAKA,EACd/H,EAAS,GAAKA,EAERgI,IAAAA,EAAamB,KAAKlB,OAAO9F,IAAI4F,GAE/B,IAACC,EACH,MAAM,IAAIuD,EACC9G,SAAAA,OAAAA,EAA8BsD,2BAAAA,OAAAA,EADzC,gCAIF,IAAKoB,KAAKlB,OAAOwJ,IAAIzR,GACnB,MAAM,IAAIuL,EACC9G,SAAAA,OAAAA,oCAA8BzE,EADnC,gCAKDiR,OAAAA,GAA0BlO,EAAMgM,EAAW/G,EAAYhI,GAG1D,MAAA,IAAImL,EACC1G,SAAAA,OAAAA,+DAAyDxB,UAAUC,OAD9E,QAgBA6Z,CAA0BvI,EAAOzC,MI8wDrCiL,CAA2BxI,IHj5EZ,SAAwCA,GACrDtD,GAAoB8D,SAAQ,SAAAjD,GAC1BD,GAA2B0C,EAAOzC,GAlPtC,SAA+BlE,EAAOkE,GACpC,IAAOtN,EAAyBsN,EAAzBtN,KAAM1B,EAAmBgP,EAAnBhP,KAAMgM,EAAagD,EAAbhD,UAEbkN,EAAc,UAAYxX,EAAK,GAAGyX,cAAgBzX,EAAK0C,MAAM,GAAI,GAWvE0G,EAAMzN,UAAU6b,GAAe,SAAUjK,EAAM7C,GAE7C,GAAa,UAATpM,GAAkC,UAAdoG,KAAKpG,MAAoBA,IAASoG,KAAKpG,KAA/D,CAEAiP,EAAO,GAAKA,EAEN3E,IAAAA,EAAWlE,KAAKlB,OAAO9F,IAAI6P,GAEjC,QAAwB,IAAb3E,EACT,MAAM,IAAI9B,EAAJ,SAAA5K,OACKsb,EADL,0BAAAtb,OACyCqR,EADzC,yBAKRN,IACE,EACS,UAAT3O,EAAmBoG,KAAKpG,KAAOA,EAC/BgM,EACA1B,EACA8B,KAYJ,IAAMgN,EAAU,MAAQ1X,EAAK,GAAGyX,cAAgBzX,EAAK0C,MAAM,GAE3D0G,EAAMzN,UAAU+b,GAAW,SAAUnK,EAAM7C,GAEnC4J,IAAAA,EAAS,GAMf,OAJKkD,KAAAA,GAAajK,GAAM,SAACtP,EAAGmX,GAC1Bd,EAAO5V,KAAKgM,EAASzM,EAAGmX,OAGnBd,GAWT,IAAMwD,EAAa,SAAW9X,EAAK,GAAGyX,cAAgBzX,EAAK0C,MAAM,GAEjE0G,EAAMzN,UAAUmc,GAAc,SAAUvK,EAAM7C,GACtC4J,IAAAA,EAAS,GAMf,OAJKkD,KAAAA,GAAajK,GAAM,SAACtP,EAAGmX,GACtB1K,EAASzM,EAAGmX,IAAId,EAAO5V,KAAKT,MAG3BqW,GAWT,IAAMyD,EAAa,SAAW/X,EAAK,GAAGyX,cAAgBzX,EAAK0C,MAAM,GAEjE0G,EAAMzN,UAAUoc,GAAc,SAAUxK,EAAM7C,EAAUkK,GAClDpW,GAAAA,UAAUC,OAAS,EACrB,MAAM,IAAIiI,EACCqR,SAAAA,OAAAA,EADX,qMAIElD,IAAAA,EAAcD,EAMlB,OAJK4C,KAAAA,GAAajK,GAAM,SAACtP,EAAGmX,GAC1BP,EAAcnK,EAASmK,EAAa5W,EAAGmX,MAGlCP,GA+IP2D,CAAsBzI,EAAOzC,GApIjC,SAA4BlE,EAAOkE,GACjC,IAAOtN,EAAyBsN,EAAzBtN,KAAM1B,EAAmBgP,EAAnBhP,KAAMgM,EAAagD,EAAbhD,UAEbmO,EAAsBzY,EAAK,GAAGyX,cAAgBzX,EAAK0C,MAAM,GAAI,GAE7DgW,EAAW,OAASD,EAW1BrP,EAAMzN,UAAU+c,GAAY,SAAUnL,EAAM7C,GAE1C,GAAa,UAATpM,GAAkC,UAAdoG,KAAKpG,MAAoBA,IAASoG,KAAKpG,KAA/D,CAEAiP,EAAO,GAAKA,EAEN3E,IAAAA,EAAWlE,KAAKlB,OAAO9F,IAAI6P,GAEjC,QAAwB,IAAb3E,EACT,MAAM,IAAI9B,EAAJ,SAAA5K,OACKwc,EADL,0BAAAxc,OACsCqR,EADtC,yBAKR,OAAON,IACL,EACS,UAAT3O,EAAmBoG,KAAKpG,KAAOA,EAC/BgM,EACA1B,EACA8B,KAcEwN,IAAAA,EAAW,OAASO,EAE1BrP,EAAMzN,UAAUuc,GAAY,SAAU3K,EAAM7C,GAGtCuB,QAFUvH,KAAKgU,GAAUnL,EAAM7C,IAiB/ByN,IAAAA,EAAY,QAAUM,EAE5BrP,EAAMzN,UAAUwc,GAAa,SAAU5K,EAAM7C,GAKvCuB,OAJUvH,KAAKgU,GAAUnL,GAAM,SAACtP,EAAGmX,GACrC,OAAQ1K,EAASzM,EAAGmX,OA4DtBuD,CAAmB5I,EAAOzC,GAC1BI,GAA8BqC,EAAOzC,MGi5EzCsL,CAA+B7I,QCv7FzB8I,eACJ,SAAAA,EAAY7I,GACJ8I,IAAAA,EAAe7V,EAAO,CAAC3E,KAAM,YAAa0R,GAEhD,GAAI,UAAW8I,IAAuC,IAAvBA,EAAa7O,MAC1C,MAAM,IAAIvD,EACR,gGAGJ,GAA0B,aAAtBoS,EAAaxa,KACf,MAAM,IAAIoI,EACR,qCACEoS,EAAaxa,KACb,4BAGN,OAAAya,EAAAnd,KAAA8I,KAAMoU,IAfapU,sBADKqL,IAmBtBiJ,eACJ,SAAAA,EAAYhJ,GACJ8I,IAAAA,EAAe7V,EAAO,CAAC3E,KAAM,cAAe0R,GAElD,GAAI,UAAW8I,IAAuC,IAAvBA,EAAa7O,MAC1C,MAAM,IAAIvD,EACR,kGAGJ,GAA0B,eAAtBoS,EAAaxa,KACf,MAAM,IAAIoI,EACR,uCACEoS,EAAaxa,KACb,4BAGN,OAAA2a,EAAArd,KAAA8I,KAAMoU,IAfapU,sBADOqL,IAmBxBmJ,eACJ,SAAAA,EAAYlJ,GACJ8I,IAAAA,EAAe7V,EAAO,CAACgH,OAAO,GAAO+F,GAE3C,GAAI,UAAW8I,IAAuC,IAAvBA,EAAa7O,MAC1C,MAAM,IAAIvD,EACR,8FAGJ,OAAAyS,EAAAvd,KAAA8I,KAAMoU,IARapU,sBADEqL,IAYnBqJ,eACJ,SAAAA,EAAYpJ,GACJ8I,IAAAA,EAAe7V,EAAO,CAAC3E,KAAM,WAAY2L,OAAO,GAAO+F,GAE7D,GAAI,UAAW8I,IAAuC,IAAvBA,EAAa7O,MAC1C,MAAM,IAAIvD,EACR,sGAGJ,GAA0B,aAAtBoS,EAAaxa,KACf,MAAM,IAAIoI,EACR,0CACEoS,EAAaxa,KACb,4BAGN,OAAA+a,EAAAzd,KAAA8I,KAAMoU,IAfapU,sBADUqL,IAmB3BuJ,eACJ,SAAAA,EAAYtJ,GACJ8I,IAAAA,EAAe7V,EAAO,CAAC3E,KAAM,aAAc2L,OAAO,GAAO+F,GAE/D,GAAI,UAAW8I,IAAuC,IAAvBA,EAAa7O,MAC1C,MAAM,IAAIvD,EACR,wGAGJ,GAA0B,eAAtBoS,EAAaxa,KACf,MAAM,IAAIoI,EACR,4CACEoS,EAAaxa,KACb,4BAGN,OAAAib,EAAA3d,KAAA8I,KAAMoU,IAfapU,sBADYqL,IAuBnC,SAASyJ,GAAuBpQ,GAQ9BA,EAAMmC,KAAO,SAAUjC,EAAM0G,GAErB8I,IAAAA,EAAe7V,EAAO,GAAIqG,EAAK0G,QAASA,GAExCyJ,EAAW,IAAIrQ,EAAM0P,GAG3B,OAFAW,EAAA,OAAgBnQ,GAETmQ,UAIXD,GAAuBzJ,IACvByJ,GAAuBX,IACvBW,GAAuBR,IACvBQ,GAAuBN,IACvBM,GAAuBJ,IACvBI,GAAuBF,IAEvBvJ,GAAMA,MAAQA,GACdA,GAAM8I,cAAgBA,GACtB9I,GAAMiJ,gBAAkBA,GACxBjJ,GAAMmJ,WAAaA,GACnBnJ,GAAMqJ,mBAAqBA,GAC3BrJ,GAAMuJ,qBAAuBA,GAE7BvJ,GAAMrJ,2BAA6BA,EACnCqJ,GAAMjJ,mBAAqBA,EAC3BiJ,GAAM9I,gBAAkBA;;;;AClJxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9zBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA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","file":"graphTest.77de5100.js","sourceRoot":"..","sourcesContent":["/**\n * Graphology isGraph\n * ===================\n *\n * Very simple function aiming at ensuring the given variable is a\n * graphology instance.\n */\n\n/**\n * Checking the value is a graphology instance.\n *\n * @param  {any}     value - Target value.\n * @return {boolean}\n */\nmodule.exports = function isGraph(value) {\n  return (\n    value !== null &&\n    typeof value === 'object' &&\n    typeof value.addUndirectedEdgeWithKey === 'function' &&\n    typeof value.dropNode === 'function' &&\n    typeof value.multi === 'boolean'\n  );\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.multiplyVec2 = exports.multiply = exports.translate = exports.rotate = exports.scale = exports.identity = void 0;\nfunction identity() {\n    return Float32Array.of(1, 0, 0, 0, 1, 0, 0, 0, 1);\n}\nexports.identity = identity;\n// TODO: optimize\nfunction scale(m, x, y) {\n    m[0] = x;\n    m[4] = typeof y === \"number\" ? y : x;\n    return m;\n}\nexports.scale = scale;\nfunction rotate(m, r) {\n    var s = Math.sin(r), c = Math.cos(r);\n    m[0] = c;\n    m[1] = s;\n    m[3] = -s;\n    m[4] = c;\n    return m;\n}\nexports.rotate = rotate;\nfunction translate(m, x, y) {\n    m[6] = x;\n    m[7] = y;\n    return m;\n}\nexports.translate = translate;\nfunction multiply(a, b) {\n    var a00 = a[0], a01 = a[1], a02 = a[2];\n    var a10 = a[3], a11 = a[4], a12 = a[5];\n    var a20 = a[6], a21 = a[7], a22 = a[8];\n    var b00 = b[0], b01 = b[1], b02 = b[2];\n    var b10 = b[3], b11 = b[4], b12 = b[5];\n    var b20 = b[6], b21 = b[7], b22 = b[8];\n    a[0] = b00 * a00 + b01 * a10 + b02 * a20;\n    a[1] = b00 * a01 + b01 * a11 + b02 * a21;\n    a[2] = b00 * a02 + b01 * a12 + b02 * a22;\n    a[3] = b10 * a00 + b11 * a10 + b12 * a20;\n    a[4] = b10 * a01 + b11 * a11 + b12 * a21;\n    a[5] = b10 * a02 + b11 * a12 + b12 * a22;\n    a[6] = b20 * a00 + b21 * a10 + b22 * a20;\n    a[7] = b20 * a01 + b21 * a11 + b22 * a21;\n    a[8] = b20 * a02 + b21 * a12 + b22 * a22;\n    return a;\n}\nexports.multiply = multiply;\nfunction multiplyVec2(a, b, z) {\n    if (z === void 0) { z = 1; }\n    var a00 = a[0];\n    var a01 = a[1];\n    var a10 = a[3];\n    var a11 = a[4];\n    var a20 = a[6];\n    var a21 = a[7];\n    var b0 = b.x;\n    var b1 = b.y;\n    return { x: b0 * a00 + b1 * a10 + a20 * z, y: b0 * a01 + b1 * a11 + a21 * z };\n}\nexports.multiplyVec2 = multiplyVec2;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HTML_COLORS = void 0;\nexports.HTML_COLORS = {\n    black: \"#000000\",\n    silver: \"#C0C0C0\",\n    gray: \"#808080\",\n    grey: \"#808080\",\n    white: \"#FFFFFF\",\n    maroon: \"#800000\",\n    red: \"#FF0000\",\n    purple: \"#800080\",\n    fuchsia: \"#FF00FF\",\n    green: \"#008000\",\n    lime: \"#00FF00\",\n    olive: \"#808000\",\n    yellow: \"#FFFF00\",\n    navy: \"#000080\",\n    blue: \"#0000FF\",\n    teal: \"#008080\",\n    aqua: \"#00FFFF\",\n    darkblue: \"#00008B\",\n    mediumblue: \"#0000CD\",\n    darkgreen: \"#006400\",\n    darkcyan: \"#008B8B\",\n    deepskyblue: \"#00BFFF\",\n    darkturquoise: \"#00CED1\",\n    mediumspringgreen: \"#00FA9A\",\n    springgreen: \"#00FF7F\",\n    cyan: \"#00FFFF\",\n    midnightblue: \"#191970\",\n    dodgerblue: \"#1E90FF\",\n    lightseagreen: \"#20B2AA\",\n    forestgreen: \"#228B22\",\n    seagreen: \"#2E8B57\",\n    darkslategray: \"#2F4F4F\",\n    darkslategrey: \"#2F4F4F\",\n    limegreen: \"#32CD32\",\n    mediumseagreen: \"#3CB371\",\n    turquoise: \"#40E0D0\",\n    royalblue: \"#4169E1\",\n    steelblue: \"#4682B4\",\n    darkslateblue: \"#483D8B\",\n    mediumturquoise: \"#48D1CC\",\n    indigo: \"#4B0082\",\n    darkolivegreen: \"#556B2F\",\n    cadetblue: \"#5F9EA0\",\n    cornflowerblue: \"#6495ED\",\n    rebeccapurple: \"#663399\",\n    mediumaquamarine: \"#66CDAA\",\n    dimgray: \"#696969\",\n    dimgrey: \"#696969\",\n    slateblue: \"#6A5ACD\",\n    olivedrab: \"#6B8E23\",\n    slategray: \"#708090\",\n    slategrey: \"#708090\",\n    lightslategray: \"#778899\",\n    lightslategrey: \"#778899\",\n    mediumslateblue: \"#7B68EE\",\n    lawngreen: \"#7CFC00\",\n    chartreuse: \"#7FFF00\",\n    aquamarine: \"#7FFFD4\",\n    skyblue: \"#87CEEB\",\n    lightskyblue: \"#87CEFA\",\n    blueviolet: \"#8A2BE2\",\n    darkred: \"#8B0000\",\n    darkmagenta: \"#8B008B\",\n    saddlebrown: \"#8B4513\",\n    darkseagreen: \"#8FBC8F\",\n    lightgreen: \"#90EE90\",\n    mediumpurple: \"#9370DB\",\n    darkviolet: \"#9400D3\",\n    palegreen: \"#98FB98\",\n    darkorchid: \"#9932CC\",\n    yellowgreen: \"#9ACD32\",\n    sienna: \"#A0522D\",\n    brown: \"#A52A2A\",\n    darkgray: \"#A9A9A9\",\n    darkgrey: \"#A9A9A9\",\n    lightblue: \"#ADD8E6\",\n    greenyellow: \"#ADFF2F\",\n    paleturquoise: \"#AFEEEE\",\n    lightsteelblue: \"#B0C4DE\",\n    powderblue: \"#B0E0E6\",\n    firebrick: \"#B22222\",\n    darkgoldenrod: \"#B8860B\",\n    mediumorchid: \"#BA55D3\",\n    rosybrown: \"#BC8F8F\",\n    darkkhaki: \"#BDB76B\",\n    mediumvioletred: \"#C71585\",\n    indianred: \"#CD5C5C\",\n    peru: \"#CD853F\",\n    chocolate: \"#D2691E\",\n    tan: \"#D2B48C\",\n    lightgray: \"#D3D3D3\",\n    lightgrey: \"#D3D3D3\",\n    thistle: \"#D8BFD8\",\n    orchid: \"#DA70D6\",\n    goldenrod: \"#DAA520\",\n    palevioletred: \"#DB7093\",\n    crimson: \"#DC143C\",\n    gainsboro: \"#DCDCDC\",\n    plum: \"#DDA0DD\",\n    burlywood: \"#DEB887\",\n    lightcyan: \"#E0FFFF\",\n    lavender: \"#E6E6FA\",\n    darksalmon: \"#E9967A\",\n    violet: \"#EE82EE\",\n    palegoldenrod: \"#EEE8AA\",\n    lightcoral: \"#F08080\",\n    khaki: \"#F0E68C\",\n    aliceblue: \"#F0F8FF\",\n    honeydew: \"#F0FFF0\",\n    azure: \"#F0FFFF\",\n    sandybrown: \"#F4A460\",\n    wheat: \"#F5DEB3\",\n    beige: \"#F5F5DC\",\n    whitesmoke: \"#F5F5F5\",\n    mintcream: \"#F5FFFA\",\n    ghostwhite: \"#F8F8FF\",\n    salmon: \"#FA8072\",\n    antiquewhite: \"#FAEBD7\",\n    linen: \"#FAF0E6\",\n    lightgoldenrodyellow: \"#FAFAD2\",\n    oldlace: \"#FDF5E6\",\n    magenta: \"#FF00FF\",\n    deeppink: \"#FF1493\",\n    orangered: \"#FF4500\",\n    tomato: \"#FF6347\",\n    hotpink: \"#FF69B4\",\n    coral: \"#FF7F50\",\n    darkorange: \"#FF8C00\",\n    lightsalmon: \"#FFA07A\",\n    orange: \"#FFA500\",\n    lightpink: \"#FFB6C1\",\n    pink: \"#FFC0CB\",\n    gold: \"#FFD700\",\n    peachpuff: \"#FFDAB9\",\n    navajowhite: \"#FFDEAD\",\n    moccasin: \"#FFE4B5\",\n    bisque: \"#FFE4C4\",\n    mistyrose: \"#FFE4E1\",\n    blanchedalmond: \"#FFEBCD\",\n    papayawhip: \"#FFEFD5\",\n    lavenderblush: \"#FFF0F5\",\n    seashell: \"#FFF5EE\",\n    cornsilk: \"#FFF8DC\",\n    lemonchiffon: \"#FFFACD\",\n    floralwhite: \"#FFFAF0\",\n    snow: \"#FFFAFA\",\n    lightyellow: \"#FFFFE0\",\n    ivory: \"#FFFFF0\",\n};\n","\"use strict\";\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateGraph = exports.canUse32BitsIndices = exports.extractPixel = exports.getMatrixImpact = exports.matrixFromCamera = exports.getCorrectionRatio = exports.floatColor = exports.floatArrayColor = exports.parseColor = exports.zIndexOrdering = exports.createNormalizationFunction = exports.graphExtent = exports.getPixelRatio = exports.createElement = exports.cancelFrame = exports.requestFrame = exports.assignDeep = exports.assign = exports.isPlainObject = void 0;\nvar is_graph_1 = __importDefault(require(\"graphology-utils/is-graph\"));\nvar matrices_1 = require(\"./matrices\");\nvar data_1 = require(\"./data\");\n/**\n * Checks whether the given value is a plain object.\n *\n * @param  {mixed}   value - Target value.\n * @return {boolean}\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\nfunction isPlainObject(value) {\n    return typeof value === \"object\" && value !== null && value.constructor === Object;\n}\nexports.isPlainObject = isPlainObject;\n/**\n * Helper to use Object.assign with more than two objects.\n *\n * @param  {object} target       - First object.\n * @param  {object} [...objects] - Objects to merge.\n * @return {object}\n */\nfunction assign(target) {\n    var objects = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        objects[_i - 1] = arguments[_i];\n    }\n    target = target || {};\n    for (var i = 0, l = objects.length; i < l; i++) {\n        var o = objects[i];\n        if (!o)\n            continue;\n        Object.assign(target, o);\n    }\n    return target;\n}\nexports.assign = assign;\n/**\n * Very simple recursive Object.assign-like function.\n *\n * @param  {object} target       - First object.\n * @param  {object} [...objects] - Objects to merge.\n * @return {object}\n */\nfunction assignDeep(target) {\n    var objects = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        objects[_i - 1] = arguments[_i];\n    }\n    target = target || {};\n    for (var i = 0, l = objects.length; i < l; i++) {\n        var o = objects[i];\n        if (!o)\n            continue;\n        for (var k in o) {\n            if (isPlainObject(o[k])) {\n                target[k] = assignDeep(target[k], o[k]);\n            }\n            else {\n                target[k] = o[k];\n            }\n        }\n    }\n    return target;\n}\nexports.assignDeep = assignDeep;\n/**\n * Just some dirty trick to make requestAnimationFrame and cancelAnimationFrame \"work\" in Node.js, for unit tests:\n */\nexports.requestFrame = typeof requestAnimationFrame !== \"undefined\"\n    ? function (callback) { return requestAnimationFrame(callback); }\n    : function (callback) { return setTimeout(callback, 0); };\nexports.cancelFrame = typeof cancelAnimationFrame !== \"undefined\"\n    ? function (requestID) { return cancelAnimationFrame(requestID); }\n    : function (requestID) { return clearTimeout(requestID); };\n/**\n * Function used to create DOM elements easily.\n *\n * @param  {string} tag        - Tag name of the element to create.\n * @param  {object} style      - Styles map.\n * @param  {object} attributes - Attributes map.\n * @return {HTMLElement}\n */\nfunction createElement(tag, style, attributes) {\n    var element = document.createElement(tag);\n    if (style) {\n        for (var k in style) {\n            element.style[k] = style[k];\n        }\n    }\n    if (attributes) {\n        for (var k in attributes) {\n            element.setAttribute(k, attributes[k]);\n        }\n    }\n    return element;\n}\nexports.createElement = createElement;\n/**\n * Function returning the browser's pixel ratio.\n *\n * @return {number}\n */\nfunction getPixelRatio() {\n    if (typeof window.devicePixelRatio !== \"undefined\")\n        return window.devicePixelRatio;\n    return 1;\n}\nexports.getPixelRatio = getPixelRatio;\n/**\n * Function returning the graph's node extent in x & y.\n *\n * @param  {Graph}\n * @return {object}\n */\nfunction graphExtent(graph) {\n    if (!graph.order)\n        return { x: [0, 1], y: [0, 1] };\n    var xMin = Infinity;\n    var xMax = -Infinity;\n    var yMin = Infinity;\n    var yMax = -Infinity;\n    graph.forEachNode(function (_, attr) {\n        var x = attr.x, y = attr.y;\n        if (x < xMin)\n            xMin = x;\n        if (x > xMax)\n            xMax = x;\n        if (y < yMin)\n            yMin = y;\n        if (y > yMax)\n            yMax = y;\n    });\n    return { x: [xMin, xMax], y: [yMin, yMax] };\n}\nexports.graphExtent = graphExtent;\nfunction createNormalizationFunction(extent) {\n    var _a = __read(extent.x, 2), minX = _a[0], maxX = _a[1], _b = __read(extent.y, 2), minY = _b[0], maxY = _b[1];\n    var ratio = Math.max(maxX - minX, maxY - minY), dX = (maxX + minX) / 2, dY = (maxY + minY) / 2;\n    if (ratio === 0 || Math.abs(ratio) === Infinity || isNaN(ratio))\n        ratio = 1;\n    if (isNaN(dX))\n        dX = 0;\n    if (isNaN(dY))\n        dY = 0;\n    var fn = function (data) {\n        return {\n            x: 0.5 + (data.x - dX) / ratio,\n            y: 0.5 + (data.y - dY) / ratio,\n        };\n    };\n    // TODO: possibility to apply this in batch over array of indices\n    fn.applyTo = function (data) {\n        data.x = 0.5 + (data.x - dX) / ratio;\n        data.y = 0.5 + (data.y - dY) / ratio;\n    };\n    fn.inverse = function (data) {\n        return {\n            x: dX + ratio * (data.x - 0.5),\n            y: dY + ratio * (data.y - 0.5),\n        };\n    };\n    fn.ratio = ratio;\n    return fn;\n}\nexports.createNormalizationFunction = createNormalizationFunction;\n/**\n * Function ordering the given elements in reverse z-order so they drawn\n * the correct way.\n *\n * @param  {number}   extent   - [min, max] z values.\n * @param  {function} getter   - Z attribute getter function.\n * @param  {array}    elements - The array to sort.\n * @return {array} - The sorted array.\n */\nfunction zIndexOrdering(extent, getter, elements) {\n    // If k is > n, we'll use a standard sort\n    return elements.sort(function (a, b) {\n        var zA = getter(a) || 0, zB = getter(b) || 0;\n        if (zA < zB)\n            return -1;\n        if (zA > zB)\n            return 1;\n        return 0;\n    });\n    // TODO: counting sort optimization\n}\nexports.zIndexOrdering = zIndexOrdering;\n/**\n * WebGL utils\n * ===========\n */\n/**\n * Memoized function returning a float-encoded color from various string\n * formats describing colors.\n */\nvar INT8 = new Int8Array(4);\nvar INT32 = new Int32Array(INT8.buffer, 0, 1);\nvar FLOAT32 = new Float32Array(INT8.buffer, 0, 1);\nvar RGBA_TEST_REGEX = /^\\s*rgba?\\s*\\(/;\nvar RGBA_EXTRACT_REGEX = /^\\s*rgba?\\s*\\(\\s*([0-9]*)\\s*,\\s*([0-9]*)\\s*,\\s*([0-9]*)(?:\\s*,\\s*(.*)?)?\\)\\s*$/;\nfunction parseColor(val) {\n    var r = 0; // byte\n    var g = 0; // byte\n    var b = 0; // byte\n    var a = 1; // float\n    // Handling hexadecimal notation\n    if (val[0] === \"#\") {\n        if (val.length === 4) {\n            r = parseInt(val.charAt(1) + val.charAt(1), 16);\n            g = parseInt(val.charAt(2) + val.charAt(2), 16);\n            b = parseInt(val.charAt(3) + val.charAt(3), 16);\n        }\n        else {\n            r = parseInt(val.charAt(1) + val.charAt(2), 16);\n            g = parseInt(val.charAt(3) + val.charAt(4), 16);\n            b = parseInt(val.charAt(5) + val.charAt(6), 16);\n        }\n        // TODO: parse hex with alpha?\n    }\n    // Handling rgb notation\n    else if (RGBA_TEST_REGEX.test(val)) {\n        var match = val.match(RGBA_EXTRACT_REGEX);\n        if (match) {\n            r = +match[1];\n            g = +match[2];\n            b = +match[3];\n            if (match[4])\n                a = +match[4];\n        }\n    }\n    return { r: r, g: g, b: b, a: a };\n}\nexports.parseColor = parseColor;\nvar FLOAT_COLOR_CACHE = {};\nfor (var htmlColor in data_1.HTML_COLORS) {\n    FLOAT_COLOR_CACHE[htmlColor] = floatColor(data_1.HTML_COLORS[htmlColor]);\n    // Replicating cache for hex values for free\n    FLOAT_COLOR_CACHE[data_1.HTML_COLORS[htmlColor]] = FLOAT_COLOR_CACHE[htmlColor];\n}\nfunction floatArrayColor(val) {\n    val = data_1.HTML_COLORS[val] || val;\n    // NOTE: this variant is not cached because it is mostly used for uniforms\n    var _a = parseColor(val), r = _a.r, g = _a.g, b = _a.b, a = _a.a;\n    return new Float32Array([r / 255, g / 255, b / 255, a]);\n}\nexports.floatArrayColor = floatArrayColor;\nfunction floatColor(val) {\n    // If the color is already computed, we yield it\n    if (typeof FLOAT_COLOR_CACHE[val] !== \"undefined\")\n        return FLOAT_COLOR_CACHE[val];\n    var parsed = parseColor(val);\n    var r = parsed.r, g = parsed.g, b = parsed.b;\n    var a = parsed.a;\n    a = (a * 255) | 0;\n    INT32[0] = ((a << 24) | (b << 16) | (g << 8) | r) & 0xfeffffff;\n    var color = FLOAT32[0];\n    FLOAT_COLOR_CACHE[val] = color;\n    return color;\n}\nexports.floatColor = floatColor;\n/**\n * In sigma, the graph is normalized into a [0, 1], [0, 1] square, before being given to the various renderers. This\n * helps dealing with quadtree in particular.\n * But at some point, we need to rescale it so that it takes the best place in the screen, ie. we always want to see two\n * nodes \"touching\" opposite sides of the graph, with the camera being at its default state.\n *\n * This function determines this ratio.\n */\nfunction getCorrectionRatio(viewportDimensions, graphDimensions) {\n    var viewportRatio = viewportDimensions.height / viewportDimensions.width;\n    var graphRatio = graphDimensions.height / graphDimensions.width;\n    // If the stage and the graphs are in different directions (such as the graph being wider that tall while the stage\n    // is taller than wide), we can stop here to have indeed nodes touching opposite sides:\n    if ((viewportRatio < 1 && graphRatio > 1) || (viewportRatio > 1 && graphRatio < 1)) {\n        return 1;\n    }\n    // Else, we need to fit the graph inside the stage:\n    // 1. If the graph is \"squarer\" (ie. with a ratio closer to 1), we need to make the largest sides touch;\n    // 2. If the stage is \"squarer\", we need to make the smallest sides touch.\n    return Math.min(Math.max(graphRatio, 1 / graphRatio), Math.max(1 / viewportRatio, viewportRatio));\n}\nexports.getCorrectionRatio = getCorrectionRatio;\n/**\n * Function returning a matrix from the current state of the camera.\n */\n// TODO: it's possible to optimize this drastically!\nfunction matrixFromCamera(state, viewportDimensions, graphDimensions, padding, inverse) {\n    var angle = state.angle, ratio = state.ratio, x = state.x, y = state.y;\n    var width = viewportDimensions.width, height = viewportDimensions.height;\n    var matrix = (0, matrices_1.identity)();\n    var smallestDimension = Math.min(width, height) - 2 * padding;\n    var correctionRatio = getCorrectionRatio(viewportDimensions, graphDimensions);\n    if (!inverse) {\n        (0, matrices_1.multiply)(matrix, (0, matrices_1.scale)((0, matrices_1.identity)(), 2 * (smallestDimension / width) * correctionRatio, 2 * (smallestDimension / height) * correctionRatio));\n        (0, matrices_1.multiply)(matrix, (0, matrices_1.rotate)((0, matrices_1.identity)(), -angle));\n        (0, matrices_1.multiply)(matrix, (0, matrices_1.scale)((0, matrices_1.identity)(), 1 / ratio));\n        (0, matrices_1.multiply)(matrix, (0, matrices_1.translate)((0, matrices_1.identity)(), -x, -y));\n    }\n    else {\n        (0, matrices_1.multiply)(matrix, (0, matrices_1.translate)((0, matrices_1.identity)(), x, y));\n        (0, matrices_1.multiply)(matrix, (0, matrices_1.scale)((0, matrices_1.identity)(), ratio));\n        (0, matrices_1.multiply)(matrix, (0, matrices_1.rotate)((0, matrices_1.identity)(), angle));\n        (0, matrices_1.multiply)(matrix, (0, matrices_1.scale)((0, matrices_1.identity)(), width / smallestDimension / 2 / correctionRatio, height / smallestDimension / 2 / correctionRatio));\n    }\n    return matrix;\n}\nexports.matrixFromCamera = matrixFromCamera;\n/**\n * All these transformations we apply on the matrix to get it rescale the graph\n * as we want make it very hard to get pixel-perfect distances in WebGL. This\n * function returns a factor that properly cancels the matrix effect on lengths.\n *\n * [jacomyal]\n * To be fully honest, I can't really explain happens here... I notice that the\n * following ratio works (ie. it correctly compensates the matrix impact on all\n * camera states I could try):\n * > `R = size(V) / size(M * V) / W`\n * as long as `M * V` is in the direction of W (ie. parallel to (Ox)). It works\n * as well with H and a vector that transforms into something parallel to (Oy).\n *\n * Also, note that we use `angle` and not `-angle` (that would seem logical,\n * since we want to anticipate the rotation), because of the fact that in WebGL,\n * the image is vertically swapped.\n */\nfunction getMatrixImpact(matrix, cameraState, viewportDimensions) {\n    var _a = (0, matrices_1.multiplyVec2)(matrix, { x: Math.cos(cameraState.angle), y: Math.sin(cameraState.angle) }, 0), x = _a.x, y = _a.y;\n    return 1 / Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)) / viewportDimensions.width;\n}\nexports.getMatrixImpact = getMatrixImpact;\n/**\n * Function extracting the color at the given pixel.\n */\nfunction extractPixel(gl, x, y, array) {\n    var data = array || new Uint8Array(4);\n    gl.readPixels(x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, data);\n    return data;\n}\nexports.extractPixel = extractPixel;\n/**\n * Function used to know whether given webgl context can use 32 bits indices.\n */\nfunction canUse32BitsIndices(gl) {\n    var webgl2 = typeof WebGL2RenderingContext !== \"undefined\" && gl instanceof WebGL2RenderingContext;\n    return webgl2 || !!gl.getExtension(\"OES_element_index_uint\");\n}\nexports.canUse32BitsIndices = canUse32BitsIndices;\n/**\n * Check if the graph variable is a valid graph, and if sigma can render it.\n */\nfunction validateGraph(graph) {\n    // check if it's a valid graphology instance\n    if (!(0, is_graph_1.default)(graph))\n        throw new Error(\"Sigma: invalid graph instance.\");\n    // check if nodes have x/y attributes\n    graph.forEachNode(function (key, attributes) {\n        if (!Number.isFinite(attributes.x) || !Number.isFinite(attributes.y)) {\n            throw new Error(\"Sigma: Coordinates of node \".concat(key, \" are invalid. A node must have a numeric 'x' and 'y' attribute.\"));\n        }\n    });\n}\nexports.validateGraph = validateGraph;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.cubicInOut = exports.cubicOut = exports.cubicIn = exports.quadraticInOut = exports.quadraticOut = exports.quadraticIn = exports.linear = void 0;\n/**\n * Sigma.js Easings\n * =================\n *\n * Handy collection of easing functions.\n * @module\n */\nvar linear = function (k) { return k; };\nexports.linear = linear;\nvar quadraticIn = function (k) { return k * k; };\nexports.quadraticIn = quadraticIn;\nvar quadraticOut = function (k) { return k * (2 - k); };\nexports.quadraticOut = quadraticOut;\nvar quadraticInOut = function (k) {\n    if ((k *= 2) < 1)\n        return 0.5 * k * k;\n    return -0.5 * (--k * (k - 2) - 1);\n};\nexports.quadraticInOut = quadraticInOut;\nvar cubicIn = function (k) { return k * k * k; };\nexports.cubicIn = cubicIn;\nvar cubicOut = function (k) { return --k * k * k + 1; };\nexports.cubicOut = cubicOut;\nvar cubicInOut = function (k) {\n    if ((k *= 2) < 1)\n        return 0.5 * k * k * k;\n    return 0.5 * ((k -= 2) * k * k + 2);\n};\nexports.cubicInOut = cubicInOut;\nvar easings = {\n    linear: exports.linear,\n    quadraticIn: exports.quadraticIn,\n    quadraticOut: exports.quadraticOut,\n    quadraticInOut: exports.quadraticInOut,\n    cubicIn: exports.cubicIn,\n    cubicOut: exports.cubicOut,\n    cubicInOut: exports.cubicInOut,\n};\nexports.default = easings;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.animateNodes = exports.ANIMATE_DEFAULTS = void 0;\nvar index_1 = require(\"./index\");\nvar easings_1 = __importDefault(require(\"./easings\"));\nexports.ANIMATE_DEFAULTS = {\n    easing: \"quadraticInOut\",\n    duration: 150,\n};\n/**\n * Function used to animate the nodes.\n */\nfunction animateNodes(graph, targets, opts, callback) {\n    var options = Object.assign({}, exports.ANIMATE_DEFAULTS, opts);\n    var easing = typeof options.easing === \"function\" ? options.easing : easings_1.default[options.easing];\n    var start = Date.now();\n    var startPositions = {};\n    for (var node in targets) {\n        var attrs = targets[node];\n        startPositions[node] = {};\n        for (var k in attrs)\n            startPositions[node][k] = graph.getNodeAttribute(node, k);\n    }\n    var frame = null;\n    var step = function () {\n        frame = null;\n        var p = (Date.now() - start) / options.duration;\n        if (p >= 1) {\n            // Animation is done\n            for (var node in targets) {\n                var attrs = targets[node];\n                // We use given values to avoid precision issues and for convenience\n                for (var k in attrs)\n                    graph.setNodeAttribute(node, k, attrs[k]);\n            }\n            if (typeof callback === \"function\")\n                callback();\n            return;\n        }\n        p = easing(p);\n        for (var node in targets) {\n            var attrs = targets[node];\n            var s = startPositions[node];\n            for (var k in attrs)\n                graph.setNodeAttribute(node, k, attrs[k] * p + s[k] * (1 - p));\n        }\n        frame = (0, index_1.requestFrame)(step);\n    };\n    step();\n    return function () {\n        if (frame)\n            (0, index_1.cancelFrame)(frame);\n    };\n}\nexports.animateNodes = animateNodes;\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TypedEventEmitter = void 0;\n/**\n * Sigma.js Types\n * ===============\n *\n * Various type declarations used throughout the library.\n * @module\n */\nvar events_1 = require(\"events\");\nvar TypedEventEmitter = /** @class */ (function (_super) {\n    __extends(TypedEventEmitter, _super);\n    function TypedEventEmitter() {\n        var _this = _super.call(this) || this;\n        _this.rawEmitter = _this;\n        return _this;\n    }\n    return TypedEventEmitter;\n}(events_1.EventEmitter));\nexports.TypedEventEmitter = TypedEventEmitter;\n","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Sigma.js Camera Class\n * ======================\n *\n * Class designed to store camera information & used to update it.\n * @module\n */\nvar animate_1 = require(\"../utils/animate\");\nvar easings_1 = __importDefault(require(\"../utils/easings\"));\nvar utils_1 = require(\"../utils\");\nvar types_1 = require(\"../types\");\n/**\n * Defaults.\n */\nvar DEFAULT_ZOOMING_RATIO = 1.5;\n/**\n * Camera class\n *\n * @constructor\n */\nvar Camera = /** @class */ (function (_super) {\n    __extends(Camera, _super);\n    function Camera() {\n        var _this = _super.call(this) || this;\n        _this.x = 0.5;\n        _this.y = 0.5;\n        _this.angle = 0;\n        _this.ratio = 1;\n        _this.minRatio = null;\n        _this.maxRatio = null;\n        _this.nextFrame = null;\n        _this.previousState = null;\n        _this.enabled = true;\n        // State\n        _this.previousState = _this.getState();\n        return _this;\n    }\n    /**\n     * Static method used to create a Camera object with a given state.\n     *\n     * @param state\n     * @return {Camera}\n     */\n    Camera.from = function (state) {\n        var camera = new Camera();\n        return camera.setState(state);\n    };\n    /**\n     * Method used to enable the camera.\n     *\n     * @return {Camera}\n     */\n    Camera.prototype.enable = function () {\n        this.enabled = true;\n        return this;\n    };\n    /**\n     * Method used to disable the camera.\n     *\n     * @return {Camera}\n     */\n    Camera.prototype.disable = function () {\n        this.enabled = false;\n        return this;\n    };\n    /**\n     * Method used to retrieve the camera's current state.\n     *\n     * @return {object}\n     */\n    Camera.prototype.getState = function () {\n        return {\n            x: this.x,\n            y: this.y,\n            angle: this.angle,\n            ratio: this.ratio,\n        };\n    };\n    /**\n     * Method used to check whether the camera has the given state.\n     *\n     * @return {object}\n     */\n    Camera.prototype.hasState = function (state) {\n        return this.x === state.x && this.y === state.y && this.ratio === state.ratio && this.angle === state.angle;\n    };\n    /**\n     * Method used to retrieve the camera's previous state.\n     *\n     * @return {object}\n     */\n    Camera.prototype.getPreviousState = function () {\n        var state = this.previousState;\n        if (!state)\n            return null;\n        return {\n            x: state.x,\n            y: state.y,\n            angle: state.angle,\n            ratio: state.ratio,\n        };\n    };\n    /**\n     * Method used to check minRatio and maxRatio values.\n     *\n     * @param ratio\n     * @return {number}\n     */\n    Camera.prototype.getBoundedRatio = function (ratio) {\n        var r = ratio;\n        if (typeof this.minRatio === \"number\")\n            r = Math.max(r, this.minRatio);\n        if (typeof this.maxRatio === \"number\")\n            r = Math.min(r, this.maxRatio);\n        return r;\n    };\n    /**\n     * Method used to check various things to return a legit state candidate.\n     *\n     * @param state\n     * @return {object}\n     */\n    Camera.prototype.validateState = function (state) {\n        var validatedState = {};\n        if (typeof state.x === \"number\")\n            validatedState.x = state.x;\n        if (typeof state.y === \"number\")\n            validatedState.y = state.y;\n        if (typeof state.angle === \"number\")\n            validatedState.angle = state.angle;\n        if (typeof state.ratio === \"number\")\n            validatedState.ratio = this.getBoundedRatio(state.ratio);\n        return validatedState;\n    };\n    /**\n     * Method used to check whether the camera is currently being animated.\n     *\n     * @return {boolean}\n     */\n    Camera.prototype.isAnimated = function () {\n        return !!this.nextFrame;\n    };\n    /**\n     * Method used to set the camera's state.\n     *\n     * @param  {object} state - New state.\n     * @return {Camera}\n     */\n    Camera.prototype.setState = function (state) {\n        if (!this.enabled)\n            return this;\n        // TODO: update by function\n        // Keeping track of last state\n        this.previousState = this.getState();\n        var validState = this.validateState(state);\n        if (typeof validState.x === \"number\")\n            this.x = validState.x;\n        if (typeof validState.y === \"number\")\n            this.y = validState.y;\n        if (typeof validState.angle === \"number\")\n            this.angle = validState.angle;\n        if (typeof validState.ratio === \"number\")\n            this.ratio = validState.ratio;\n        // Emitting\n        if (!this.hasState(this.previousState))\n            this.emit(\"updated\", this.getState());\n        return this;\n    };\n    /**\n     * Method used to animate the camera.\n     *\n     * @param  {object}                    state      - State to reach eventually.\n     * @param  {object}                    opts       - Options:\n     * @param  {number}                      duration - Duration of the animation.\n     * @param  {string | number => number}   easing   - Easing function or name of an existing one\n     * @param  {function}                  callback   - Callback\n     */\n    Camera.prototype.animate = function (state, opts, callback) {\n        var _this = this;\n        if (!this.enabled)\n            return;\n        var options = Object.assign({}, animate_1.ANIMATE_DEFAULTS, opts);\n        var validState = this.validateState(state);\n        var easing = typeof options.easing === \"function\" ? options.easing : easings_1.default[options.easing];\n        // State\n        var start = Date.now(), initialState = this.getState();\n        // Function performing the animation\n        var fn = function () {\n            var t = (Date.now() - start) / options.duration;\n            // The animation is over:\n            if (t >= 1) {\n                _this.nextFrame = null;\n                _this.setState(validState);\n                if (_this.animationCallback) {\n                    _this.animationCallback.call(null);\n                    _this.animationCallback = undefined;\n                }\n                return;\n            }\n            var coefficient = easing(t);\n            var newState = {};\n            if (typeof validState.x === \"number\")\n                newState.x = initialState.x + (validState.x - initialState.x) * coefficient;\n            if (typeof validState.y === \"number\")\n                newState.y = initialState.y + (validState.y - initialState.y) * coefficient;\n            if (typeof validState.angle === \"number\")\n                newState.angle = initialState.angle + (validState.angle - initialState.angle) * coefficient;\n            if (typeof validState.ratio === \"number\")\n                newState.ratio = initialState.ratio + (validState.ratio - initialState.ratio) * coefficient;\n            _this.setState(newState);\n            _this.nextFrame = (0, utils_1.requestFrame)(fn);\n        };\n        if (this.nextFrame) {\n            (0, utils_1.cancelFrame)(this.nextFrame);\n            if (this.animationCallback)\n                this.animationCallback.call(null);\n            this.nextFrame = (0, utils_1.requestFrame)(fn);\n        }\n        else {\n            fn();\n        }\n        this.animationCallback = callback;\n    };\n    /**\n     * Method used to zoom the camera.\n     *\n     * @param  {number|object} factorOrOptions - Factor or options.\n     * @return {function}\n     */\n    Camera.prototype.animatedZoom = function (factorOrOptions) {\n        if (!factorOrOptions) {\n            this.animate({ ratio: this.ratio / DEFAULT_ZOOMING_RATIO });\n        }\n        else {\n            if (typeof factorOrOptions === \"number\")\n                return this.animate({ ratio: this.ratio / factorOrOptions });\n            else\n                this.animate({\n                    ratio: this.ratio / (factorOrOptions.factor || DEFAULT_ZOOMING_RATIO),\n                }, factorOrOptions);\n        }\n    };\n    /**\n     * Method used to unzoom the camera.\n     *\n     * @param  {number|object} factorOrOptions - Factor or options.\n     */\n    Camera.prototype.animatedUnzoom = function (factorOrOptions) {\n        if (!factorOrOptions) {\n            this.animate({ ratio: this.ratio * DEFAULT_ZOOMING_RATIO });\n        }\n        else {\n            if (typeof factorOrOptions === \"number\")\n                return this.animate({ ratio: this.ratio * factorOrOptions });\n            else\n                this.animate({\n                    ratio: this.ratio * (factorOrOptions.factor || DEFAULT_ZOOMING_RATIO),\n                }, factorOrOptions);\n        }\n    };\n    /**\n     * Method used to reset the camera.\n     *\n     * @param  {object} options - Options.\n     */\n    Camera.prototype.animatedReset = function (options) {\n        this.animate({\n            x: 0.5,\n            y: 0.5,\n            ratio: 1,\n            angle: 0,\n        }, options);\n    };\n    /**\n     * Returns a new Camera instance, with the same state as the current camera.\n     *\n     * @return {Camera}\n     */\n    Camera.prototype.copy = function () {\n        return Camera.from(this.getState());\n    };\n    return Camera;\n}(types_1.TypedEventEmitter));\nexports.default = Camera;\n","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getWheelDelta = exports.getTouchCoords = exports.getTouchesArray = exports.getWheelCoords = exports.getMouseCoords = exports.getPosition = void 0;\n/**\n * Sigma.js Captor Class\n * ======================\n * @module\n */\nvar types_1 = require(\"../../types\");\n/**\n * Captor utils functions\n * ======================\n */\n/**\n * Extract the local X and Y coordinates from a mouse event or touch object. If\n * a DOM element is given, it uses this element's offset to compute the position\n * (this allows using events that are not bound to the container itself and\n * still have a proper position).\n *\n * @param  {event}       e - A mouse event or touch object.\n * @param  {HTMLElement} dom - A DOM element to compute offset relatively to.\n * @return {number}      The local Y value of the mouse.\n */\nfunction getPosition(e, dom) {\n    var bbox = dom.getBoundingClientRect();\n    return {\n        x: e.clientX - bbox.left,\n        y: e.clientY - bbox.top,\n    };\n}\nexports.getPosition = getPosition;\n/**\n * Convert mouse coords to sigma coords.\n *\n * @param  {event}       e   - A mouse event or touch object.\n * @param  {HTMLElement} dom - A DOM element to compute offset relatively to.\n * @return {object}\n */\nfunction getMouseCoords(e, dom) {\n    var res = __assign(__assign({}, getPosition(e, dom)), { sigmaDefaultPrevented: false, preventSigmaDefault: function () {\n            res.sigmaDefaultPrevented = true;\n        }, original: e });\n    return res;\n}\nexports.getMouseCoords = getMouseCoords;\n/**\n * Convert mouse wheel event coords to sigma coords.\n *\n * @param  {event}       e   - A wheel mouse event.\n * @param  {HTMLElement} dom - A DOM element to compute offset relatively to.\n * @return {object}\n */\nfunction getWheelCoords(e, dom) {\n    return __assign(__assign({}, getMouseCoords(e, dom)), { delta: getWheelDelta(e) });\n}\nexports.getWheelCoords = getWheelCoords;\nvar MAX_TOUCHES = 2;\nfunction getTouchesArray(touches) {\n    var arr = [];\n    for (var i = 0, l = Math.min(touches.length, MAX_TOUCHES); i < l; i++)\n        arr.push(touches[i]);\n    return arr;\n}\nexports.getTouchesArray = getTouchesArray;\n/**\n * Convert touch coords to sigma coords.\n *\n * @param  {event}       e   - A touch event.\n * @param  {HTMLElement} dom - A DOM element to compute offset relatively to.\n * @return {object}\n */\nfunction getTouchCoords(e, dom) {\n    return {\n        touches: getTouchesArray(e.touches).map(function (touch) { return getPosition(touch, dom); }),\n        original: e,\n    };\n}\nexports.getTouchCoords = getTouchCoords;\n/**\n * Extract the wheel delta from a mouse event or touch object.\n *\n * @param  {event}  e - A mouse event or touch object.\n * @return {number}     The wheel delta of the mouse.\n */\nfunction getWheelDelta(e) {\n    // TODO: check those ratios again to ensure a clean Chrome/Firefox compat\n    if (typeof e.deltaY !== \"undefined\")\n        return (e.deltaY * -3) / 360;\n    if (typeof e.detail !== \"undefined\")\n        return e.detail / -9;\n    throw new Error(\"Captor: could not extract delta from event.\");\n}\nexports.getWheelDelta = getWheelDelta;\n/**\n * Abstract class representing a captor like the user's mouse or touch controls.\n */\nvar Captor = /** @class */ (function (_super) {\n    __extends(Captor, _super);\n    function Captor(container, renderer) {\n        var _this = _super.call(this) || this;\n        // Properties\n        _this.container = container;\n        _this.renderer = renderer;\n        return _this;\n    }\n    return Captor;\n}(types_1.TypedEventEmitter));\nexports.default = Captor;\n","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar captor_1 = __importStar(require(\"./captor\"));\n/**\n * Constants.\n */\nvar DRAG_TIMEOUT = 100;\nvar DRAGGED_EVENTS_TOLERANCE = 3;\nvar MOUSE_INERTIA_DURATION = 200;\nvar MOUSE_INERTIA_RATIO = 3;\nvar MOUSE_ZOOM_DURATION = 250;\nvar ZOOMING_RATIO = 1.7;\nvar DOUBLE_CLICK_TIMEOUT = 300;\nvar DOUBLE_CLICK_ZOOMING_RATIO = 2.2;\nvar DOUBLE_CLICK_ZOOMING_DURATION = 200;\n/**\n * Mouse captor class.\n *\n * @constructor\n */\nvar MouseCaptor = /** @class */ (function (_super) {\n    __extends(MouseCaptor, _super);\n    function MouseCaptor(container, renderer) {\n        var _this = _super.call(this, container, renderer) || this;\n        // State\n        _this.enabled = true;\n        _this.draggedEvents = 0;\n        _this.downStartTime = null;\n        _this.lastMouseX = null;\n        _this.lastMouseY = null;\n        _this.isMouseDown = false;\n        _this.isMoving = false;\n        _this.movingTimeout = null;\n        _this.startCameraState = null;\n        _this.clicks = 0;\n        _this.doubleClickTimeout = null;\n        _this.currentWheelDirection = 0;\n        // Binding methods\n        _this.handleClick = _this.handleClick.bind(_this);\n        _this.handleRightClick = _this.handleRightClick.bind(_this);\n        _this.handleDown = _this.handleDown.bind(_this);\n        _this.handleUp = _this.handleUp.bind(_this);\n        _this.handleMove = _this.handleMove.bind(_this);\n        _this.handleWheel = _this.handleWheel.bind(_this);\n        _this.handleOut = _this.handleOut.bind(_this);\n        // Binding events\n        container.addEventListener(\"click\", _this.handleClick, false);\n        container.addEventListener(\"contextmenu\", _this.handleRightClick, false);\n        container.addEventListener(\"mousedown\", _this.handleDown, false);\n        container.addEventListener(\"wheel\", _this.handleWheel, false);\n        container.addEventListener(\"mouseout\", _this.handleOut, false);\n        document.addEventListener(\"mousemove\", _this.handleMove, false);\n        document.addEventListener(\"mouseup\", _this.handleUp, false);\n        return _this;\n    }\n    MouseCaptor.prototype.kill = function () {\n        var container = this.container;\n        container.removeEventListener(\"click\", this.handleClick);\n        container.removeEventListener(\"contextmenu\", this.handleRightClick);\n        container.removeEventListener(\"mousedown\", this.handleDown);\n        container.removeEventListener(\"wheel\", this.handleWheel);\n        container.removeEventListener(\"mouseout\", this.handleOut);\n        document.removeEventListener(\"mousemove\", this.handleMove);\n        document.removeEventListener(\"mouseup\", this.handleUp);\n    };\n    MouseCaptor.prototype.handleClick = function (e) {\n        var _this = this;\n        if (!this.enabled)\n            return;\n        this.clicks++;\n        if (this.clicks === 2) {\n            this.clicks = 0;\n            if (typeof this.doubleClickTimeout === \"number\") {\n                clearTimeout(this.doubleClickTimeout);\n                this.doubleClickTimeout = null;\n            }\n            return this.handleDoubleClick(e);\n        }\n        setTimeout(function () {\n            _this.clicks = 0;\n            _this.doubleClickTimeout = null;\n        }, DOUBLE_CLICK_TIMEOUT);\n        // NOTE: this is here to prevent click events on drag\n        if (this.draggedEvents < DRAGGED_EVENTS_TOLERANCE)\n            this.emit(\"click\", (0, captor_1.getMouseCoords)(e, this.container));\n    };\n    MouseCaptor.prototype.handleRightClick = function (e) {\n        if (!this.enabled)\n            return;\n        this.emit(\"rightClick\", (0, captor_1.getMouseCoords)(e, this.container));\n    };\n    MouseCaptor.prototype.handleDoubleClick = function (e) {\n        if (!this.enabled)\n            return;\n        e.preventDefault();\n        e.stopPropagation();\n        var mouseCoords = (0, captor_1.getMouseCoords)(e, this.container);\n        this.emit(\"doubleClick\", mouseCoords);\n        if (mouseCoords.sigmaDefaultPrevented)\n            return;\n        // default behavior\n        var camera = this.renderer.getCamera();\n        var newRatio = camera.getBoundedRatio(camera.getState().ratio / DOUBLE_CLICK_ZOOMING_RATIO);\n        camera.animate(this.renderer.getViewportZoomedState((0, captor_1.getPosition)(e, this.container), newRatio), {\n            easing: \"quadraticInOut\",\n            duration: DOUBLE_CLICK_ZOOMING_DURATION,\n        });\n    };\n    MouseCaptor.prototype.handleDown = function (e) {\n        if (!this.enabled)\n            return;\n        this.startCameraState = this.renderer.getCamera().getState();\n        var _a = (0, captor_1.getPosition)(e, this.container), x = _a.x, y = _a.y;\n        this.lastMouseX = x;\n        this.lastMouseY = y;\n        this.draggedEvents = 0;\n        this.downStartTime = Date.now();\n        // TODO: dispatch events\n        // Left button pressed\n        this.isMouseDown = true;\n        this.emit(\"mousedown\", (0, captor_1.getMouseCoords)(e, this.container));\n    };\n    MouseCaptor.prototype.handleUp = function (e) {\n        var _this = this;\n        if (!this.enabled || !this.isMouseDown)\n            return;\n        var camera = this.renderer.getCamera();\n        this.isMouseDown = false;\n        if (typeof this.movingTimeout === \"number\") {\n            clearTimeout(this.movingTimeout);\n            this.movingTimeout = null;\n        }\n        var _a = (0, captor_1.getPosition)(e, this.container), x = _a.x, y = _a.y;\n        var cameraState = camera.getState(), previousCameraState = camera.getPreviousState() || { x: 0, y: 0 };\n        if (this.isMoving) {\n            camera.animate({\n                x: cameraState.x + MOUSE_INERTIA_RATIO * (cameraState.x - previousCameraState.x),\n                y: cameraState.y + MOUSE_INERTIA_RATIO * (cameraState.y - previousCameraState.y),\n            }, {\n                duration: MOUSE_INERTIA_DURATION,\n                easing: \"quadraticOut\",\n            });\n        }\n        else if (this.lastMouseX !== x || this.lastMouseY !== y) {\n            camera.setState({\n                x: cameraState.x,\n                y: cameraState.y,\n            });\n        }\n        this.isMoving = false;\n        setTimeout(function () {\n            _this.draggedEvents = 0;\n            _this.renderer.refresh();\n        }, 0);\n        this.emit(\"mouseup\", (0, captor_1.getMouseCoords)(e, this.container));\n    };\n    MouseCaptor.prototype.handleMove = function (e) {\n        var _this = this;\n        if (!this.enabled)\n            return;\n        var mouseCoords = (0, captor_1.getMouseCoords)(e, this.container);\n        // Always trigger a \"mousemovebody\" event, so that it is possible to develop\n        // a drag-and-drop effect that works even when the mouse is out of the\n        // container:\n        this.emit(\"mousemovebody\", mouseCoords);\n        // Only trigger the \"mousemove\" event when the mouse is actually hovering\n        // the container, to avoid weirdly hovering nodes and/or edges when the\n        // mouse is not hover the container:\n        if (e.target === this.container) {\n            this.emit(\"mousemove\", mouseCoords);\n        }\n        if (mouseCoords.sigmaDefaultPrevented)\n            return;\n        // Handle the case when \"isMouseDown\" all the time, to allow dragging the\n        // stage while the mouse is not hover the container:\n        if (this.isMouseDown) {\n            this.isMoving = true;\n            this.draggedEvents++;\n            if (typeof this.movingTimeout === \"number\") {\n                clearTimeout(this.movingTimeout);\n            }\n            this.movingTimeout = window.setTimeout(function () {\n                _this.movingTimeout = null;\n                _this.isMoving = false;\n            }, DRAG_TIMEOUT);\n            var camera = this.renderer.getCamera();\n            var _a = (0, captor_1.getPosition)(e, this.container), eX = _a.x, eY = _a.y;\n            var lastMouse = this.renderer.viewportToFramedGraph({\n                x: this.lastMouseX,\n                y: this.lastMouseY,\n            });\n            var mouse = this.renderer.viewportToFramedGraph({ x: eX, y: eY });\n            var offsetX = lastMouse.x - mouse.x, offsetY = lastMouse.y - mouse.y;\n            var cameraState = camera.getState();\n            var x = cameraState.x + offsetX, y = cameraState.y + offsetY;\n            camera.setState({ x: x, y: y });\n            this.lastMouseX = eX;\n            this.lastMouseY = eY;\n            e.preventDefault();\n            e.stopPropagation();\n        }\n    };\n    MouseCaptor.prototype.handleWheel = function (e) {\n        var _this = this;\n        if (!this.enabled)\n            return;\n        e.preventDefault();\n        e.stopPropagation();\n        var delta = (0, captor_1.getWheelDelta)(e);\n        if (!delta)\n            return;\n        var wheelCoords = (0, captor_1.getWheelCoords)(e, this.container);\n        this.emit(\"wheel\", wheelCoords);\n        if (wheelCoords.sigmaDefaultPrevented)\n            return;\n        // Default behavior\n        var ratioDiff = delta > 0 ? 1 / ZOOMING_RATIO : ZOOMING_RATIO;\n        var camera = this.renderer.getCamera();\n        var newRatio = camera.getBoundedRatio(camera.getState().ratio * ratioDiff);\n        var wheelDirection = delta > 0 ? 1 : -1;\n        var now = Date.now();\n        // Cancel events that are too close too each other and in the same direction:\n        if (this.currentWheelDirection === wheelDirection &&\n            this.lastWheelTriggerTime &&\n            now - this.lastWheelTriggerTime < MOUSE_ZOOM_DURATION / 5) {\n            return;\n        }\n        camera.animate(this.renderer.getViewportZoomedState((0, captor_1.getPosition)(e, this.container), newRatio), {\n            easing: \"quadraticOut\",\n            duration: MOUSE_ZOOM_DURATION,\n        }, function () {\n            _this.currentWheelDirection = 0;\n        });\n        this.currentWheelDirection = wheelDirection;\n        this.lastWheelTriggerTime = now;\n    };\n    MouseCaptor.prototype.handleOut = function () {\n        // TODO: dispatch event\n    };\n    return MouseCaptor;\n}(captor_1.default));\nexports.default = MouseCaptor;\n","/**\n * Extend function\n * ================\n *\n * Function used to push a bunch of values into an array at once.\n *\n * Its strategy is to mutate target array's length then setting the new indices\n * to be the values to add.\n *\n * A benchmark proved that it is faster than the following strategies:\n *   1) `array.push.apply(array, values)`.\n *   2) A loop of pushes.\n *   3) `array = array.concat(values)`, obviously.\n *\n * Intuitively, this is correct because when adding a lot of elements, the\n * chosen strategies does not need to handle the `arguments` object to\n * execute #.apply's variadicity and because the array know its final length\n * at the beginning, avoiding potential multiple reallocations of the underlying\n * contiguous array. Some engines may be able to optimize the loop of push\n * operations but empirically they don't seem to do so.\n */\n\n/**\n * Extends the target array with the given values.\n *\n * @param  {array} array  - Target array.\n * @param  {array} values - Values to add.\n */\nmodule.exports = function extend(array, values) {\n  var l2 = values.length;\n\n  if (l2 === 0)\n    return;\n\n  var l1 = array.length;\n\n  array.length += l2;\n\n  for (var i = 0; i < l2; i++)\n    array[l1 + i] = values[i];\n};\n","\"use strict\";\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.rectangleCollidesWithQuad = exports.squareCollidesWithQuad = exports.getCircumscribedAlignedRectangle = exports.isRectangleAligned = void 0;\n/**\n * Sigma.js Quad Tree Class\n * =========================\n *\n * Class implementing the quad tree data structure used to solve hovers and\n * determine which elements are currently in the scope of the camera so that\n * we don't waste time rendering things the user cannot see anyway.\n * @module\n */\n/* eslint no-nested-ternary: 0 */\n/* eslint no-constant-condition: 0 */\nvar extend_1 = __importDefault(require(\"@yomguithereal/helpers/extend\"));\n// TODO: should not ask the quadtree when the camera has the whole graph in\n// sight.\n// TODO: a square can be represented as topleft + width, saying for the quad blocks (reduce mem)\n// TODO: jsdoc\n// TODO: be sure we can handle cases overcoming boundaries (because of size) or use a maxed size\n// TODO: filtering unwanted labels beforehand through the filter function\n// NOTE: this is basically a MX-CIF Quadtree at this point\n// NOTE: need to explore R-Trees for edges\n// NOTE: need to explore 2d segment tree for edges\n// NOTE: probably can do faster using spatial hashing\n/**\n * Constants.\n *\n * Note that since we are representing a static 4-ary tree, the indices of the\n * quadrants are the following:\n *   - TOP_LEFT:     4i + b\n *   - TOP_RIGHT:    4i + 2b\n *   - BOTTOM_LEFT:  4i + 3b\n *   - BOTTOM_RIGHT: 4i + 4b\n */\nvar BLOCKS = 4, MAX_LEVEL = 5;\nvar OUTSIDE_BLOCK = \"outside\";\nvar X_OFFSET = 0, Y_OFFSET = 1, WIDTH_OFFSET = 2, HEIGHT_OFFSET = 3;\nvar TOP_LEFT = 1, TOP_RIGHT = 2, BOTTOM_LEFT = 3, BOTTOM_RIGHT = 4;\nvar hasWarnedTooMuchOutside = false;\n/**\n * Geometry helpers.\n */\n/**\n * Function returning whether the given rectangle is axis-aligned.\n *\n * @param  {Rectangle} rect\n * @return {boolean}\n */\nfunction isRectangleAligned(rect) {\n    return rect.x1 === rect.x2 || rect.y1 === rect.y2;\n}\nexports.isRectangleAligned = isRectangleAligned;\n/**\n * Function returning the smallest rectangle that contains the given rectangle, and that is aligned with the axis.\n *\n * @param {Rectangle} rect\n * @return {Rectangle}\n */\nfunction getCircumscribedAlignedRectangle(rect) {\n    var width = Math.sqrt(Math.pow(rect.x2 - rect.x1, 2) + Math.pow(rect.y2 - rect.y1, 2));\n    var heightVector = {\n        x: ((rect.y1 - rect.y2) * rect.height) / width,\n        y: ((rect.x2 - rect.x1) * rect.height) / width,\n    };\n    // Compute all corners:\n    var tl = { x: rect.x1, y: rect.y1 };\n    var tr = { x: rect.x2, y: rect.y2 };\n    var bl = {\n        x: rect.x1 + heightVector.x,\n        y: rect.y1 + heightVector.y,\n    };\n    var br = {\n        x: rect.x2 + heightVector.x,\n        y: rect.y2 + heightVector.y,\n    };\n    var xL = Math.min(tl.x, tr.x, bl.x, br.x);\n    var xR = Math.max(tl.x, tr.x, bl.x, br.x);\n    var yT = Math.min(tl.y, tr.y, bl.y, br.y);\n    var yB = Math.max(tl.y, tr.y, bl.y, br.y);\n    return {\n        x1: xL,\n        y1: yT,\n        x2: xR,\n        y2: yT,\n        height: yB - yT,\n    };\n}\nexports.getCircumscribedAlignedRectangle = getCircumscribedAlignedRectangle;\n/**\n *\n * @param x1\n * @param y1\n * @param w\n * @param qx\n * @param qy\n * @param qw\n * @param qh\n */\nfunction squareCollidesWithQuad(x1, y1, w, qx, qy, qw, qh) {\n    return x1 < qx + qw && x1 + w > qx && y1 < qy + qh && y1 + w > qy;\n}\nexports.squareCollidesWithQuad = squareCollidesWithQuad;\nfunction rectangleCollidesWithQuad(x1, y1, w, h, qx, qy, qw, qh) {\n    return x1 < qx + qw && x1 + w > qx && y1 < qy + qh && y1 + h > qy;\n}\nexports.rectangleCollidesWithQuad = rectangleCollidesWithQuad;\nfunction pointIsInQuad(x, y, qx, qy, qw, qh) {\n    var xmp = qx + qw / 2, ymp = qy + qh / 2, top = y < ymp, left = x < xmp;\n    return top ? (left ? TOP_LEFT : TOP_RIGHT) : left ? BOTTOM_LEFT : BOTTOM_RIGHT;\n}\n/**\n * Helper functions that are not bound to the class so an external user\n * cannot mess with them.\n */\nfunction buildQuadrants(maxLevel, data) {\n    // [block, level]\n    var stack = [0, 0];\n    while (stack.length) {\n        var level = stack.pop(), block = stack.pop();\n        var topLeftBlock = 4 * block + BLOCKS, topRightBlock = 4 * block + 2 * BLOCKS, bottomLeftBlock = 4 * block + 3 * BLOCKS, bottomRightBlock = 4 * block + 4 * BLOCKS;\n        var x = data[block + X_OFFSET], y = data[block + Y_OFFSET], width = data[block + WIDTH_OFFSET], height = data[block + HEIGHT_OFFSET], hw = width / 2, hh = height / 2;\n        data[topLeftBlock + X_OFFSET] = x;\n        data[topLeftBlock + Y_OFFSET] = y;\n        data[topLeftBlock + WIDTH_OFFSET] = hw;\n        data[topLeftBlock + HEIGHT_OFFSET] = hh;\n        data[topRightBlock + X_OFFSET] = x + hw;\n        data[topRightBlock + Y_OFFSET] = y;\n        data[topRightBlock + WIDTH_OFFSET] = hw;\n        data[topRightBlock + HEIGHT_OFFSET] = hh;\n        data[bottomLeftBlock + X_OFFSET] = x;\n        data[bottomLeftBlock + Y_OFFSET] = y + hh;\n        data[bottomLeftBlock + WIDTH_OFFSET] = hw;\n        data[bottomLeftBlock + HEIGHT_OFFSET] = hh;\n        data[bottomRightBlock + X_OFFSET] = x + hw;\n        data[bottomRightBlock + Y_OFFSET] = y + hh;\n        data[bottomRightBlock + WIDTH_OFFSET] = hw;\n        data[bottomRightBlock + HEIGHT_OFFSET] = hh;\n        if (level < maxLevel - 1) {\n            stack.push(bottomRightBlock, level + 1);\n            stack.push(bottomLeftBlock, level + 1);\n            stack.push(topRightBlock, level + 1);\n            stack.push(topLeftBlock, level + 1);\n        }\n    }\n}\nfunction insertNode(maxLevel, data, containers, key, x, y, size) {\n    var x1 = x - size, y1 = y - size, w = size * 2;\n    var level = 0, block = 0;\n    while (true) {\n        // If we reached max level\n        if (level >= maxLevel) {\n            containers[block] = containers[block] || [];\n            containers[block].push(key);\n            return;\n        }\n        var topLeftBlock = 4 * block + BLOCKS, topRightBlock = 4 * block + 2 * BLOCKS, bottomLeftBlock = 4 * block + 3 * BLOCKS, bottomRightBlock = 4 * block + 4 * BLOCKS;\n        var collidingWithTopLeft = squareCollidesWithQuad(x1, y1, w, data[topLeftBlock + X_OFFSET], data[topLeftBlock + Y_OFFSET], data[topLeftBlock + WIDTH_OFFSET], data[topLeftBlock + HEIGHT_OFFSET]);\n        var collidingWithTopRight = squareCollidesWithQuad(x1, y1, w, data[topRightBlock + X_OFFSET], data[topRightBlock + Y_OFFSET], data[topRightBlock + WIDTH_OFFSET], data[topRightBlock + HEIGHT_OFFSET]);\n        var collidingWithBottomLeft = squareCollidesWithQuad(x1, y1, w, data[bottomLeftBlock + X_OFFSET], data[bottomLeftBlock + Y_OFFSET], data[bottomLeftBlock + WIDTH_OFFSET], data[bottomLeftBlock + HEIGHT_OFFSET]);\n        var collidingWithBottomRight = squareCollidesWithQuad(x1, y1, w, data[bottomRightBlock + X_OFFSET], data[bottomRightBlock + Y_OFFSET], data[bottomRightBlock + WIDTH_OFFSET], data[bottomRightBlock + HEIGHT_OFFSET]);\n        var collisions = [\n            collidingWithTopLeft,\n            collidingWithTopRight,\n            collidingWithBottomLeft,\n            collidingWithBottomRight,\n        ].reduce(function (acc, current) {\n            if (current)\n                return acc + 1;\n            else\n                return acc;\n        }, 0);\n        // If we have no collision at root level, inject node in the outside block\n        if (collisions === 0 && level === 0) {\n            containers[OUTSIDE_BLOCK].push(key);\n            if (!hasWarnedTooMuchOutside && containers[OUTSIDE_BLOCK].length >= 5) {\n                hasWarnedTooMuchOutside = true;\n                console.warn(\"sigma/quadtree.insertNode: At least 5 nodes are outside the global quadtree zone. \" +\n                    \"You might have a problem with the normalization function or the custom bounding box.\");\n            }\n            return;\n        }\n        // If we don't have at least a collision but deeper, there is an issue\n        if (collisions === 0)\n            throw new Error(\"sigma/quadtree.insertNode: no collision (level: \".concat(level, \", key: \").concat(key, \", x: \").concat(x, \", y: \").concat(y, \", size: \").concat(size, \").\"));\n        // If we have 3 collisions, we have a geometry problem obviously\n        if (collisions === 3)\n            throw new Error(\"sigma/quadtree.insertNode: 3 impossible collisions (level: \".concat(level, \", key: \").concat(key, \", x: \").concat(x, \", y: \").concat(y, \", size: \").concat(size, \").\"));\n        // If we have more that one collision, we stop here and store the node\n        // in the relevant containers\n        if (collisions > 1) {\n            containers[block] = containers[block] || [];\n            containers[block].push(key);\n            return;\n        }\n        else {\n            level++;\n        }\n        // Else we recurse into the correct quads\n        if (collidingWithTopLeft)\n            block = topLeftBlock;\n        if (collidingWithTopRight)\n            block = topRightBlock;\n        if (collidingWithBottomLeft)\n            block = bottomLeftBlock;\n        if (collidingWithBottomRight)\n            block = bottomRightBlock;\n    }\n}\nfunction getNodesInAxisAlignedRectangleArea(maxLevel, data, containers, x1, y1, w, h) {\n    // [block, level]\n    var stack = [0, 0];\n    var collectedNodes = [];\n    var container;\n    while (stack.length) {\n        var level = stack.pop(), block = stack.pop();\n        // Collecting nodes\n        container = containers[block];\n        if (container)\n            (0, extend_1.default)(collectedNodes, container);\n        // If we reached max level\n        if (level >= maxLevel)\n            continue;\n        var topLeftBlock = 4 * block + BLOCKS, topRightBlock = 4 * block + 2 * BLOCKS, bottomLeftBlock = 4 * block + 3 * BLOCKS, bottomRightBlock = 4 * block + 4 * BLOCKS;\n        var collidingWithTopLeft = rectangleCollidesWithQuad(x1, y1, w, h, data[topLeftBlock + X_OFFSET], data[topLeftBlock + Y_OFFSET], data[topLeftBlock + WIDTH_OFFSET], data[topLeftBlock + HEIGHT_OFFSET]);\n        var collidingWithTopRight = rectangleCollidesWithQuad(x1, y1, w, h, data[topRightBlock + X_OFFSET], data[topRightBlock + Y_OFFSET], data[topRightBlock + WIDTH_OFFSET], data[topRightBlock + HEIGHT_OFFSET]);\n        var collidingWithBottomLeft = rectangleCollidesWithQuad(x1, y1, w, h, data[bottomLeftBlock + X_OFFSET], data[bottomLeftBlock + Y_OFFSET], data[bottomLeftBlock + WIDTH_OFFSET], data[bottomLeftBlock + HEIGHT_OFFSET]);\n        var collidingWithBottomRight = rectangleCollidesWithQuad(x1, y1, w, h, data[bottomRightBlock + X_OFFSET], data[bottomRightBlock + Y_OFFSET], data[bottomRightBlock + WIDTH_OFFSET], data[bottomRightBlock + HEIGHT_OFFSET]);\n        if (collidingWithTopLeft)\n            stack.push(topLeftBlock, level + 1);\n        if (collidingWithTopRight)\n            stack.push(topRightBlock, level + 1);\n        if (collidingWithBottomLeft)\n            stack.push(bottomLeftBlock, level + 1);\n        if (collidingWithBottomRight)\n            stack.push(bottomRightBlock, level + 1);\n    }\n    return collectedNodes;\n}\n/**\n * QuadTree class.\n *\n * @constructor\n * @param {object} boundaries - The graph boundaries.\n */\nvar QuadTree = /** @class */ (function () {\n    function QuadTree(params) {\n        var _a;\n        if (params === void 0) { params = {}; }\n        this.containers = (_a = {}, _a[OUTSIDE_BLOCK] = [], _a);\n        this.cache = null;\n        this.lastRectangle = null;\n        // Allocating the underlying byte array\n        var L = Math.pow(4, MAX_LEVEL);\n        this.data = new Float32Array(BLOCKS * ((4 * L - 1) / 3));\n        if (params.boundaries)\n            this.resize(params.boundaries);\n        else\n            this.resize({\n                x: 0,\n                y: 0,\n                width: 1,\n                height: 1,\n            });\n    }\n    QuadTree.prototype.add = function (key, x, y, size) {\n        insertNode(MAX_LEVEL, this.data, this.containers, key, x, y, size);\n        return this;\n    };\n    QuadTree.prototype.resize = function (boundaries) {\n        this.clear();\n        // Building the quadrants\n        this.data[X_OFFSET] = boundaries.x;\n        this.data[Y_OFFSET] = boundaries.y;\n        this.data[WIDTH_OFFSET] = boundaries.width;\n        this.data[HEIGHT_OFFSET] = boundaries.height;\n        buildQuadrants(MAX_LEVEL, this.data);\n    };\n    QuadTree.prototype.clear = function () {\n        var _a;\n        this.containers = (_a = {}, _a[OUTSIDE_BLOCK] = [], _a);\n        return this;\n    };\n    QuadTree.prototype.point = function (x, y) {\n        var nodes = this.containers[OUTSIDE_BLOCK];\n        var block = 0, level = 0;\n        do {\n            if (this.containers[block])\n                nodes.push.apply(nodes, __spreadArray([], __read(this.containers[block]), false));\n            var quad = pointIsInQuad(x, y, this.data[block + X_OFFSET], this.data[block + Y_OFFSET], this.data[block + WIDTH_OFFSET], this.data[block + HEIGHT_OFFSET]);\n            block = 4 * block + quad * BLOCKS;\n            level++;\n        } while (level <= MAX_LEVEL);\n        return nodes;\n    };\n    QuadTree.prototype.rectangle = function (x1, y1, x2, y2, height) {\n        var _a;\n        var lr = this.lastRectangle;\n        if (lr && x1 === lr.x1 && x2 === lr.x2 && y1 === lr.y1 && y2 === lr.y2 && height === lr.height) {\n            return this.cache;\n        }\n        this.lastRectangle = {\n            x1: x1,\n            y1: y1,\n            x2: x2,\n            y2: y2,\n            height: height,\n        };\n        // If the rectangle is shifted, we use the smallest aligned rectangle that contains the shifted one:\n        if (!isRectangleAligned(this.lastRectangle))\n            this.lastRectangle = getCircumscribedAlignedRectangle(this.lastRectangle);\n        this.cache = getNodesInAxisAlignedRectangleArea(MAX_LEVEL, this.data, this.containers, x1, y1, Math.abs(x1 - x2) || Math.abs(y1 - y2), height);\n        // Add all the nodes in the outside block, since they might be relevant, and since they should be very few:\n        (_a = this.cache).push.apply(_a, __spreadArray([], __read(this.containers[OUTSIDE_BLOCK]), false));\n        return this.cache;\n    };\n    return QuadTree;\n}());\nexports.default = QuadTree;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.edgeLabelsToDisplayFromNodes = exports.LabelGrid = void 0;\n/**\n * Class representing a single candidate for the label grid selection.\n *\n * It also describes a deterministic way to compare two candidates to assess\n * which one is better.\n */\nvar LabelCandidate = /** @class */ (function () {\n    function LabelCandidate(key, size) {\n        this.key = key;\n        this.size = size;\n    }\n    LabelCandidate.compare = function (first, second) {\n        // First we compare by size\n        if (first.size > second.size)\n            return -1;\n        if (first.size < second.size)\n            return 1;\n        // Then since no two nodes can have the same key, we use it to\n        // deterministically tie-break by key\n        if (first.key > second.key)\n            return 1;\n        // NOTE: this comparator cannot return 0\n        return -1;\n    };\n    return LabelCandidate;\n}());\n/**\n * Class representing a 2D spatial grid divided into constant-size cells.\n */\nvar LabelGrid = /** @class */ (function () {\n    function LabelGrid() {\n        this.width = 0;\n        this.height = 0;\n        this.cellSize = 0;\n        this.columns = 0;\n        this.rows = 0;\n        this.cells = {};\n    }\n    LabelGrid.prototype.resizeAndClear = function (dimensions, cellSize) {\n        this.width = dimensions.width;\n        this.height = dimensions.height;\n        this.cellSize = cellSize;\n        this.columns = Math.ceil(dimensions.width / cellSize);\n        this.rows = Math.ceil(dimensions.height / cellSize);\n        this.cells = {};\n    };\n    LabelGrid.prototype.getIndex = function (pos) {\n        var xIndex = Math.floor(pos.x / this.cellSize);\n        var yIndex = Math.floor(pos.y / this.cellSize);\n        return yIndex * this.columns + xIndex;\n    };\n    LabelGrid.prototype.add = function (key, size, pos) {\n        var candidate = new LabelCandidate(key, size);\n        var index = this.getIndex(pos);\n        var cell = this.cells[index];\n        if (!cell) {\n            cell = [];\n            this.cells[index] = cell;\n        }\n        cell.push(candidate);\n    };\n    LabelGrid.prototype.organize = function () {\n        for (var k in this.cells) {\n            var cell = this.cells[k];\n            cell.sort(LabelCandidate.compare);\n        }\n    };\n    LabelGrid.prototype.getLabelsToDisplay = function (ratio, density) {\n        // TODO: work on visible nodes to optimize? ^ -> threshold outside so that memoization works?\n        // TODO: adjust threshold lower, but increase cells a bit?\n        // TODO: hunt for geom issue in disguise\n        // TODO: memoize while ratio does not move. method to force recompute\n        var cellArea = this.cellSize * this.cellSize;\n        var scaledCellArea = cellArea / ratio / ratio;\n        var scaledDensity = (scaledCellArea * density) / cellArea;\n        var labelsToDisplayPerCell = Math.ceil(scaledDensity);\n        var labels = [];\n        for (var k in this.cells) {\n            var cell = this.cells[k];\n            for (var i = 0; i < Math.min(labelsToDisplayPerCell, cell.length); i++) {\n                labels.push(cell[i].key);\n            }\n        }\n        return labels;\n    };\n    return LabelGrid;\n}());\nexports.LabelGrid = LabelGrid;\n/**\n * Label heuristic selecting edge labels to display, based on displayed node\n * labels\n *\n * @param  {object} params                 - Parameters:\n * @param  {Set}      displayedNodeLabels  - Currently displayed node labels.\n * @param  {Set}      highlightedNodes     - Highlighted nodes.\n * @param  {Graph}    graph                - The rendered graph.\n * @param  {string}   hoveredNode          - Hovered node (optional)\n * @return {Array}                         - The selected labels.\n */\nfunction edgeLabelsToDisplayFromNodes(params) {\n    var graph = params.graph, hoveredNode = params.hoveredNode, highlightedNodes = params.highlightedNodes, displayedNodeLabels = params.displayedNodeLabels;\n    var worthyEdges = [];\n    // TODO: the code below can be optimized using #.forEach and batching the code per adj\n    // We should display an edge's label if:\n    //   - Any of its extremities is highlighted or hovered\n    //   - Both of its extremities has its label shown\n    graph.forEachEdge(function (edge, _, source, target) {\n        if (source === hoveredNode ||\n            target === hoveredNode ||\n            highlightedNodes.has(source) ||\n            highlightedNodes.has(target) ||\n            (displayedNodeLabels.has(source) && displayedNodeLabels.has(target))) {\n            worthyEdges.push(edge);\n        }\n    });\n    return worthyEdges;\n}\nexports.edgeLabelsToDisplayFromNodes = edgeLabelsToDisplayFromNodes;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction drawLabel(context, data, settings) {\n    if (!data.label)\n        return;\n    var size = settings.labelSize, font = settings.labelFont, weight = settings.labelWeight, color = settings.labelColor.attribute\n        ? data[settings.labelColor.attribute] || settings.labelColor.color || \"#000\"\n        : settings.labelColor.color;\n    context.fillStyle = color;\n    context.font = \"\".concat(weight, \" \").concat(size, \"px \").concat(font);\n    context.fillText(data.label, data.x + data.size + 3, data.y + size / 3);\n}\nexports.default = drawLabel;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar label_1 = __importDefault(require(\"./label\"));\n/**\n * Draw an hovered node.\n * - if there is no label => display a shadow on the node\n * - if the label box is bigger than node size => display a label box that contains the node with a shadow\n * - else node with shadow and the label box\n */\nfunction drawHover(context, data, settings) {\n    var size = settings.labelSize, font = settings.labelFont, weight = settings.labelWeight;\n    context.font = \"\".concat(weight, \" \").concat(size, \"px \").concat(font);\n    // Then we draw the label background\n    context.fillStyle = \"#FFF\";\n    context.shadowOffsetX = 0;\n    context.shadowOffsetY = 0;\n    context.shadowBlur = 8;\n    context.shadowColor = \"#000\";\n    var PADDING = 2;\n    if (typeof data.label === \"string\") {\n        var textWidth = context.measureText(data.label).width, boxWidth = Math.round(textWidth + 5), boxHeight = Math.round(size + 2 * PADDING), radius = Math.max(data.size, size / 2) + PADDING;\n        var angleRadian = Math.asin(boxHeight / 2 / radius);\n        var xDeltaCoord = Math.sqrt(Math.abs(Math.pow(radius, 2) - Math.pow(boxHeight / 2, 2)));\n        context.beginPath();\n        context.moveTo(data.x + xDeltaCoord, data.y + boxHeight / 2);\n        context.lineTo(data.x + radius + boxWidth, data.y + boxHeight / 2);\n        context.lineTo(data.x + radius + boxWidth, data.y - boxHeight / 2);\n        context.lineTo(data.x + xDeltaCoord, data.y - boxHeight / 2);\n        context.arc(data.x, data.y, radius, angleRadian, -angleRadian);\n        context.closePath();\n        context.fill();\n    }\n    else {\n        context.beginPath();\n        context.arc(data.x, data.y, data.size + PADDING, 0, Math.PI * 2);\n        context.closePath();\n        context.fill();\n    }\n    context.shadowOffsetX = 0;\n    context.shadowOffsetY = 0;\n    context.shadowBlur = 0;\n    // And finally we draw the label\n    (0, label_1.default)(context, data, settings);\n}\nexports.default = drawHover;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction drawEdgeLabel(context, edgeData, sourceData, targetData, settings) {\n    var size = settings.edgeLabelSize, font = settings.edgeLabelFont, weight = settings.edgeLabelWeight, color = settings.edgeLabelColor.attribute\n        ? edgeData[settings.edgeLabelColor.attribute] || settings.edgeLabelColor.color || \"#000\"\n        : settings.edgeLabelColor.color;\n    var label = edgeData.label;\n    if (!label)\n        return;\n    context.fillStyle = color;\n    context.font = \"\".concat(weight, \" \").concat(size, \"px \").concat(font);\n    // Computing positions without considering nodes sizes:\n    var sSize = sourceData.size;\n    var tSize = targetData.size;\n    var sx = sourceData.x;\n    var sy = sourceData.y;\n    var tx = targetData.x;\n    var ty = targetData.y;\n    var cx = (sx + tx) / 2;\n    var cy = (sy + ty) / 2;\n    var dx = tx - sx;\n    var dy = ty - sy;\n    var d = Math.sqrt(dx * dx + dy * dy);\n    if (d < sSize + tSize)\n        return;\n    // Adding nodes sizes:\n    sx += (dx * sSize) / d;\n    sy += (dy * sSize) / d;\n    tx -= (dx * tSize) / d;\n    ty -= (dy * tSize) / d;\n    cx = (sx + tx) / 2;\n    cy = (sy + ty) / 2;\n    dx = tx - sx;\n    dy = ty - sy;\n    d = Math.sqrt(dx * dx + dy * dy);\n    // Handling ellipsis\n    var textLength = context.measureText(label).width;\n    if (textLength > d) {\n        var ellipsis = \"\";\n        label = label + ellipsis;\n        textLength = context.measureText(label).width;\n        while (textLength > d && label.length > 1) {\n            label = label.slice(0, -2) + ellipsis;\n            textLength = context.measureText(label).width;\n        }\n        if (label.length < 4)\n            return;\n    }\n    var angle;\n    if (dx > 0) {\n        if (dy > 0)\n            angle = Math.acos(dx / d);\n        else\n            angle = Math.asin(dy / d);\n    }\n    else {\n        if (dy > 0)\n            angle = Math.acos(dx / d) + Math.PI;\n        else\n            angle = Math.asin(dx / d) + Math.PI / 2;\n    }\n    context.save();\n    context.translate(cx, cy);\n    context.rotate(angle);\n    context.fillText(label, -textLength / 2, edgeData.size / 2 + size);\n    context.restore();\n}\nexports.default = drawEdgeLabel;\n","(()=>{\"use strict\";var o={d:(t,e)=>{for(var n in e)o.o(e,n)&&!o.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:e[n]})},o:(o,t)=>Object.prototype.hasOwnProperty.call(o,t),r:o=>{\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(o,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(o,\"__esModule\",{value:!0})}},t={};o.r(t),o.d(t,{default:()=>e});const e=\"attribute vec2 a_position;\\nattribute float a_size;\\nattribute vec4 a_color;\\n\\nuniform float u_ratio;\\nuniform float u_scale;\\nuniform mat3 u_matrix;\\n\\nvarying vec4 v_color;\\nvarying float v_border;\\n\\nconst float bias = 255.0 / 254.0;\\n\\nvoid main() {\\n  gl_Position = vec4(\\n    (u_matrix * vec3(a_position, 1)).xy,\\n    0,\\n    1\\n  );\\n\\n  // Multiply the point size twice:\\n  //  - x SCALING_RATIO to correct the canvas scaling\\n  //  - x 2 to correct the formulae\\n  gl_PointSize = a_size * u_ratio * u_scale * 2.0;\\n\\n  v_border = (1.0 / u_ratio) * (0.5 / a_size);\\n\\n  // Extract the color:\\n  v_color = a_color;\\n  v_color.a *= bias;\\n}\\n\";module.exports=t})();","(()=>{\"use strict\";var e={d:(n,o)=>{for(var t in o)e.o(o,t)&&!e.o(n,t)&&Object.defineProperty(n,t,{enumerable:!0,get:o[t]})},o:(e,n)=>Object.prototype.hasOwnProperty.call(e,n),r:e=>{\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(e,\"__esModule\",{value:!0})}},n={};e.r(n),e.d(n,{default:()=>o});const o=\"precision mediump float;\\n\\nvarying vec4 v_color;\\nvarying float v_border;\\n\\nconst float radius = 0.5;\\nconst vec4 transparent = vec4(0.0, 0.0, 0.0, 0.0);\\n\\nvoid main(void) {\\n  vec2 m = gl_PointCoord - vec2(0.5, 0.5);\\n  float dist = radius - length(m);\\n\\n  float t = 0.0;\\n  if (dist > v_border)\\n    t = 1.0;\\n  else if (dist > 0.0)\\n    t = dist / v_border;\\n\\n  gl_FragColor = mix(transparent, v_color, t);\\n}\\n\";module.exports=n})();","\"use strict\";\n/**\n * Sigma.js Shader Utils\n * ======================\n *\n * Code used to load sigma's shaders.\n * @module\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.loadProgram = exports.loadFragmentShader = exports.loadVertexShader = void 0;\n/**\n * Function used to load a shader.\n */\nfunction loadShader(type, gl, source) {\n    var glType = type === \"VERTEX\" ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER;\n    // Creating the shader\n    var shader = gl.createShader(glType);\n    if (shader === null) {\n        throw new Error(\"loadShader: error while creating the shader\");\n    }\n    // Loading source\n    gl.shaderSource(shader, source);\n    // Compiling the shader\n    gl.compileShader(shader);\n    // Retrieving compilation status\n    var successfullyCompiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n    // Throwing if something went awry\n    if (!successfullyCompiled) {\n        var infoLog = gl.getShaderInfoLog(shader);\n        gl.deleteShader(shader);\n        throw new Error(\"loadShader: error while compiling the shader:\\n\".concat(infoLog, \"\\n\").concat(source));\n    }\n    return shader;\n}\nfunction loadVertexShader(gl, source) {\n    return loadShader(\"VERTEX\", gl, source);\n}\nexports.loadVertexShader = loadVertexShader;\nfunction loadFragmentShader(gl, source) {\n    return loadShader(\"FRAGMENT\", gl, source);\n}\nexports.loadFragmentShader = loadFragmentShader;\n/**\n * Function used to load a program.\n */\nfunction loadProgram(gl, shaders) {\n    var program = gl.createProgram();\n    if (program === null) {\n        throw new Error(\"loadProgram: error while creating the program.\");\n    }\n    var i, l;\n    // Attaching the shaders\n    for (i = 0, l = shaders.length; i < l; i++)\n        gl.attachShader(program, shaders[i]);\n    gl.linkProgram(program);\n    // Checking status\n    var successfullyLinked = gl.getProgramParameter(program, gl.LINK_STATUS);\n    if (!successfullyLinked) {\n        gl.deleteProgram(program);\n        throw new Error(\"loadProgram: error while linking the program.\");\n    }\n    return program;\n}\nexports.loadProgram = loadProgram;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AbstractProgram = void 0;\n/**\n * Sigma.js WebGL Renderer Program\n * ================================\n *\n * Class representing a single WebGL program used by sigma's WebGL renderer.\n * @module\n */\nvar utils_1 = require(\"../../shaders/utils\");\n/**\n * Abstract Program class.\n *\n * @constructor\n */\nvar AbstractProgram = /** @class */ (function () {\n    function AbstractProgram(gl, vertexShaderSource, fragmentShaderSource, points, attributes) {\n        this.array = new Float32Array();\n        this.points = points;\n        this.attributes = attributes;\n        this.gl = gl;\n        this.vertexShaderSource = vertexShaderSource;\n        this.fragmentShaderSource = fragmentShaderSource;\n        var buffer = gl.createBuffer();\n        if (buffer === null)\n            throw new Error(\"AbstractProgram: error while creating the buffer\");\n        this.buffer = buffer;\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);\n        this.vertexShader = (0, utils_1.loadVertexShader)(gl, this.vertexShaderSource);\n        this.fragmentShader = (0, utils_1.loadFragmentShader)(gl, this.fragmentShaderSource);\n        this.program = (0, utils_1.loadProgram)(gl, [this.vertexShader, this.fragmentShader]);\n    }\n    AbstractProgram.prototype.bufferData = function () {\n        var gl = this.gl;\n        gl.bufferData(gl.ARRAY_BUFFER, this.array, gl.DYNAMIC_DRAW);\n    };\n    AbstractProgram.prototype.allocate = function (capacity) {\n        this.array = new Float32Array(this.points * this.attributes * capacity);\n    };\n    AbstractProgram.prototype.hasNothingToRender = function () {\n        return this.array.length === 0;\n    };\n    return AbstractProgram;\n}());\nexports.AbstractProgram = AbstractProgram;\n","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createNodeCompoundProgram = exports.AbstractNodeProgram = void 0;\n/**\n * Sigma.js WebGL Abstract Node Program\n * =====================================\n *\n * @module\n */\nvar program_1 = require(\"./program\");\n/**\n * Node Program class.\n *\n * @constructor\n */\nvar AbstractNodeProgram = /** @class */ (function (_super) {\n    __extends(AbstractNodeProgram, _super);\n    function AbstractNodeProgram(gl, vertexShaderSource, fragmentShaderSource, points, attributes) {\n        var _this = _super.call(this, gl, vertexShaderSource, fragmentShaderSource, points, attributes) || this;\n        // Locations\n        _this.positionLocation = gl.getAttribLocation(_this.program, \"a_position\");\n        _this.sizeLocation = gl.getAttribLocation(_this.program, \"a_size\");\n        _this.colorLocation = gl.getAttribLocation(_this.program, \"a_color\");\n        // Uniform Location\n        var matrixLocation = gl.getUniformLocation(_this.program, \"u_matrix\");\n        if (matrixLocation === null)\n            throw new Error(\"AbstractNodeProgram: error while getting matrixLocation\");\n        _this.matrixLocation = matrixLocation;\n        var ratioLocation = gl.getUniformLocation(_this.program, \"u_ratio\");\n        if (ratioLocation === null)\n            throw new Error(\"AbstractNodeProgram: error while getting ratioLocation\");\n        _this.ratioLocation = ratioLocation;\n        var scaleLocation = gl.getUniformLocation(_this.program, \"u_scale\");\n        if (scaleLocation === null)\n            throw new Error(\"AbstractNodeProgram: error while getting scaleLocation\");\n        _this.scaleLocation = scaleLocation;\n        return _this;\n    }\n    AbstractNodeProgram.prototype.bind = function () {\n        var gl = this.gl;\n        gl.enableVertexAttribArray(this.positionLocation);\n        gl.enableVertexAttribArray(this.sizeLocation);\n        gl.enableVertexAttribArray(this.colorLocation);\n        gl.vertexAttribPointer(this.positionLocation, 2, gl.FLOAT, false, this.attributes * Float32Array.BYTES_PER_ELEMENT, 0);\n        gl.vertexAttribPointer(this.sizeLocation, 1, gl.FLOAT, false, this.attributes * Float32Array.BYTES_PER_ELEMENT, 8);\n        gl.vertexAttribPointer(this.colorLocation, 4, gl.UNSIGNED_BYTE, true, this.attributes * Float32Array.BYTES_PER_ELEMENT, 12);\n    };\n    return AbstractNodeProgram;\n}(program_1.AbstractProgram));\nexports.AbstractNodeProgram = AbstractNodeProgram;\n/**\n * Helper function combining two or more programs into a single compound one.\n * Note that this is more a quick & easy way to combine program than a really\n * performant option. More performant programs can be written entirely.\n *\n * @param  {array}    programClasses - Program classes to combine.\n * @return {function}\n */\nfunction createNodeCompoundProgram(programClasses) {\n    return /** @class */ (function () {\n        function NodeCompoundProgram(gl, renderer) {\n            this.programs = programClasses.map(function (ProgramClass) { return new ProgramClass(gl, renderer); });\n        }\n        NodeCompoundProgram.prototype.bufferData = function () {\n            this.programs.forEach(function (program) { return program.bufferData(); });\n        };\n        NodeCompoundProgram.prototype.allocate = function (capacity) {\n            this.programs.forEach(function (program) { return program.allocate(capacity); });\n        };\n        NodeCompoundProgram.prototype.bind = function () {\n            // nothing todo, it's already done in each program constructor\n        };\n        NodeCompoundProgram.prototype.render = function (params) {\n            this.programs.forEach(function (program) {\n                program.bind();\n                program.bufferData();\n                program.render(params);\n            });\n        };\n        NodeCompoundProgram.prototype.process = function (data, hidden, offset) {\n            this.programs.forEach(function (program) { return program.process(data, hidden, offset); });\n        };\n        return NodeCompoundProgram;\n    }());\n}\nexports.createNodeCompoundProgram = createNodeCompoundProgram;\n","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils_1 = require(\"../../../utils\");\nvar node_fast_vert_glsl_1 = __importDefault(require(\"../shaders/node.fast.vert.glsl.js\"));\nvar node_fast_frag_glsl_1 = __importDefault(require(\"../shaders/node.fast.frag.glsl.js\"));\nvar node_1 = require(\"./common/node\");\nvar POINTS = 1, ATTRIBUTES = 4;\nvar NodeFastProgram = /** @class */ (function (_super) {\n    __extends(NodeFastProgram, _super);\n    function NodeFastProgram(gl) {\n        var _this = _super.call(this, gl, node_fast_vert_glsl_1.default, node_fast_frag_glsl_1.default, POINTS, ATTRIBUTES) || this;\n        _this.bind();\n        return _this;\n    }\n    NodeFastProgram.prototype.process = function (data, hidden, offset) {\n        var array = this.array;\n        var i = offset * POINTS * ATTRIBUTES;\n        if (hidden) {\n            array[i++] = 0;\n            array[i++] = 0;\n            array[i++] = 0;\n            array[i++] = 0;\n            return;\n        }\n        var color = (0, utils_1.floatColor)(data.color);\n        array[i++] = data.x;\n        array[i++] = data.y;\n        array[i++] = data.size;\n        array[i] = color;\n    };\n    NodeFastProgram.prototype.render = function (params) {\n        if (this.hasNothingToRender())\n            return;\n        var gl = this.gl;\n        var program = this.program;\n        gl.useProgram(program);\n        gl.uniform1f(this.ratioLocation, 1 / Math.sqrt(params.ratio));\n        gl.uniform1f(this.scaleLocation, params.scalingRatio);\n        gl.uniformMatrix3fv(this.matrixLocation, false, params.matrix);\n        gl.drawArrays(gl.POINTS, 0, this.array.length / ATTRIBUTES);\n    };\n    return NodeFastProgram;\n}(node_1.AbstractNodeProgram));\nexports.default = NodeFastProgram;\n","(()=>{\"use strict\";var e={d:(n,o)=>{for(var t in o)e.o(o,t)&&!e.o(n,t)&&Object.defineProperty(n,t,{enumerable:!0,get:o[t]})},o:(e,n)=>Object.prototype.hasOwnProperty.call(e,n),r:e=>{\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(e,\"__esModule\",{value:!0})}},n={};e.r(n),e.d(n,{default:()=>o});const o='attribute vec4 a_color;\\nattribute vec2 a_normal;\\nattribute vec2 a_position;\\n\\nuniform mat3 u_matrix;\\nuniform float u_sqrtZoomRatio;\\nuniform float u_correctionRatio;\\n\\nvarying vec4 v_color;\\nvarying vec2 v_normal;\\nvarying float v_thickness;\\n\\nconst float minThickness = 1.7;\\nconst float bias = 255.0 / 254.0;\\n\\nvoid main() {\\n  float normalLength = length(a_normal);\\n  vec2 unitNormal = a_normal / normalLength;\\n\\n  // We require edges to be at least `minThickness` pixels thick *on screen*\\n  // (so we need to compensate the SQRT zoom ratio):\\n  float pixelsThickness = max(normalLength, minThickness * u_sqrtZoomRatio);\\n\\n  // Then, we need to retrieve the normalized thickness of the edge in the WebGL\\n  // referential (in a ([0, 1], [0, 1]) space), using our \"magic\" correction\\n  // ratio:\\n  float webGLThickness = pixelsThickness * u_correctionRatio;\\n\\n  // Finally, we adapt the edge thickness to the \"SQRT rule\" in sigma (so that\\n  // items are not too big when zoomed in, and not too small when zoomed out).\\n  // The exact computation should be `adapted = value * zoom / sqrt(zoom)`, but\\n  // it\\'s simpler like this:\\n  float adaptedWebGLThickness = webGLThickness * u_sqrtZoomRatio;\\n\\n  // Here is the proper position of the vertex\\n  gl_Position = vec4((u_matrix * vec3(a_position + unitNormal * adaptedWebGLThickness, 1)).xy, 0, 1);\\n\\n  // For the fragment shader though, we need a thickness that takes the \"magic\"\\n  // correction ratio into account (as in webGLThickness), but so that the\\n  // antialiasint effect does not depend on the zoom level. So here\\'s yet\\n  // another thickness version:\\n  v_thickness = webGLThickness / u_sqrtZoomRatio;\\n\\n  v_normal = unitNormal;\\n  v_color = a_color;\\n  v_color.a *= bias;\\n}\\n';module.exports=n})();","(()=>{\"use strict\";var e={d:(n,t)=>{for(var o in t)e.o(t,o)&&!e.o(n,o)&&Object.defineProperty(n,o,{enumerable:!0,get:t[o]})},o:(e,n)=>Object.prototype.hasOwnProperty.call(e,n),r:e=>{\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(e,\"__esModule\",{value:!0})}},n={};e.r(n),e.d(n,{default:()=>t});const t=\"precision mediump float;\\n\\nvarying vec4 v_color;\\nvarying vec2 v_normal;\\nvarying float v_thickness;\\n\\nconst float feather = 0.001;\\nconst vec4 transparent = vec4(0.0, 0.0, 0.0, 0.0);\\n\\nvoid main(void) {\\n  float dist = length(v_normal) * v_thickness;\\n\\n  float t = smoothstep(\\n    v_thickness - feather,\\n    v_thickness,\\n    dist\\n  );\\n\\n  gl_FragColor = mix(v_color, transparent, t);\\n}\\n\";module.exports=n})();","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createEdgeCompoundProgram = exports.AbstractEdgeProgram = void 0;\n/**\n * Sigma.js WebGL Abstract Edge Program\n * =====================================\n *\n * @module\n */\nvar program_1 = require(\"./program\");\n/**\n * Edge Program class.\n *\n * @constructor\n */\nvar AbstractEdgeProgram = /** @class */ (function (_super) {\n    __extends(AbstractEdgeProgram, _super);\n    function AbstractEdgeProgram(gl, vertexShaderSource, fragmentShaderSource, points, attributes) {\n        return _super.call(this, gl, vertexShaderSource, fragmentShaderSource, points, attributes) || this;\n    }\n    return AbstractEdgeProgram;\n}(program_1.AbstractProgram));\nexports.AbstractEdgeProgram = AbstractEdgeProgram;\nfunction createEdgeCompoundProgram(programClasses) {\n    return /** @class */ (function () {\n        function EdgeCompoundProgram(gl, renderer) {\n            this.programs = programClasses.map(function (ProgramClass) { return new ProgramClass(gl, renderer); });\n        }\n        EdgeCompoundProgram.prototype.bufferData = function () {\n            this.programs.forEach(function (program) { return program.bufferData(); });\n        };\n        EdgeCompoundProgram.prototype.allocate = function (capacity) {\n            this.programs.forEach(function (program) { return program.allocate(capacity); });\n        };\n        EdgeCompoundProgram.prototype.bind = function () {\n            // nothing todo, it's already done in each program constructor\n        };\n        EdgeCompoundProgram.prototype.computeIndices = function () {\n            this.programs.forEach(function (program) { return program.computeIndices(); });\n        };\n        EdgeCompoundProgram.prototype.render = function (params) {\n            this.programs.forEach(function (program) {\n                program.bind();\n                program.bufferData();\n                program.render(params);\n            });\n        };\n        EdgeCompoundProgram.prototype.process = function (sourceData, targetData, data, hidden, offset) {\n            this.programs.forEach(function (program) { return program.process(sourceData, targetData, data, hidden, offset); });\n        };\n        return EdgeCompoundProgram;\n    }());\n}\nexports.createEdgeCompoundProgram = createEdgeCompoundProgram;\n","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Sigma.js WebGL Renderer Edge Program\n * =====================================\n *\n * Program rendering edges as thick lines using four points translated\n * orthogonally from the source & target's centers by half thickness.\n *\n * Rendering two triangles by using only four points is made possible through\n * the use of indices.\n *\n * This method should be faster than the 6 points / 2 triangles approach and\n * should handle thickness better than with gl.LINES.\n *\n * This version of the shader balances geometry computation evenly between\n * the CPU & GPU (normals are computed on the CPU side).\n * @module\n */\nvar utils_1 = require(\"../../../utils\");\nvar edge_vert_glsl_1 = __importDefault(require(\"../shaders/edge.vert.glsl.js\"));\nvar edge_frag_glsl_1 = __importDefault(require(\"../shaders/edge.frag.glsl.js\"));\nvar edge_1 = require(\"./common/edge\");\nvar POINTS = 4, ATTRIBUTES = 5, STRIDE = POINTS * ATTRIBUTES;\nvar EdgeProgram = /** @class */ (function (_super) {\n    __extends(EdgeProgram, _super);\n    function EdgeProgram(gl) {\n        var _this = _super.call(this, gl, edge_vert_glsl_1.default, edge_frag_glsl_1.default, POINTS, ATTRIBUTES) || this;\n        // Initializing indices buffer\n        var indicesBuffer = gl.createBuffer();\n        if (indicesBuffer === null)\n            throw new Error(\"EdgeProgram: error while creating indicesBuffer\");\n        _this.indicesBuffer = indicesBuffer;\n        // Locations\n        _this.positionLocation = gl.getAttribLocation(_this.program, \"a_position\");\n        _this.colorLocation = gl.getAttribLocation(_this.program, \"a_color\");\n        _this.normalLocation = gl.getAttribLocation(_this.program, \"a_normal\");\n        var matrixLocation = gl.getUniformLocation(_this.program, \"u_matrix\");\n        if (matrixLocation === null)\n            throw new Error(\"EdgeProgram: error while getting matrixLocation\");\n        _this.matrixLocation = matrixLocation;\n        var correctionRatioLocation = gl.getUniformLocation(_this.program, \"u_correctionRatio\");\n        if (correctionRatioLocation === null)\n            throw new Error(\"EdgeProgram: error while getting correctionRatioLocation\");\n        _this.correctionRatioLocation = correctionRatioLocation;\n        var sqrtZoomRatioLocation = gl.getUniformLocation(_this.program, \"u_sqrtZoomRatio\");\n        if (sqrtZoomRatioLocation === null)\n            throw new Error(\"EdgeProgram: error while getting sqrtZoomRatioLocation\");\n        _this.sqrtZoomRatioLocation = sqrtZoomRatioLocation;\n        // Enabling the OES_element_index_uint extension\n        // NOTE: on older GPUs, this means that really large graphs won't\n        // have all their edges rendered. But it seems that the\n        // `OES_element_index_uint` is quite everywhere so we'll handle\n        // the potential issue if it really arises.\n        // NOTE: when using webgl2, the extension is enabled by default\n        _this.canUse32BitsIndices = (0, utils_1.canUse32BitsIndices)(gl);\n        _this.IndicesArray = _this.canUse32BitsIndices ? Uint32Array : Uint16Array;\n        _this.indicesArray = new _this.IndicesArray();\n        _this.indicesType = _this.canUse32BitsIndices ? gl.UNSIGNED_INT : gl.UNSIGNED_SHORT;\n        _this.bind();\n        return _this;\n    }\n    EdgeProgram.prototype.bind = function () {\n        var gl = this.gl;\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indicesBuffer);\n        // Bindings\n        gl.enableVertexAttribArray(this.positionLocation);\n        gl.enableVertexAttribArray(this.normalLocation);\n        gl.enableVertexAttribArray(this.colorLocation);\n        gl.vertexAttribPointer(this.positionLocation, 2, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 0);\n        gl.vertexAttribPointer(this.normalLocation, 2, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 8);\n        gl.vertexAttribPointer(this.colorLocation, 4, gl.UNSIGNED_BYTE, true, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 16);\n    };\n    EdgeProgram.prototype.computeIndices = function () {\n        var l = this.array.length / ATTRIBUTES;\n        var size = l + l / 2;\n        var indices = new this.IndicesArray(size);\n        for (var i = 0, c = 0; i < l; i += 4) {\n            indices[c++] = i;\n            indices[c++] = i + 1;\n            indices[c++] = i + 2;\n            indices[c++] = i + 2;\n            indices[c++] = i + 1;\n            indices[c++] = i + 3;\n        }\n        this.indicesArray = indices;\n    };\n    EdgeProgram.prototype.bufferData = function () {\n        _super.prototype.bufferData.call(this);\n        // Indices data\n        var gl = this.gl;\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indicesArray, gl.STATIC_DRAW);\n    };\n    EdgeProgram.prototype.process = function (sourceData, targetData, data, hidden, offset) {\n        if (hidden) {\n            for (var i_1 = offset * STRIDE, l = i_1 + STRIDE; i_1 < l; i_1++)\n                this.array[i_1] = 0;\n            return;\n        }\n        var thickness = data.size || 1, x1 = sourceData.x, y1 = sourceData.y, x2 = targetData.x, y2 = targetData.y, color = (0, utils_1.floatColor)(data.color);\n        // Computing normals\n        var dx = x2 - x1, dy = y2 - y1;\n        var len = dx * dx + dy * dy, n1 = 0, n2 = 0;\n        if (len) {\n            len = 1 / Math.sqrt(len);\n            n1 = -dy * len * thickness;\n            n2 = dx * len * thickness;\n        }\n        var i = POINTS * ATTRIBUTES * offset;\n        var array = this.array;\n        // First point\n        array[i++] = x1;\n        array[i++] = y1;\n        array[i++] = n1;\n        array[i++] = n2;\n        array[i++] = color;\n        // First point flipped\n        array[i++] = x1;\n        array[i++] = y1;\n        array[i++] = -n1;\n        array[i++] = -n2;\n        array[i++] = color;\n        // Second point\n        array[i++] = x2;\n        array[i++] = y2;\n        array[i++] = n1;\n        array[i++] = n2;\n        array[i++] = color;\n        // Second point flipped\n        array[i++] = x2;\n        array[i++] = y2;\n        array[i++] = -n1;\n        array[i++] = -n2;\n        array[i] = color;\n    };\n    EdgeProgram.prototype.render = function (params) {\n        if (this.hasNothingToRender())\n            return;\n        var gl = this.gl;\n        var program = this.program;\n        gl.useProgram(program);\n        gl.uniformMatrix3fv(this.matrixLocation, false, params.matrix);\n        gl.uniform1f(this.sqrtZoomRatioLocation, Math.sqrt(params.ratio));\n        gl.uniform1f(this.correctionRatioLocation, params.correctionRatio);\n        // Drawing:\n        gl.drawElements(gl.TRIANGLES, this.indicesArray.length, this.indicesType, 0);\n    };\n    return EdgeProgram;\n}(edge_1.AbstractEdgeProgram));\nexports.default = EdgeProgram;\n","(()=>{\"use strict\";var a={d:(e,t)=>{for(var o in t)a.o(t,o)&&!a.o(e,o)&&Object.defineProperty(e,o,{enumerable:!0,get:t[o]})},o:(a,e)=>Object.prototype.hasOwnProperty.call(a,e),r:a=>{\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(a,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(a,\"__esModule\",{value:!0})}},e={};a.r(e),a.d(e,{default:()=>t});const t=\"attribute vec2 a_position;\\nattribute vec2 a_normal;\\nattribute float a_radius;\\nattribute vec4 a_color;\\nattribute vec3 a_barycentric;\\n\\nuniform mat3 u_matrix;\\nuniform float u_sqrtZoomRatio;\\nuniform float u_correctionRatio;\\n\\nvarying vec4 v_color;\\n\\nconst float minThickness = 1.7;\\nconst float bias = 255.0 / 254.0;\\nconst float arrowHeadWidthLengthRatio = 0.66;\\nconst float arrowHeadLengthThicknessRatio = 2.5;\\n\\nvoid main() {\\n  float normalLength = length(a_normal);\\n  vec2 unitNormal = a_normal / normalLength;\\n\\n  // These first computations are taken from edge.vert.glsl and\\n  // edge.clamped.vert.glsl. Please read it to get better comments on what's\\n  // happening:\\n  float pixelsThickness = max(normalLength, minThickness * u_sqrtZoomRatio);\\n  float webGLThickness = pixelsThickness * u_correctionRatio;\\n  float adaptedWebGLThickness = webGLThickness * u_sqrtZoomRatio;\\n  float adaptedWebGLNodeRadius = a_radius * 2.0 * u_correctionRatio * u_sqrtZoomRatio;\\n  float adaptedWebGLArrowHeadLength = adaptedWebGLThickness * 2.0 * arrowHeadLengthThicknessRatio;\\n  float adaptedWebGLArrowHeadHalfWidth = adaptedWebGLArrowHeadLength * arrowHeadWidthLengthRatio / 2.0;\\n\\n  float da = a_barycentric.x;\\n  float db = a_barycentric.y;\\n  float dc = a_barycentric.z;\\n\\n  vec2 delta = vec2(\\n      da * (adaptedWebGLNodeRadius * unitNormal.y)\\n    + db * ((adaptedWebGLNodeRadius + adaptedWebGLArrowHeadLength) * unitNormal.y + adaptedWebGLArrowHeadHalfWidth * unitNormal.x)\\n    + dc * ((adaptedWebGLNodeRadius + adaptedWebGLArrowHeadLength) * unitNormal.y - adaptedWebGLArrowHeadHalfWidth * unitNormal.x),\\n\\n      da * (-adaptedWebGLNodeRadius * unitNormal.x)\\n    + db * (-(adaptedWebGLNodeRadius + adaptedWebGLArrowHeadLength) * unitNormal.x + adaptedWebGLArrowHeadHalfWidth * unitNormal.y)\\n    + dc * (-(adaptedWebGLNodeRadius + adaptedWebGLArrowHeadLength) * unitNormal.x - adaptedWebGLArrowHeadHalfWidth * unitNormal.y)\\n  );\\n\\n  vec2 position = (u_matrix * vec3(a_position + delta, 1)).xy;\\n\\n  gl_Position = vec4(position, 0, 1);\\n\\n  // Extract the color:\\n  v_color = a_color;\\n  v_color.a *= bias;\\n}\\n\";module.exports=e})();","(()=>{\"use strict\";var e={d:(o,r)=>{for(var t in r)e.o(r,t)&&!e.o(o,t)&&Object.defineProperty(o,t,{enumerable:!0,get:r[t]})},o:(e,o)=>Object.prototype.hasOwnProperty.call(e,o),r:e=>{\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(e,\"__esModule\",{value:!0})}},o={};e.r(o),e.d(o,{default:()=>r});const r=\"precision mediump float;\\n\\nvarying vec4 v_color;\\n\\nvoid main(void) {\\n  gl_FragColor = v_color;\\n}\\n\";module.exports=o})();","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils_1 = require(\"../../../utils\");\nvar edge_arrowHead_vert_glsl_1 = __importDefault(require(\"../shaders/edge.arrowHead.vert.glsl.js\"));\nvar edge_arrowHead_frag_glsl_1 = __importDefault(require(\"../shaders/edge.arrowHead.frag.glsl.js\"));\nvar edge_1 = require(\"./common/edge\");\nvar POINTS = 3, ATTRIBUTES = 9, STRIDE = POINTS * ATTRIBUTES;\nvar EdgeArrowHeadProgram = /** @class */ (function (_super) {\n    __extends(EdgeArrowHeadProgram, _super);\n    function EdgeArrowHeadProgram(gl) {\n        var _this = _super.call(this, gl, edge_arrowHead_vert_glsl_1.default, edge_arrowHead_frag_glsl_1.default, POINTS, ATTRIBUTES) || this;\n        // Locations\n        _this.positionLocation = gl.getAttribLocation(_this.program, \"a_position\");\n        _this.colorLocation = gl.getAttribLocation(_this.program, \"a_color\");\n        _this.normalLocation = gl.getAttribLocation(_this.program, \"a_normal\");\n        _this.radiusLocation = gl.getAttribLocation(_this.program, \"a_radius\");\n        _this.barycentricLocation = gl.getAttribLocation(_this.program, \"a_barycentric\");\n        // Uniform locations\n        var matrixLocation = gl.getUniformLocation(_this.program, \"u_matrix\");\n        if (matrixLocation === null)\n            throw new Error(\"EdgeArrowHeadProgram: error while getting matrixLocation\");\n        _this.matrixLocation = matrixLocation;\n        var sqrtZoomRatioLocation = gl.getUniformLocation(_this.program, \"u_sqrtZoomRatio\");\n        if (sqrtZoomRatioLocation === null)\n            throw new Error(\"EdgeArrowHeadProgram: error while getting sqrtZoomRatioLocation\");\n        _this.sqrtZoomRatioLocation = sqrtZoomRatioLocation;\n        var correctionRatioLocation = gl.getUniformLocation(_this.program, \"u_correctionRatio\");\n        if (correctionRatioLocation === null)\n            throw new Error(\"EdgeArrowHeadProgram: error while getting correctionRatioLocation\");\n        _this.correctionRatioLocation = correctionRatioLocation;\n        _this.bind();\n        return _this;\n    }\n    EdgeArrowHeadProgram.prototype.bind = function () {\n        var gl = this.gl;\n        // Bindings\n        gl.enableVertexAttribArray(this.positionLocation);\n        gl.enableVertexAttribArray(this.normalLocation);\n        gl.enableVertexAttribArray(this.radiusLocation);\n        gl.enableVertexAttribArray(this.colorLocation);\n        gl.enableVertexAttribArray(this.barycentricLocation);\n        gl.vertexAttribPointer(this.positionLocation, 2, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 0);\n        gl.vertexAttribPointer(this.normalLocation, 2, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 8);\n        gl.vertexAttribPointer(this.radiusLocation, 1, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 16);\n        gl.vertexAttribPointer(this.colorLocation, 4, gl.UNSIGNED_BYTE, true, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 20);\n        // TODO: maybe we can optimize here by packing this in a bit mask\n        gl.vertexAttribPointer(this.barycentricLocation, 3, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 24);\n    };\n    EdgeArrowHeadProgram.prototype.computeIndices = function () {\n        // nothing to do\n    };\n    EdgeArrowHeadProgram.prototype.process = function (sourceData, targetData, data, hidden, offset) {\n        if (hidden) {\n            for (var i_1 = offset * STRIDE, l = i_1 + STRIDE; i_1 < l; i_1++)\n                this.array[i_1] = 0;\n            return;\n        }\n        var thickness = data.size || 1, radius = targetData.size || 1, x1 = sourceData.x, y1 = sourceData.y, x2 = targetData.x, y2 = targetData.y, color = (0, utils_1.floatColor)(data.color);\n        // Computing normals\n        var dx = x2 - x1, dy = y2 - y1;\n        var len = dx * dx + dy * dy, n1 = 0, n2 = 0;\n        if (len) {\n            len = 1 / Math.sqrt(len);\n            n1 = -dy * len * thickness;\n            n2 = dx * len * thickness;\n        }\n        var i = POINTS * ATTRIBUTES * offset;\n        var array = this.array;\n        // First point\n        array[i++] = x2;\n        array[i++] = y2;\n        array[i++] = -n1;\n        array[i++] = -n2;\n        array[i++] = radius;\n        array[i++] = color;\n        array[i++] = 1;\n        array[i++] = 0;\n        array[i++] = 0;\n        // Second point\n        array[i++] = x2;\n        array[i++] = y2;\n        array[i++] = -n1;\n        array[i++] = -n2;\n        array[i++] = radius;\n        array[i++] = color;\n        array[i++] = 0;\n        array[i++] = 1;\n        array[i++] = 0;\n        // Third point\n        array[i++] = x2;\n        array[i++] = y2;\n        array[i++] = -n1;\n        array[i++] = -n2;\n        array[i++] = radius;\n        array[i++] = color;\n        array[i++] = 0;\n        array[i++] = 0;\n        array[i] = 1;\n    };\n    EdgeArrowHeadProgram.prototype.render = function (params) {\n        if (this.hasNothingToRender())\n            return;\n        var gl = this.gl;\n        var program = this.program;\n        gl.useProgram(program);\n        // Binding uniforms\n        gl.uniformMatrix3fv(this.matrixLocation, false, params.matrix);\n        gl.uniform1f(this.sqrtZoomRatioLocation, Math.sqrt(params.ratio));\n        gl.uniform1f(this.correctionRatioLocation, params.correctionRatio);\n        // Drawing:\n        gl.drawArrays(gl.TRIANGLES, 0, this.array.length / ATTRIBUTES);\n    };\n    return EdgeArrowHeadProgram;\n}(edge_1.AbstractEdgeProgram));\nexports.default = EdgeArrowHeadProgram;\n","(()=>{\"use strict\";var e={d:(o,n)=>{for(var t in n)e.o(n,t)&&!e.o(o,t)&&Object.defineProperty(o,t,{enumerable:!0,get:n[t]})},o:(e,o)=>Object.prototype.hasOwnProperty.call(e,o),r:e=>{\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(e,\"__esModule\",{value:!0})}},o={};e.r(o),e.d(o,{default:()=>n});const n=\"attribute vec4 a_color;\\nattribute vec2 a_normal;\\nattribute vec2 a_position;\\nattribute float a_radius;\\n\\nuniform mat3 u_matrix;\\nuniform float u_sqrtZoomRatio;\\nuniform float u_correctionRatio;\\n\\nvarying vec4 v_color;\\nvarying vec2 v_normal;\\nvarying float v_thickness;\\n\\nconst float minThickness = 1.7;\\nconst float bias = 255.0 / 254.0;\\nconst float arrowHeadLengthThicknessRatio = 2.5;\\n\\nvoid main() {\\n  float normalLength = length(a_normal);\\n  vec2 unitNormal = a_normal / normalLength;\\n\\n  // These first computations are taken from edge.vert.glsl. Please read it to\\n  // get better comments on what's happening:\\n  float pixelsThickness = max(normalLength, minThickness * u_sqrtZoomRatio);\\n  float webGLThickness = pixelsThickness * u_correctionRatio;\\n  float adaptedWebGLThickness = webGLThickness * u_sqrtZoomRatio;\\n\\n  // Here, we move the point to leave space for the arrow head:\\n  float direction = sign(a_radius);\\n  float adaptedWebGLNodeRadius = direction * a_radius * 2.0 * u_correctionRatio * u_sqrtZoomRatio;\\n  float adaptedWebGLArrowHeadLength = adaptedWebGLThickness * 2.0 * arrowHeadLengthThicknessRatio;\\n\\n  vec2 compensationVector = vec2(-direction * unitNormal.y, direction * unitNormal.x) * (adaptedWebGLNodeRadius + adaptedWebGLArrowHeadLength);\\n\\n  // Here is the proper position of the vertex\\n  gl_Position = vec4((u_matrix * vec3(a_position + unitNormal * adaptedWebGLThickness + compensationVector, 1)).xy, 0, 1);\\n\\n  v_thickness = webGLThickness / u_sqrtZoomRatio;\\n\\n  v_normal = unitNormal;\\n  v_color = a_color;\\n  v_color.a *= bias;\\n}\\n\";module.exports=o})();","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar edge_1 = require(\"./common/edge\");\nvar utils_1 = require(\"../../../utils\");\nvar edge_clamped_vert_glsl_1 = __importDefault(require(\"../shaders/edge.clamped.vert.glsl.js\"));\nvar edge_frag_glsl_1 = __importDefault(require(\"../shaders/edge.frag.glsl.js\"));\nvar POINTS = 4, ATTRIBUTES = 6, STRIDE = POINTS * ATTRIBUTES;\nvar EdgeClampedProgram = /** @class */ (function (_super) {\n    __extends(EdgeClampedProgram, _super);\n    function EdgeClampedProgram(gl) {\n        var _this = _super.call(this, gl, edge_clamped_vert_glsl_1.default, edge_frag_glsl_1.default, POINTS, ATTRIBUTES) || this;\n        // Initializing indices buffer\n        var indicesBuffer = gl.createBuffer();\n        if (indicesBuffer === null)\n            throw new Error(\"EdgeClampedProgram: error while getting resolutionLocation\");\n        _this.indicesBuffer = indicesBuffer;\n        // Locations:\n        _this.positionLocation = gl.getAttribLocation(_this.program, \"a_position\");\n        _this.colorLocation = gl.getAttribLocation(_this.program, \"a_color\");\n        _this.normalLocation = gl.getAttribLocation(_this.program, \"a_normal\");\n        _this.radiusLocation = gl.getAttribLocation(_this.program, \"a_radius\");\n        // Uniform locations\n        var matrixLocation = gl.getUniformLocation(_this.program, \"u_matrix\");\n        if (matrixLocation === null)\n            throw new Error(\"EdgeClampedProgram: error while getting matrixLocation\");\n        _this.matrixLocation = matrixLocation;\n        var sqrtZoomRatioLocation = gl.getUniformLocation(_this.program, \"u_sqrtZoomRatio\");\n        if (sqrtZoomRatioLocation === null)\n            throw new Error(\"EdgeClampedProgram: error while getting cameraRatioLocation\");\n        _this.sqrtZoomRatioLocation = sqrtZoomRatioLocation;\n        var correctionRatioLocation = gl.getUniformLocation(_this.program, \"u_correctionRatio\");\n        if (correctionRatioLocation === null)\n            throw new Error(\"EdgeClampedProgram: error while getting viewportRatioLocation\");\n        _this.correctionRatioLocation = correctionRatioLocation;\n        // Enabling the OES_element_index_uint extension\n        // NOTE: on older GPUs, this means that really large graphs won't\n        // have all their edges rendered. But it seems that the\n        // `OES_element_index_uint` is quite everywhere so we'll handle\n        // the potential issue if it really arises.\n        // NOTE: when using webgl2, the extension is enabled by default\n        _this.canUse32BitsIndices = (0, utils_1.canUse32BitsIndices)(gl);\n        _this.IndicesArray = _this.canUse32BitsIndices ? Uint32Array : Uint16Array;\n        _this.indicesArray = new _this.IndicesArray();\n        _this.indicesType = _this.canUse32BitsIndices ? gl.UNSIGNED_INT : gl.UNSIGNED_SHORT;\n        _this.bind();\n        return _this;\n    }\n    EdgeClampedProgram.prototype.bind = function () {\n        var gl = this.gl;\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indicesBuffer);\n        // Bindings\n        gl.enableVertexAttribArray(this.positionLocation);\n        gl.enableVertexAttribArray(this.normalLocation);\n        gl.enableVertexAttribArray(this.colorLocation);\n        gl.enableVertexAttribArray(this.radiusLocation);\n        gl.vertexAttribPointer(this.positionLocation, 2, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 0);\n        gl.vertexAttribPointer(this.normalLocation, 2, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 8);\n        gl.vertexAttribPointer(this.colorLocation, 4, gl.UNSIGNED_BYTE, true, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 16);\n        gl.vertexAttribPointer(this.radiusLocation, 1, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 20);\n    };\n    EdgeClampedProgram.prototype.process = function (sourceData, targetData, data, hidden, offset) {\n        if (hidden) {\n            for (var i_1 = offset * STRIDE, l = i_1 + STRIDE; i_1 < l; i_1++)\n                this.array[i_1] = 0;\n            return;\n        }\n        var thickness = data.size || 1, x1 = sourceData.x, y1 = sourceData.y, x2 = targetData.x, y2 = targetData.y, radius = targetData.size || 1, color = (0, utils_1.floatColor)(data.color);\n        // Computing normals\n        var dx = x2 - x1, dy = y2 - y1;\n        var len = dx * dx + dy * dy, n1 = 0, n2 = 0;\n        if (len) {\n            len = 1 / Math.sqrt(len);\n            n1 = -dy * len * thickness;\n            n2 = dx * len * thickness;\n        }\n        var i = POINTS * ATTRIBUTES * offset;\n        var array = this.array;\n        // First point\n        array[i++] = x1;\n        array[i++] = y1;\n        array[i++] = n1;\n        array[i++] = n2;\n        array[i++] = color;\n        array[i++] = 0;\n        // First point flipped\n        array[i++] = x1;\n        array[i++] = y1;\n        array[i++] = -n1;\n        array[i++] = -n2;\n        array[i++] = color;\n        array[i++] = 0;\n        // Second point\n        array[i++] = x2;\n        array[i++] = y2;\n        array[i++] = n1;\n        array[i++] = n2;\n        array[i++] = color;\n        array[i++] = radius;\n        // Second point flipped\n        array[i++] = x2;\n        array[i++] = y2;\n        array[i++] = -n1;\n        array[i++] = -n2;\n        array[i++] = color;\n        array[i] = -radius;\n    };\n    EdgeClampedProgram.prototype.computeIndices = function () {\n        var l = this.array.length / ATTRIBUTES;\n        var size = l + l / 2;\n        var indices = new this.IndicesArray(size);\n        for (var i = 0, c = 0; i < l; i += 4) {\n            indices[c++] = i;\n            indices[c++] = i + 1;\n            indices[c++] = i + 2;\n            indices[c++] = i + 2;\n            indices[c++] = i + 1;\n            indices[c++] = i + 3;\n        }\n        this.indicesArray = indices;\n    };\n    EdgeClampedProgram.prototype.bufferData = function () {\n        _super.prototype.bufferData.call(this);\n        // Indices data\n        var gl = this.gl;\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indicesArray, gl.STATIC_DRAW);\n    };\n    EdgeClampedProgram.prototype.render = function (params) {\n        if (this.hasNothingToRender())\n            return;\n        var gl = this.gl;\n        var program = this.program;\n        gl.useProgram(program);\n        // Binding uniforms\n        gl.uniformMatrix3fv(this.matrixLocation, false, params.matrix);\n        gl.uniform1f(this.sqrtZoomRatioLocation, Math.sqrt(params.ratio));\n        gl.uniform1f(this.correctionRatioLocation, params.correctionRatio);\n        // Drawing:\n        gl.drawElements(gl.TRIANGLES, this.indicesArray.length, this.indicesType, 0);\n    };\n    return EdgeClampedProgram;\n}(edge_1.AbstractEdgeProgram));\nexports.default = EdgeClampedProgram;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Sigma.js WebGL Renderer Edge Arrow Program\n * ===========================================\n *\n * Compound program rendering edges as an arrow from the source to the target.\n * @module\n */\nvar edge_1 = require(\"./common/edge\");\nvar edge_arrowHead_1 = __importDefault(require(\"./edge.arrowHead\"));\nvar edge_clamped_1 = __importDefault(require(\"./edge.clamped\"));\nvar EdgeArrowProgram = (0, edge_1.createEdgeCompoundProgram)([edge_clamped_1.default, edge_arrowHead_1.default]);\nexports.default = EdgeArrowProgram;\n","\"use strict\";\n/**\n * Sigma.js Settings\n * =================================\n *\n * The list of settings and some handy functions.\n * @module\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DEFAULT_SETTINGS = exports.validateSettings = void 0;\nvar label_1 = __importDefault(require(\"./rendering/canvas/label\"));\nvar hover_1 = __importDefault(require(\"./rendering/canvas/hover\"));\nvar edge_label_1 = __importDefault(require(\"./rendering/canvas/edge-label\"));\nvar node_fast_1 = __importDefault(require(\"./rendering/webgl/programs/node.fast\"));\nvar edge_1 = __importDefault(require(\"./rendering/webgl/programs/edge\"));\nvar edge_arrow_1 = __importDefault(require(\"./rendering/webgl/programs/edge.arrow\"));\nfunction validateSettings(settings) {\n    if (typeof settings.labelDensity !== \"number\" || settings.labelDensity < 0) {\n        throw new Error(\"Settings: invalid `labelDensity`. Expecting a positive number.\");\n    }\n    var minCameraRatio = settings.minCameraRatio, maxCameraRatio = settings.maxCameraRatio;\n    if (typeof minCameraRatio === \"number\" && typeof maxCameraRatio === \"number\" && maxCameraRatio < minCameraRatio) {\n        throw new Error(\"Settings: invalid camera ratio boundaries. Expecting `maxCameraRatio` to be greater than `minCameraRatio`.\");\n    }\n}\nexports.validateSettings = validateSettings;\nexports.DEFAULT_SETTINGS = {\n    // Performance\n    hideEdgesOnMove: false,\n    hideLabelsOnMove: false,\n    renderLabels: true,\n    renderEdgeLabels: false,\n    enableEdgeClickEvents: false,\n    enableEdgeWheelEvents: false,\n    enableEdgeHoverEvents: false,\n    // Component rendering\n    defaultNodeColor: \"#999\",\n    defaultNodeType: \"circle\",\n    defaultEdgeColor: \"#ccc\",\n    defaultEdgeType: \"line\",\n    labelFont: \"Arial\",\n    labelSize: 14,\n    labelWeight: \"normal\",\n    labelColor: { color: \"#000\" },\n    edgeLabelFont: \"Arial\",\n    edgeLabelSize: 14,\n    edgeLabelWeight: \"normal\",\n    edgeLabelColor: { attribute: \"color\" },\n    stagePadding: 30,\n    // Labels\n    labelDensity: 1,\n    labelGridCellSize: 100,\n    labelRenderedSizeThreshold: 6,\n    // Reducers\n    nodeReducer: null,\n    edgeReducer: null,\n    // Features\n    zIndex: false,\n    minCameraRatio: null,\n    maxCameraRatio: null,\n    // Renderers\n    labelRenderer: label_1.default,\n    hoverRenderer: hover_1.default,\n    edgeLabelRenderer: edge_label_1.default,\n    // Lifecycle\n    allowInvalidContainer: false,\n    // Program classes\n    nodeProgramClasses: {\n        circle: node_fast_1.default,\n    },\n    edgeProgramClasses: {\n        arrow: edge_arrow_1.default,\n        line: edge_1.default,\n    },\n};\n","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar captor_1 = __importStar(require(\"./captor\"));\nvar DRAG_TIMEOUT = 200;\nvar TOUCH_INERTIA_RATIO = 3;\nvar TOUCH_INERTIA_DURATION = 200;\n/**\n * Touch captor class.\n *\n * @constructor\n */\nvar TouchCaptor = /** @class */ (function (_super) {\n    __extends(TouchCaptor, _super);\n    function TouchCaptor(container, renderer) {\n        var _this = _super.call(this, container, renderer) || this;\n        _this.enabled = true;\n        _this.isMoving = false;\n        _this.touchMode = 0; // number of touches down\n        // Binding methods:\n        _this.handleStart = _this.handleStart.bind(_this);\n        _this.handleLeave = _this.handleLeave.bind(_this);\n        _this.handleMove = _this.handleMove.bind(_this);\n        // Binding events\n        container.addEventListener(\"touchstart\", _this.handleStart, false);\n        container.addEventListener(\"touchend\", _this.handleLeave, false);\n        container.addEventListener(\"touchcancel\", _this.handleLeave, false);\n        container.addEventListener(\"touchmove\", _this.handleMove, false);\n        return _this;\n    }\n    TouchCaptor.prototype.kill = function () {\n        var container = this.container;\n        container.removeEventListener(\"touchstart\", this.handleStart);\n        container.removeEventListener(\"touchend\", this.handleLeave);\n        container.removeEventListener(\"touchcancel\", this.handleLeave);\n        container.removeEventListener(\"touchmove\", this.handleMove);\n    };\n    TouchCaptor.prototype.getDimensions = function () {\n        return {\n            width: this.container.offsetWidth,\n            height: this.container.offsetHeight,\n        };\n    };\n    TouchCaptor.prototype.dispatchRelatedMouseEvent = function (type, e, position, emitter) {\n        var mousePosition = position || (0, captor_1.getPosition)(e.touches[0], this.container);\n        var mouseEvent = new MouseEvent(type, {\n            clientX: mousePosition.x,\n            clientY: mousePosition.y,\n            altKey: e.altKey,\n            ctrlKey: e.ctrlKey,\n        });\n        mouseEvent.isFakeSigmaMouseEvent = true;\n        (emitter || this.container).dispatchEvent(mouseEvent);\n    };\n    TouchCaptor.prototype.handleStart = function (e) {\n        var _this = this;\n        if (!this.enabled)\n            return;\n        // Prevent default to avoid default browser behaviors...\n        e.preventDefault();\n        // ...but simulate mouse behavior anyway, to get the MouseCaptor working as well:\n        if (e.touches.length === 1)\n            this.dispatchRelatedMouseEvent(\"mousedown\", e);\n        var touches = (0, captor_1.getTouchesArray)(e.touches);\n        this.isMoving = true;\n        this.touchMode = touches.length;\n        this.startCameraState = this.renderer.getCamera().getState();\n        this.startTouchesPositions = touches.map(function (touch) { return (0, captor_1.getPosition)(touch, _this.container); });\n        this.lastTouchesPositions = this.startTouchesPositions;\n        // When there are two touches down, let's record distance and angle as well:\n        if (this.touchMode === 2) {\n            var _a = __read(this.startTouchesPositions, 2), _b = _a[0], x0 = _b.x, y0 = _b.y, _c = _a[1], x1 = _c.x, y1 = _c.y;\n            this.startTouchesAngle = Math.atan2(y1 - y0, x1 - x0);\n            this.startTouchesDistance = Math.sqrt(Math.pow(x1 - x0, 2) + Math.pow(y1 - y0, 2));\n        }\n        this.emit(\"touchdown\", (0, captor_1.getTouchCoords)(e, this.container));\n    };\n    TouchCaptor.prototype.handleLeave = function (e) {\n        if (!this.enabled)\n            return;\n        // Prevent default to avoid default browser behaviors...\n        e.preventDefault();\n        // ...but simulate mouse behavior anyway, to get the MouseCaptor working as well:\n        if (e.touches.length === 0 && this.lastTouchesPositions && this.lastTouchesPositions.length) {\n            this.dispatchRelatedMouseEvent(\"mouseup\", e, this.lastTouchesPositions[0], document);\n            this.dispatchRelatedMouseEvent(\"click\", e, this.lastTouchesPositions[0]);\n        }\n        if (this.movingTimeout) {\n            this.isMoving = false;\n            clearTimeout(this.movingTimeout);\n        }\n        switch (this.touchMode) {\n            case 2:\n                if (e.touches.length === 1) {\n                    this.handleStart(e);\n                    e.preventDefault();\n                    break;\n                }\n            /* falls through */\n            case 1:\n                // TODO\n                // Dispatch event\n                if (this.isMoving) {\n                    var camera = this.renderer.getCamera();\n                    var cameraState = camera.getState(), previousCameraState = camera.getPreviousState() || { x: 0, y: 0 };\n                    camera.animate({\n                        x: cameraState.x + TOUCH_INERTIA_RATIO * (cameraState.x - previousCameraState.x),\n                        y: cameraState.y + TOUCH_INERTIA_RATIO * (cameraState.y - previousCameraState.y),\n                    }, {\n                        duration: TOUCH_INERTIA_DURATION,\n                        easing: \"quadraticOut\",\n                    });\n                }\n                this.isMoving = false;\n                this.touchMode = 0;\n                break;\n        }\n        this.emit(\"touchup\", (0, captor_1.getTouchCoords)(e, this.container));\n    };\n    TouchCaptor.prototype.handleMove = function (e) {\n        var _a;\n        var _this = this;\n        if (!this.enabled)\n            return;\n        // Prevent default to avoid default browser behaviors...\n        e.preventDefault();\n        // ...but simulate mouse behavior anyway, to get the MouseCaptor working as well:\n        if (e.touches.length === 1)\n            this.dispatchRelatedMouseEvent(\"mousemove\", e);\n        var camera = this.renderer.getCamera();\n        var startCameraState = this.startCameraState;\n        var touches = (0, captor_1.getTouchesArray)(e.touches);\n        var touchesPositions = touches.map(function (touch) { return (0, captor_1.getPosition)(touch, _this.container); });\n        this.lastTouchesPositions = touchesPositions;\n        this.isMoving = true;\n        if (this.movingTimeout)\n            clearTimeout(this.movingTimeout);\n        this.movingTimeout = window.setTimeout(function () {\n            _this.isMoving = false;\n        }, DRAG_TIMEOUT);\n        switch (this.touchMode) {\n            case 1: {\n                var _b = this.renderer.viewportToFramedGraph((this.startTouchesPositions || [])[0]), xStart = _b.x, yStart = _b.y;\n                var _c = this.renderer.viewportToFramedGraph(touchesPositions[0]), x = _c.x, y = _c.y;\n                camera.setState({\n                    x: startCameraState.x + xStart - x,\n                    y: startCameraState.y + yStart - y,\n                });\n                break;\n            }\n            case 2: {\n                /**\n                 * Here is the thinking here:\n                 *\n                 * 1. We can find the new angle and ratio, by comparing the vector from \"touch one\" to \"touch two\" at the start\n                 *    of the d'n'd and now\n                 *\n                 * 2. We can use `Camera#viewportToGraph` inside formula to retrieve the new camera position, using the graph\n                 *    position of a touch at the beginning of the d'n'd (using `startCamera.viewportToGraph`) and the viewport\n                 *    position of this same touch now\n                 */\n                var newCameraState = {};\n                var _d = touchesPositions[0], x0 = _d.x, y0 = _d.y;\n                var _e = touchesPositions[1], x1 = _e.x, y1 = _e.y;\n                var angleDiff = Math.atan2(y1 - y0, x1 - x0) - this.startTouchesAngle;\n                var ratioDiff = Math.hypot(y1 - y0, x1 - x0) / this.startTouchesDistance;\n                // 1.\n                var newRatio = camera.getBoundedRatio(startCameraState.ratio / ratioDiff);\n                newCameraState.ratio = newRatio;\n                newCameraState.angle = startCameraState.angle + angleDiff;\n                // 2.\n                var dimensions = this.getDimensions();\n                var touchGraphPosition = this.renderer.viewportToFramedGraph((this.startTouchesPositions || [])[0], { cameraState: startCameraState });\n                var smallestDimension = Math.min(dimensions.width, dimensions.height);\n                var dx = smallestDimension / dimensions.width;\n                var dy = smallestDimension / dimensions.height;\n                var ratio = newRatio / smallestDimension;\n                // Align with center of the graph:\n                var x = x0 - smallestDimension / 2 / dx;\n                var y = y0 - smallestDimension / 2 / dy;\n                // Rotate:\n                _a = __read([\n                    x * Math.cos(-newCameraState.angle) - y * Math.sin(-newCameraState.angle),\n                    y * Math.cos(-newCameraState.angle) + x * Math.sin(-newCameraState.angle),\n                ], 2), x = _a[0], y = _a[1];\n                newCameraState.x = touchGraphPosition.x - x * ratio;\n                newCameraState.y = touchGraphPosition.y + y * ratio;\n                camera.setState(newCameraState);\n                break;\n            }\n        }\n        this.emit(\"touchmove\", (0, captor_1.getTouchCoords)(e, this.container));\n    };\n    return TouchCaptor;\n}(captor_1.default));\nexports.default = TouchCaptor;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.doEdgeCollideWithPoint = exports.isPixelColored = void 0;\n/**\n * This helper returns true is the pixel at (x,y) in the given WebGL context is\n * colored, and false else.\n */\nfunction isPixelColored(gl, x, y) {\n    var pixels = new Uint8Array(4);\n    gl.readPixels(x, gl.drawingBufferHeight - y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixels);\n    return pixels[3] > 0;\n}\nexports.isPixelColored = isPixelColored;\n/**\n * This helper checks whether or not a point (x, y) collides with an\n * edge, connecting a source (xS, yS) to a target (xT, yT) with a thickness in\n * pixels.\n */\nfunction doEdgeCollideWithPoint(x, y, xS, yS, xT, yT, thickness) {\n    // Check first if point is out of the rectangle which opposite corners are the\n    // source and the target, rectangle we expand by `thickness` in every\n    // directions:\n    if (x < xS - thickness && x < xT - thickness)\n        return false;\n    if (y < yS - thickness && y < yT - thickness)\n        return false;\n    if (x > xS + thickness && x > xT + thickness)\n        return false;\n    if (y > yS + thickness && y > yT + thickness)\n        return false;\n    // Check actual collision now: Since we now the point is in this big rectangle\n    // we \"just\" need to check that the distance between the point and the line\n    // connecting the source and the target is less than `thickness`:\n    // https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line\n    var distance = Math.abs((xT - xS) * (yS - y) - (xS - x) * (yT - yS)) / Math.sqrt(Math.pow(xT - xS, 2) + Math.pow(yT - yS, 2));\n    return distance < thickness / 2;\n}\nexports.doEdgeCollideWithPoint = doEdgeCollideWithPoint;\n","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar camera_1 = __importDefault(require(\"./core/camera\"));\nvar mouse_1 = __importDefault(require(\"./core/captors/mouse\"));\nvar quadtree_1 = __importDefault(require(\"./core/quadtree\"));\nvar types_1 = require(\"./types\");\nvar utils_1 = require(\"./utils\");\nvar labels_1 = require(\"./core/labels\");\nvar settings_1 = require(\"./settings\");\nvar touch_1 = __importDefault(require(\"./core/captors/touch\"));\nvar matrices_1 = require(\"./utils/matrices\");\nvar edge_collisions_1 = require(\"./utils/edge-collisions\");\n/**\n * Important functions.\n */\nfunction applyNodeDefaults(settings, key, data) {\n    if (!data.hasOwnProperty(\"x\") || !data.hasOwnProperty(\"y\"))\n        throw new Error(\"Sigma: could not find a valid position (x, y) for node \\\"\".concat(key, \"\\\". All your nodes must have a number \\\"x\\\" and \\\"y\\\". Maybe your forgot to apply a layout or your \\\"nodeReducer\\\" is not returning the correct data?\"));\n    if (!data.color)\n        data.color = settings.defaultNodeColor;\n    if (!data.label && data.label !== \"\")\n        data.label = null;\n    if (data.label !== undefined && data.label !== null)\n        data.label = \"\" + data.label;\n    else\n        data.label = null;\n    if (!data.size)\n        data.size = 2;\n    if (!data.hasOwnProperty(\"hidden\"))\n        data.hidden = false;\n    if (!data.hasOwnProperty(\"highlighted\"))\n        data.highlighted = false;\n    if (!data.hasOwnProperty(\"forceLabel\"))\n        data.forceLabel = false;\n    if (!data.type || data.type === \"\")\n        data.type = settings.defaultNodeType;\n    if (!data.zIndex)\n        data.zIndex = 0;\n    return data;\n}\nfunction applyEdgeDefaults(settings, key, data) {\n    if (!data.color)\n        data.color = settings.defaultEdgeColor;\n    if (!data.label)\n        data.label = \"\";\n    if (!data.size)\n        data.size = 0.5;\n    if (!data.hasOwnProperty(\"hidden\"))\n        data.hidden = false;\n    if (!data.hasOwnProperty(\"forceLabel\"))\n        data.forceLabel = false;\n    if (!data.type || data.type === \"\")\n        data.type = settings.defaultEdgeType;\n    if (!data.zIndex)\n        data.zIndex = 0;\n    return data;\n}\n/**\n * Main class.\n *\n * @constructor\n * @param {Graph}       graph     - Graph to render.\n * @param {HTMLElement} container - DOM container in which to render.\n * @param {object}      settings  - Optional settings.\n */\nvar Sigma = /** @class */ (function (_super) {\n    __extends(Sigma, _super);\n    function Sigma(graph, container, settings) {\n        if (settings === void 0) { settings = {}; }\n        var _this = _super.call(this) || this;\n        _this.elements = {};\n        _this.canvasContexts = {};\n        _this.webGLContexts = {};\n        _this.activeListeners = {};\n        _this.quadtree = new quadtree_1.default();\n        _this.labelGrid = new labels_1.LabelGrid();\n        _this.nodeDataCache = {};\n        _this.edgeDataCache = {};\n        _this.nodesWithForcedLabels = [];\n        _this.edgesWithForcedLabels = [];\n        _this.nodeExtent = { x: [0, 1], y: [0, 1] };\n        _this.matrix = (0, matrices_1.identity)();\n        _this.invMatrix = (0, matrices_1.identity)();\n        _this.correctionRatio = 1;\n        _this.customBBox = null;\n        _this.normalizationFunction = (0, utils_1.createNormalizationFunction)({\n            x: [0, 1],\n            y: [0, 1],\n        });\n        // Cache:\n        _this.cameraSizeRatio = 1;\n        // Starting dimensions and pixel ratio\n        _this.width = 0;\n        _this.height = 0;\n        _this.pixelRatio = (0, utils_1.getPixelRatio)();\n        // State\n        _this.displayedLabels = new Set();\n        _this.highlightedNodes = new Set();\n        _this.hoveredNode = null;\n        _this.hoveredEdge = null;\n        _this.renderFrame = null;\n        _this.renderHighlightedNodesFrame = null;\n        _this.needToProcess = false;\n        _this.needToSoftProcess = false;\n        _this.checkEdgesEventsFrame = null;\n        // Programs\n        _this.nodePrograms = {};\n        _this.hoverNodePrograms = {};\n        _this.edgePrograms = {};\n        _this.settings = (0, utils_1.assign)({}, settings_1.DEFAULT_SETTINGS, settings);\n        // Validating\n        (0, settings_1.validateSettings)(_this.settings);\n        (0, utils_1.validateGraph)(graph);\n        if (!(container instanceof HTMLElement))\n            throw new Error(\"Sigma: container should be an html element.\");\n        // Properties\n        _this.graph = graph;\n        _this.container = container;\n        // Initializing contexts\n        _this.createWebGLContext(\"edges\", { preserveDrawingBuffer: true });\n        _this.createCanvasContext(\"edgeLabels\");\n        _this.createWebGLContext(\"nodes\");\n        _this.createCanvasContext(\"labels\");\n        _this.createCanvasContext(\"hovers\");\n        _this.createWebGLContext(\"hoverNodes\");\n        _this.createCanvasContext(\"mouse\");\n        // Blending\n        for (var key in _this.webGLContexts) {\n            var gl = _this.webGLContexts[key];\n            gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n            gl.enable(gl.BLEND);\n        }\n        // Loading programs\n        for (var type in _this.settings.nodeProgramClasses) {\n            var NodeProgramClass = _this.settings.nodeProgramClasses[type];\n            _this.nodePrograms[type] = new NodeProgramClass(_this.webGLContexts.nodes, _this);\n            _this.hoverNodePrograms[type] = new NodeProgramClass(_this.webGLContexts.hoverNodes, _this);\n        }\n        for (var type in _this.settings.edgeProgramClasses) {\n            var EdgeProgramClass = _this.settings.edgeProgramClasses[type];\n            _this.edgePrograms[type] = new EdgeProgramClass(_this.webGLContexts.edges, _this);\n        }\n        // Initial resize\n        _this.resize();\n        // Initializing the camera\n        _this.camera = new camera_1.default();\n        // Binding camera events\n        _this.bindCameraHandlers();\n        // Initializing captors\n        _this.mouseCaptor = new mouse_1.default(_this.elements.mouse, _this);\n        _this.touchCaptor = new touch_1.default(_this.elements.mouse, _this);\n        // Binding event handlers\n        _this.bindEventHandlers();\n        // Binding graph handlers\n        _this.bindGraphHandlers();\n        // Trigger eventual settings-related things\n        _this.handleSettingsUpdate();\n        // Processing data for the first time & render\n        _this.process();\n        _this.render();\n        return _this;\n    }\n    /**---------------------------------------------------------------------------\n     * Internal methods.\n     **---------------------------------------------------------------------------\n     */\n    /**\n     * Internal function used to create a canvas element.\n     * @param  {string} id - Context's id.\n     * @return {Sigma}\n     */\n    Sigma.prototype.createCanvas = function (id) {\n        var canvas = (0, utils_1.createElement)(\"canvas\", {\n            position: \"absolute\",\n        }, {\n            class: \"sigma-\".concat(id),\n        });\n        this.elements[id] = canvas;\n        this.container.appendChild(canvas);\n        return canvas;\n    };\n    /**\n     * Internal function used to create a canvas context and add the relevant\n     * DOM elements.\n     *\n     * @param  {string} id - Context's id.\n     * @return {Sigma}\n     */\n    Sigma.prototype.createCanvasContext = function (id) {\n        var canvas = this.createCanvas(id);\n        var contextOptions = {\n            preserveDrawingBuffer: false,\n            antialias: false,\n        };\n        this.canvasContexts[id] = canvas.getContext(\"2d\", contextOptions);\n        return this;\n    };\n    /**\n     * Internal function used to create a canvas context and add the relevant\n     * DOM elements.\n     *\n     * @param  {string}  id      - Context's id.\n     * @param  {object?} options - #getContext params to override (optional)\n     * @return {Sigma}\n     */\n    Sigma.prototype.createWebGLContext = function (id, options) {\n        var canvas = this.createCanvas(id);\n        var contextOptions = __assign({ preserveDrawingBuffer: false, antialias: false }, (options || {}));\n        var context;\n        // First we try webgl2 for an easy performance boost\n        context = canvas.getContext(\"webgl2\", contextOptions);\n        // Else we fall back to webgl\n        if (!context)\n            context = canvas.getContext(\"webgl\", contextOptions);\n        // Edge, I am looking right at you...\n        if (!context)\n            context = canvas.getContext(\"experimental-webgl\", contextOptions);\n        this.webGLContexts[id] = context;\n        return this;\n    };\n    /**\n     * Method binding camera handlers.\n     *\n     * @return {Sigma}\n     */\n    Sigma.prototype.bindCameraHandlers = function () {\n        var _this = this;\n        this.activeListeners.camera = function () {\n            _this._scheduleRefresh();\n        };\n        this.camera.on(\"updated\", this.activeListeners.camera);\n        return this;\n    };\n    /**\n     * Method that checks whether or not a node collides with a given position.\n     */\n    Sigma.prototype.mouseIsOnNode = function (_a, _b, size) {\n        var x = _a.x, y = _a.y;\n        var nodeX = _b.x, nodeY = _b.y;\n        return (x > nodeX - size &&\n            x < nodeX + size &&\n            y > nodeY - size &&\n            y < nodeY + size &&\n            Math.sqrt(Math.pow(x - nodeX, 2) + Math.pow(y - nodeY, 2)) < size);\n    };\n    /**\n     * Method that returns all nodes in quad at a given position.\n     */\n    Sigma.prototype.getQuadNodes = function (position) {\n        var mouseGraphPosition = this.viewportToFramedGraph(position);\n        return this.quadtree.point(mouseGraphPosition.x, 1 - mouseGraphPosition.y);\n    };\n    /**\n     * Method that returns the closest node to a given position.\n     */\n    Sigma.prototype.getNodeAtPosition = function (position) {\n        var x = position.x, y = position.y;\n        var quadNodes = this.getQuadNodes(position);\n        // We will hover the node whose center is closest to mouse\n        var minDistance = Infinity, nodeAtPosition = null;\n        for (var i = 0, l = quadNodes.length; i < l; i++) {\n            var node = quadNodes[i];\n            var data = this.nodeDataCache[node];\n            var nodePosition = this.framedGraphToViewport(data);\n            var size = this.scaleSize(data.size);\n            if (!data.hidden && this.mouseIsOnNode(position, nodePosition, size)) {\n                var distance = Math.sqrt(Math.pow(x - nodePosition.x, 2) + Math.pow(y - nodePosition.y, 2));\n                // TODO: sort by min size also for cases where center is the same\n                if (distance < minDistance) {\n                    minDistance = distance;\n                    nodeAtPosition = node;\n                }\n            }\n        }\n        return nodeAtPosition;\n    };\n    /**\n     * Method binding event handlers.\n     *\n     * @return {Sigma}\n     */\n    Sigma.prototype.bindEventHandlers = function () {\n        var _this = this;\n        // Handling window resize\n        this.activeListeners.handleResize = function () {\n            _this.needToSoftProcess = true;\n            _this._scheduleRefresh();\n        };\n        window.addEventListener(\"resize\", this.activeListeners.handleResize);\n        // Handling mouse move\n        this.activeListeners.handleMove = function (e) {\n            var baseEvent = {\n                event: e,\n                preventSigmaDefault: function () {\n                    e.preventSigmaDefault();\n                },\n            };\n            var nodeToHover = _this.getNodeAtPosition(e);\n            if (nodeToHover && _this.hoveredNode !== nodeToHover && !_this.nodeDataCache[nodeToHover].hidden) {\n                // Handling passing from one node to the other directly\n                if (_this.hoveredNode)\n                    _this.emit(\"leaveNode\", __assign(__assign({}, baseEvent), { node: _this.hoveredNode }));\n                _this.hoveredNode = nodeToHover;\n                _this.emit(\"enterNode\", __assign(__assign({}, baseEvent), { node: nodeToHover }));\n                _this.scheduleHighlightedNodesRender();\n                return;\n            }\n            // Checking if the hovered node is still hovered\n            if (_this.hoveredNode) {\n                var data = _this.nodeDataCache[_this.hoveredNode];\n                var pos = _this.framedGraphToViewport(data);\n                var size = _this.scaleSize(data.size);\n                if (!_this.mouseIsOnNode(e, pos, size)) {\n                    var node = _this.hoveredNode;\n                    _this.hoveredNode = null;\n                    _this.emit(\"leaveNode\", __assign(__assign({}, baseEvent), { node: node }));\n                    _this.scheduleHighlightedNodesRender();\n                    return;\n                }\n            }\n            if (_this.settings.enableEdgeHoverEvents === true) {\n                _this.checkEdgeHoverEvents(baseEvent);\n            }\n            else if (_this.settings.enableEdgeHoverEvents === \"debounce\") {\n                if (!_this.checkEdgesEventsFrame)\n                    _this.checkEdgesEventsFrame = (0, utils_1.requestFrame)(function () {\n                        _this.checkEdgeHoverEvents(baseEvent);\n                        _this.checkEdgesEventsFrame = null;\n                    });\n            }\n        };\n        // Handling click\n        var createMouseListener = function (eventType) {\n            return function (e) {\n                var baseEvent = {\n                    event: e,\n                    preventSigmaDefault: function () {\n                        e.preventSigmaDefault();\n                    },\n                };\n                var isFakeSigmaMouseEvent = e.original.isFakeSigmaMouseEvent;\n                var nodeAtPosition = isFakeSigmaMouseEvent ? _this.getNodeAtPosition(e) : _this.hoveredNode;\n                if (nodeAtPosition)\n                    return _this.emit(\"\".concat(eventType, \"Node\"), __assign(__assign({}, baseEvent), { node: nodeAtPosition }));\n                if (eventType === \"wheel\" ? _this.settings.enableEdgeWheelEvents : _this.settings.enableEdgeClickEvents) {\n                    var edge = _this.getEdgeAtPoint(e.x, e.y);\n                    if (edge)\n                        return _this.emit(\"\".concat(eventType, \"Edge\"), __assign(__assign({}, baseEvent), { edge: edge }));\n                }\n                return _this.emit(\"\".concat(eventType, \"Stage\"), baseEvent);\n            };\n        };\n        this.activeListeners.handleClick = createMouseListener(\"click\");\n        this.activeListeners.handleRightClick = createMouseListener(\"rightClick\");\n        this.activeListeners.handleDoubleClick = createMouseListener(\"doubleClick\");\n        this.activeListeners.handleWheel = createMouseListener(\"wheel\");\n        this.activeListeners.handleDown = createMouseListener(\"down\");\n        this.mouseCaptor.on(\"mousemove\", this.activeListeners.handleMove);\n        this.mouseCaptor.on(\"click\", this.activeListeners.handleClick);\n        this.mouseCaptor.on(\"rightClick\", this.activeListeners.handleRightClick);\n        this.mouseCaptor.on(\"doubleClick\", this.activeListeners.handleDoubleClick);\n        this.mouseCaptor.on(\"wheel\", this.activeListeners.handleWheel);\n        this.mouseCaptor.on(\"mousedown\", this.activeListeners.handleDown);\n        // TODO\n        // Deal with Touch captor events\n        return this;\n    };\n    /**\n     * Method binding graph handlers\n     *\n     * @return {Sigma}\n     */\n    Sigma.prototype.bindGraphHandlers = function () {\n        var _this = this;\n        var graph = this.graph;\n        this.activeListeners.graphUpdate = function () {\n            _this.needToProcess = true;\n            _this._scheduleRefresh();\n        };\n        this.activeListeners.softGraphUpdate = function () {\n            _this.needToSoftProcess = true;\n            _this._scheduleRefresh();\n        };\n        this.activeListeners.dropNodeGraphUpdate = function (e) {\n            delete _this.nodeDataCache[e.key];\n            if (_this.hoveredNode === e.key)\n                _this.hoveredNode = null;\n            _this.activeListeners.graphUpdate();\n        };\n        this.activeListeners.dropEdgeGraphUpdate = function (e) {\n            delete _this.edgeDataCache[e.key];\n            if (_this.hoveredEdge === e.key)\n                _this.hoveredEdge = null;\n            _this.activeListeners.graphUpdate();\n        };\n        this.activeListeners.clearEdgesGraphUpdate = function () {\n            _this.edgeDataCache = {};\n            _this.hoveredEdge = null;\n            _this.activeListeners.graphUpdate();\n        };\n        this.activeListeners.clearGraphUpdate = function () {\n            _this.nodeDataCache = {};\n            _this.hoveredNode = null;\n            _this.activeListeners.clearEdgesGraphUpdate();\n        };\n        graph.on(\"nodeAdded\", this.activeListeners.graphUpdate);\n        graph.on(\"nodeDropped\", this.activeListeners.dropNodeGraphUpdate);\n        graph.on(\"nodeAttributesUpdated\", this.activeListeners.softGraphUpdate);\n        graph.on(\"eachNodeAttributesUpdated\", this.activeListeners.graphUpdate);\n        graph.on(\"edgeAdded\", this.activeListeners.graphUpdate);\n        graph.on(\"edgeDropped\", this.activeListeners.dropEdgeGraphUpdate);\n        graph.on(\"edgeAttributesUpdated\", this.activeListeners.softGraphUpdate);\n        graph.on(\"eachEdgeAttributesUpdated\", this.activeListeners.graphUpdate);\n        graph.on(\"edgesCleared\", this.activeListeners.clearEdgesGraphUpdate);\n        graph.on(\"cleared\", this.activeListeners.clearGraphUpdate);\n        return this;\n    };\n    /**\n     * Method dealing with \"leaveEdge\" and \"enterEdge\" events.\n     *\n     * @return {Sigma}\n     */\n    Sigma.prototype.checkEdgeHoverEvents = function (payload) {\n        var edgeToHover = this.hoveredNode ? null : this.getEdgeAtPoint(payload.event.x, payload.event.y);\n        if (edgeToHover !== this.hoveredEdge) {\n            if (this.hoveredEdge)\n                this.emit(\"leaveEdge\", __assign(__assign({}, payload), { edge: this.hoveredEdge }));\n            if (edgeToHover)\n                this.emit(\"enterEdge\", __assign(__assign({}, payload), { edge: edgeToHover }));\n            this.hoveredEdge = edgeToHover;\n        }\n        return this;\n    };\n    /**\n     * Method looking for an edge colliding with a given point at (x, y). Returns\n     * the key of the edge if any, or null else.\n     */\n    Sigma.prototype.getEdgeAtPoint = function (x, y) {\n        var e_1, _a;\n        var _this = this;\n        var _b = this, edgeDataCache = _b.edgeDataCache, nodeDataCache = _b.nodeDataCache;\n        // Check first that pixel is colored:\n        // Note that mouse positions must be corrected by pixel ratio to correctly\n        // index the drawing buffer.\n        if (!(0, edge_collisions_1.isPixelColored)(this.webGLContexts.edges, x * this.pixelRatio, y * this.pixelRatio))\n            return null;\n        // Check for each edge if it collides with the point:\n        var _c = this.viewportToGraph({ x: x, y: y }), graphX = _c.x, graphY = _c.y;\n        // To translate edge thicknesses to the graph system, we observe by how much\n        // the length of a non-null edge is transformed to between the graph system\n        // and the viewport system:\n        var transformationRatio = 0;\n        this.graph.someEdge(function (key, _, sourceId, targetId, _a, _b) {\n            var xs = _a.x, ys = _a.y;\n            var xt = _b.x, yt = _b.y;\n            if (edgeDataCache[key].hidden || nodeDataCache[sourceId].hidden || nodeDataCache[targetId].hidden)\n                return false;\n            if (xs !== xt || ys !== yt) {\n                var graphLength = Math.sqrt(Math.pow(xt - xs, 2) + Math.pow(yt - ys, 2));\n                var _c = _this.graphToViewport({ x: xs, y: ys }), vp_xs = _c.x, vp_ys = _c.y;\n                var _d = _this.graphToViewport({ x: xt, y: yt }), vp_xt = _d.x, vp_yt = _d.y;\n                var viewportLength = Math.sqrt(Math.pow(vp_xt - vp_xs, 2) + Math.pow(vp_yt - vp_ys, 2));\n                transformationRatio = graphLength / viewportLength;\n                return true;\n            }\n        });\n        // If no non-null edge has been found, return null:\n        if (!transformationRatio)\n            return null;\n        // Now we can look for matching edges:\n        var edges = this.graph.filterEdges(function (key, edgeAttributes, sourceId, targetId, sourcePosition, targetPosition) {\n            if (edgeDataCache[key].hidden || nodeDataCache[sourceId].hidden || nodeDataCache[targetId].hidden)\n                return false;\n            if ((0, edge_collisions_1.doEdgeCollideWithPoint)(graphX, graphY, sourcePosition.x, sourcePosition.y, targetPosition.x, targetPosition.y, \n            // Adapt the edge size to the zoom ratio:\n            (edgeDataCache[key].size * transformationRatio) / _this.cameraSizeRatio)) {\n                return true;\n            }\n        });\n        if (edges.length === 0)\n            return null; // no edges found\n        // if none of the edges have a zIndex, selected the most recently created one to match the rendering order\n        var selectedEdge = edges[edges.length - 1];\n        // otherwise select edge with highest zIndex\n        var highestZIndex = -Infinity;\n        try {\n            for (var edges_1 = __values(edges), edges_1_1 = edges_1.next(); !edges_1_1.done; edges_1_1 = edges_1.next()) {\n                var edge = edges_1_1.value;\n                var zIndex = this.graph.getEdgeAttribute(edge, \"zIndex\");\n                if (zIndex >= highestZIndex) {\n                    selectedEdge = edge;\n                    highestZIndex = zIndex;\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (edges_1_1 && !edges_1_1.done && (_a = edges_1.return)) _a.call(edges_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        return selectedEdge;\n    };\n    /**\n     * Method used to process the whole graph's data.\n     *\n     * @return {Sigma}\n     */\n    Sigma.prototype.process = function (keepArrays) {\n        var _this = this;\n        if (keepArrays === void 0) { keepArrays = false; }\n        var graph = this.graph;\n        var settings = this.settings;\n        var dimensions = this.getDimensions();\n        var nodeZExtent = [Infinity, -Infinity];\n        var edgeZExtent = [Infinity, -Infinity];\n        // Clearing the quad\n        this.quadtree.clear();\n        // Resetting the label grid\n        // TODO: it's probably better to do this explicitly or on resizes for layout and anims\n        this.labelGrid.resizeAndClear(dimensions, settings.labelGridCellSize);\n        // Clear the highlightedNodes\n        this.highlightedNodes = new Set();\n        // Computing extents\n        this.nodeExtent = (0, utils_1.graphExtent)(graph);\n        // Resetting `forceLabel` indices\n        this.nodesWithForcedLabels = [];\n        this.edgesWithForcedLabels = [];\n        // NOTE: it is important to compute this matrix after computing the node's extent\n        // because #.getGraphDimensions relies on it\n        var nullCamera = new camera_1.default();\n        var nullCameraMatrix = (0, utils_1.matrixFromCamera)(nullCamera.getState(), this.getDimensions(), this.getGraphDimensions(), this.getSetting(\"stagePadding\") || 0);\n        // Rescaling function\n        this.normalizationFunction = (0, utils_1.createNormalizationFunction)(this.customBBox || this.nodeExtent);\n        var nodesPerPrograms = {};\n        var nodes = graph.nodes();\n        for (var i = 0, l = nodes.length; i < l; i++) {\n            var node = nodes[i];\n            // Node display data resolution:\n            //   1. First we get the node's attributes\n            //   2. We optionally reduce them using the function provided by the user\n            //      Note that this function must return a total object and won't be merged\n            //   3. We apply our defaults, while running some vital checks\n            //   4. We apply the normalization function\n            // We shallow copy node data to avoid dangerous behaviors from reducers\n            var attr = Object.assign({}, graph.getNodeAttributes(node));\n            if (settings.nodeReducer)\n                attr = settings.nodeReducer(node, attr);\n            var data = applyNodeDefaults(this.settings, node, attr);\n            nodesPerPrograms[data.type] = (nodesPerPrograms[data.type] || 0) + 1;\n            this.nodeDataCache[node] = data;\n            this.normalizationFunction.applyTo(data);\n            if (data.forceLabel)\n                this.nodesWithForcedLabels.push(node);\n            if (this.settings.zIndex) {\n                if (data.zIndex < nodeZExtent[0])\n                    nodeZExtent[0] = data.zIndex;\n                if (data.zIndex > nodeZExtent[1])\n                    nodeZExtent[1] = data.zIndex;\n            }\n        }\n        for (var type in this.nodePrograms) {\n            if (!this.nodePrograms.hasOwnProperty(type)) {\n                throw new Error(\"Sigma: could not find a suitable program for node type \\\"\".concat(type, \"\\\"!\"));\n            }\n            if (!keepArrays)\n                this.nodePrograms[type].allocate(nodesPerPrograms[type] || 0);\n            // We reset that count here, so that we can reuse it while calling the Program#process methods:\n            nodesPerPrograms[type] = 0;\n        }\n        // Handling node z-index\n        // TODO: z-index needs us to compute display data before hand\n        if (this.settings.zIndex && nodeZExtent[0] !== nodeZExtent[1])\n            nodes = (0, utils_1.zIndexOrdering)(nodeZExtent, function (node) { return _this.nodeDataCache[node].zIndex; }, nodes);\n        for (var i = 0, l = nodes.length; i < l; i++) {\n            var node = nodes[i];\n            var data = this.nodeDataCache[node];\n            this.quadtree.add(node, data.x, 1 - data.y, data.size / this.width);\n            if (typeof data.label === \"string\" && !data.hidden)\n                this.labelGrid.add(node, data.size, this.framedGraphToViewport(data, { matrix: nullCameraMatrix }));\n            this.nodePrograms[data.type].process(data, data.hidden, nodesPerPrograms[data.type]++);\n            // Save the node in the highlighted set if needed\n            if (data.highlighted && !data.hidden)\n                this.highlightedNodes.add(node);\n        }\n        this.labelGrid.organize();\n        var edgesPerPrograms = {};\n        var edges = graph.edges();\n        for (var i = 0, l = edges.length; i < l; i++) {\n            var edge = edges[i];\n            // Edge display data resolution:\n            //   1. First we get the edge's attributes\n            //   2. We optionally reduce them using the function provided by the user\n            //      Note that this function must return a total object and won't be merged\n            //   3. We apply our defaults, while running some vital checks\n            // We shallow copy edge data to avoid dangerous behaviors from reducers\n            var attr = Object.assign({}, graph.getEdgeAttributes(edge));\n            if (settings.edgeReducer)\n                attr = settings.edgeReducer(edge, attr);\n            var data = applyEdgeDefaults(this.settings, edge, attr);\n            edgesPerPrograms[data.type] = (edgesPerPrograms[data.type] || 0) + 1;\n            this.edgeDataCache[edge] = data;\n            if (data.forceLabel && !data.hidden)\n                this.edgesWithForcedLabels.push(edge);\n            if (this.settings.zIndex) {\n                if (data.zIndex < edgeZExtent[0])\n                    edgeZExtent[0] = data.zIndex;\n                if (data.zIndex > edgeZExtent[1])\n                    edgeZExtent[1] = data.zIndex;\n            }\n        }\n        for (var type in this.edgePrograms) {\n            if (!this.edgePrograms.hasOwnProperty(type)) {\n                throw new Error(\"Sigma: could not find a suitable program for edge type \\\"\".concat(type, \"\\\"!\"));\n            }\n            if (!keepArrays)\n                this.edgePrograms[type].allocate(edgesPerPrograms[type] || 0);\n            // We reset that count here, so that we can reuse it while calling the Program#process methods:\n            edgesPerPrograms[type] = 0;\n        }\n        // Handling edge z-index\n        if (this.settings.zIndex && edgeZExtent[0] !== edgeZExtent[1])\n            edges = (0, utils_1.zIndexOrdering)(edgeZExtent, function (edge) { return _this.edgeDataCache[edge].zIndex; }, edges);\n        for (var i = 0, l = edges.length; i < l; i++) {\n            var edge = edges[i];\n            var data = this.edgeDataCache[edge];\n            var extremities = graph.extremities(edge), sourceData = this.nodeDataCache[extremities[0]], targetData = this.nodeDataCache[extremities[1]];\n            var hidden = data.hidden || sourceData.hidden || targetData.hidden;\n            this.edgePrograms[data.type].process(sourceData, targetData, data, hidden, edgesPerPrograms[data.type]++);\n        }\n        for (var type in this.edgePrograms) {\n            var program = this.edgePrograms[type];\n            if (!keepArrays && typeof program.computeIndices === \"function\")\n                program.computeIndices();\n        }\n        return this;\n    };\n    /**\n     * Method that backports potential settings updates where it's needed.\n     * @private\n     */\n    Sigma.prototype.handleSettingsUpdate = function () {\n        this.camera.minRatio = this.settings.minCameraRatio;\n        this.camera.maxRatio = this.settings.maxCameraRatio;\n        this.camera.setState(this.camera.validateState(this.camera.getState()));\n        return this;\n    };\n    /**\n     * Method that decides whether to reprocess graph or not, and then render the\n     * graph.\n     *\n     * @return {Sigma}\n     */\n    Sigma.prototype._refresh = function () {\n        // Do we need to process data?\n        if (this.needToProcess) {\n            this.process();\n        }\n        else if (this.needToSoftProcess) {\n            this.process(true);\n        }\n        // Resetting state\n        this.needToProcess = false;\n        this.needToSoftProcess = false;\n        // Rendering\n        this.render();\n        return this;\n    };\n    /**\n     * Method that schedules a `_refresh` call if none has been scheduled yet. It\n     * will then be processed next available frame.\n     *\n     * @return {Sigma}\n     */\n    Sigma.prototype._scheduleRefresh = function () {\n        var _this = this;\n        if (!this.renderFrame) {\n            this.renderFrame = (0, utils_1.requestFrame)(function () {\n                _this._refresh();\n                _this.renderFrame = null;\n            });\n        }\n        return this;\n    };\n    /**\n     * Method used to render labels.\n     *\n     * @return {Sigma}\n     */\n    Sigma.prototype.renderLabels = function () {\n        if (!this.settings.renderLabels)\n            return this;\n        var cameraState = this.camera.getState();\n        // Finding visible nodes to display their labels\n        var visibleNodes;\n        if (cameraState.ratio >= 1) {\n            // Camera is unzoomed so no need to ask the quadtree for visible nodes\n            visibleNodes = new Set(this.graph.nodes());\n        }\n        else {\n            // Let's ask the quadtree\n            var viewRectangle = this.viewRectangle();\n            visibleNodes = new Set(this.quadtree.rectangle(viewRectangle.x1, 1 - viewRectangle.y1, viewRectangle.x2, 1 - viewRectangle.y2, viewRectangle.height));\n        }\n        // Selecting labels to draw\n        // TODO: drop gridsettings likewise\n        // TODO: optimize through visible nodes\n        var labelsToDisplay = this.labelGrid\n            .getLabelsToDisplay(cameraState.ratio, this.settings.labelDensity)\n            .concat(this.nodesWithForcedLabels);\n        this.displayedLabels = new Set();\n        // Drawing labels\n        var context = this.canvasContexts.labels;\n        for (var i = 0, l = labelsToDisplay.length; i < l; i++) {\n            var node = labelsToDisplay[i];\n            var data = this.nodeDataCache[node];\n            // If the node was already drawn (like if it is eligible AND has\n            // `forceLabel`), we don't want to draw it again\n            if (this.displayedLabels.has(node))\n                continue;\n            // If the node is hidden, we don't need to display its label obviously\n            if (data.hidden)\n                continue;\n            var _a = this.framedGraphToViewport(data), x = _a.x, y = _a.y;\n            // TODO: we can cache the labels we need to render until the camera's ratio changes\n            // TODO: this should be computed in the canvas components?\n            var size = this.scaleSize(data.size);\n            if (!data.forceLabel && size < this.settings.labelRenderedSizeThreshold)\n                continue;\n            if (!visibleNodes.has(node))\n                continue;\n            // TODO:\n            // Because displayed edge labels depend directly on actually rendered node\n            // labels, we need to only add to this.displayedLabels nodes whose label\n            // is rendered.\n            // This makes this.displayedLabels depend on viewport, which might become\n            // an issue once we start memoizing getLabelsToDisplay.\n            this.displayedLabels.add(node);\n            this.settings.labelRenderer(context, __assign(__assign({ key: node }, data), { size: size, x: x, y: y }), this.settings);\n        }\n        return this;\n    };\n    /**\n     * Method used to render edge labels, based on which node labels were\n     * rendered.\n     *\n     * @return {Sigma}\n     */\n    Sigma.prototype.renderEdgeLabels = function () {\n        if (!this.settings.renderEdgeLabels)\n            return this;\n        var context = this.canvasContexts.edgeLabels;\n        // Clearing\n        context.clearRect(0, 0, this.width, this.height);\n        var edgeLabelsToDisplay = (0, labels_1.edgeLabelsToDisplayFromNodes)({\n            graph: this.graph,\n            hoveredNode: this.hoveredNode,\n            displayedNodeLabels: this.displayedLabels,\n            highlightedNodes: this.highlightedNodes,\n        }).concat(this.edgesWithForcedLabels);\n        var displayedLabels = new Set();\n        for (var i = 0, l = edgeLabelsToDisplay.length; i < l; i++) {\n            var edge = edgeLabelsToDisplay[i], extremities = this.graph.extremities(edge), sourceData = this.nodeDataCache[extremities[0]], targetData = this.nodeDataCache[extremities[1]], edgeData = this.edgeDataCache[edge];\n            // If the edge was already drawn (like if it is eligible AND has\n            // `forceLabel`), we don't want to draw it again\n            if (displayedLabels.has(edge))\n                continue;\n            // If the edge is hidden we don't need to display its label\n            // NOTE: the test on sourceData & targetData is probably paranoid at this point?\n            if (edgeData.hidden || sourceData.hidden || targetData.hidden) {\n                continue;\n            }\n            this.settings.edgeLabelRenderer(context, __assign(__assign({ key: edge }, edgeData), { size: this.scaleSize(edgeData.size) }), __assign(__assign(__assign({ key: extremities[0] }, sourceData), this.framedGraphToViewport(sourceData)), { size: this.scaleSize(sourceData.size) }), __assign(__assign(__assign({ key: extremities[1] }, targetData), this.framedGraphToViewport(targetData)), { size: this.scaleSize(targetData.size) }), this.settings);\n            displayedLabels.add(edge);\n        }\n        return this;\n    };\n    /**\n     * Method used to render the highlighted nodes.\n     *\n     * @return {Sigma}\n     */\n    Sigma.prototype.renderHighlightedNodes = function () {\n        var _this = this;\n        var context = this.canvasContexts.hovers;\n        // Clearing\n        context.clearRect(0, 0, this.width, this.height);\n        // Rendering\n        var render = function (node) {\n            var data = _this.nodeDataCache[node];\n            var _a = _this.framedGraphToViewport(data), x = _a.x, y = _a.y;\n            var size = _this.scaleSize(data.size);\n            _this.settings.hoverRenderer(context, __assign(__assign({ key: node }, data), { size: size, x: x, y: y }), _this.settings);\n        };\n        var nodesToRender = [];\n        if (this.hoveredNode && !this.nodeDataCache[this.hoveredNode].hidden) {\n            nodesToRender.push(this.hoveredNode);\n        }\n        this.highlightedNodes.forEach(function (node) {\n            // The hovered node has already been highlighted\n            if (node !== _this.hoveredNode)\n                nodesToRender.push(node);\n        });\n        // Draw labels:\n        nodesToRender.forEach(function (node) { return render(node); });\n        // Draw WebGL nodes on top of the labels:\n        var nodesPerPrograms = {};\n        // 1. Count nodes per type:\n        nodesToRender.forEach(function (node) {\n            var type = _this.nodeDataCache[node].type;\n            nodesPerPrograms[type] = (nodesPerPrograms[type] || 0) + 1;\n        });\n        // 2. Allocate for each type for the proper number of nodes\n        for (var type in this.hoverNodePrograms) {\n            this.hoverNodePrograms[type].allocate(nodesPerPrograms[type] || 0);\n            // Also reset count, to use when rendering:\n            nodesPerPrograms[type] = 0;\n        }\n        // 3. Process all nodes to render:\n        nodesToRender.forEach(function (node) {\n            var data = _this.nodeDataCache[node];\n            _this.hoverNodePrograms[data.type].process(data, data.hidden, nodesPerPrograms[data.type]++);\n        });\n        // 4. Clear hovered nodes layer:\n        this.webGLContexts.hoverNodes.clear(this.webGLContexts.hoverNodes.COLOR_BUFFER_BIT);\n        // 5. Render:\n        for (var type in this.hoverNodePrograms) {\n            var program = this.hoverNodePrograms[type];\n            program.bind();\n            program.bufferData();\n            program.render({\n                matrix: this.matrix,\n                width: this.width,\n                height: this.height,\n                ratio: this.camera.ratio,\n                correctionRatio: this.correctionRatio / this.camera.ratio,\n                scalingRatio: this.pixelRatio,\n            });\n        }\n    };\n    /**\n     * Method used to schedule a hover render.\n     *\n     */\n    Sigma.prototype.scheduleHighlightedNodesRender = function () {\n        var _this = this;\n        if (this.renderHighlightedNodesFrame || this.renderFrame)\n            return;\n        this.renderHighlightedNodesFrame = (0, utils_1.requestFrame)(function () {\n            // Resetting state\n            _this.renderHighlightedNodesFrame = null;\n            // Rendering\n            _this.renderHighlightedNodes();\n            _this.renderEdgeLabels();\n        });\n    };\n    /**\n     * Method used to render.\n     *\n     * @return {Sigma}\n     */\n    Sigma.prototype.render = function () {\n        var _this = this;\n        this.emit(\"beforeRender\");\n        var handleEscape = function () {\n            _this.emit(\"afterRender\");\n            return _this;\n        };\n        // If a render was scheduled, we cancel it\n        if (this.renderFrame) {\n            (0, utils_1.cancelFrame)(this.renderFrame);\n            this.renderFrame = null;\n            this.needToProcess = false;\n            this.needToSoftProcess = false;\n        }\n        // First we need to resize\n        this.resize();\n        // Clearing the canvases\n        this.clear();\n        // Recomputing useful camera-related values:\n        this.updateCachedValues();\n        // If we have no nodes we can stop right there\n        if (!this.graph.order)\n            return handleEscape();\n        // TODO: improve this heuristic or move to the captor itself?\n        // TODO: deal with the touch captor here as well\n        var mouseCaptor = this.mouseCaptor;\n        var moving = this.camera.isAnimated() ||\n            mouseCaptor.isMoving ||\n            mouseCaptor.draggedEvents ||\n            mouseCaptor.currentWheelDirection;\n        // Then we need to extract a matrix from the camera\n        var cameraState = this.camera.getState();\n        var viewportDimensions = this.getDimensions();\n        var graphDimensions = this.getGraphDimensions();\n        var padding = this.getSetting(\"stagePadding\") || 0;\n        this.matrix = (0, utils_1.matrixFromCamera)(cameraState, viewportDimensions, graphDimensions, padding);\n        this.invMatrix = (0, utils_1.matrixFromCamera)(cameraState, viewportDimensions, graphDimensions, padding, true);\n        this.correctionRatio = (0, utils_1.getMatrixImpact)(this.matrix, cameraState, viewportDimensions);\n        // Drawing nodes\n        for (var type in this.nodePrograms) {\n            var program = this.nodePrograms[type];\n            program.bind();\n            program.bufferData();\n            program.render({\n                matrix: this.matrix,\n                width: this.width,\n                height: this.height,\n                ratio: cameraState.ratio,\n                correctionRatio: this.correctionRatio / cameraState.ratio,\n                scalingRatio: this.pixelRatio,\n            });\n        }\n        // Drawing edges\n        if (!this.settings.hideEdgesOnMove || !moving) {\n            for (var type in this.edgePrograms) {\n                var program = this.edgePrograms[type];\n                program.bind();\n                program.bufferData();\n                program.render({\n                    matrix: this.matrix,\n                    width: this.width,\n                    height: this.height,\n                    ratio: cameraState.ratio,\n                    correctionRatio: this.correctionRatio / cameraState.ratio,\n                    scalingRatio: this.pixelRatio,\n                });\n            }\n        }\n        // Do not display labels on move per setting\n        if (this.settings.hideLabelsOnMove && moving)\n            return handleEscape();\n        this.renderLabels();\n        this.renderEdgeLabels();\n        this.renderHighlightedNodes();\n        return handleEscape();\n    };\n    /**\n     * Internal method used to update expensive and therefore cached values\n     * each time the camera state is updated.\n     */\n    Sigma.prototype.updateCachedValues = function () {\n        var ratio = this.camera.getState().ratio;\n        this.cameraSizeRatio = Math.sqrt(ratio);\n    };\n    /**---------------------------------------------------------------------------\n     * Public API.\n     **---------------------------------------------------------------------------\n     */\n    /**\n     * Method returning the renderer's camera.\n     *\n     * @return {Camera}\n     */\n    Sigma.prototype.getCamera = function () {\n        return this.camera;\n    };\n    /**\n     * Method returning the container DOM element.\n     *\n     * @return {HTMLElement}\n     */\n    Sigma.prototype.getContainer = function () {\n        return this.container;\n    };\n    /**\n     * Method returning the renderer's graph.\n     *\n     * @return {Graph}\n     */\n    Sigma.prototype.getGraph = function () {\n        return this.graph;\n    };\n    /**\n     * Method returning the mouse captor.\n     *\n     * @return {MouseCaptor}\n     */\n    Sigma.prototype.getMouseCaptor = function () {\n        return this.mouseCaptor;\n    };\n    /**\n     * Method returning the touch captor.\n     *\n     * @return {TouchCaptor}\n     */\n    Sigma.prototype.getTouchCaptor = function () {\n        return this.touchCaptor;\n    };\n    /**\n     * Method returning the current renderer's dimensions.\n     *\n     * @return {Dimensions}\n     */\n    Sigma.prototype.getDimensions = function () {\n        return { width: this.width, height: this.height };\n    };\n    /**\n     * Method returning the current graph's dimensions.\n     *\n     * @return {Dimensions}\n     */\n    Sigma.prototype.getGraphDimensions = function () {\n        var extent = this.customBBox || this.nodeExtent;\n        return {\n            width: extent.x[1] - extent.x[0] || 1,\n            height: extent.y[1] - extent.y[0] || 1,\n        };\n    };\n    /**\n     * Method used to get all the sigma node attributes.\n     * It's usefull for example to get the position of a node\n     * and to get values that are set by the nodeReducer\n     *\n     * @param  {string} key - The node's key.\n     * @return {NodeDisplayData | undefined} A copy of the desired node's attribute or undefined if not found\n     */\n    Sigma.prototype.getNodeDisplayData = function (key) {\n        var node = this.nodeDataCache[key];\n        return node ? Object.assign({}, node) : undefined;\n    };\n    /**\n     * Method used to get all the sigma edge attributes.\n     * It's usefull for example to get values that are set by the edgeReducer.\n     *\n     * @param  {string} key - The edge's key.\n     * @return {EdgeDisplayData | undefined} A copy of the desired edge's attribute or undefined if not found\n     */\n    Sigma.prototype.getEdgeDisplayData = function (key) {\n        var edge = this.edgeDataCache[key];\n        return edge ? Object.assign({}, edge) : undefined;\n    };\n    /**\n     * Method returning a copy of the settings collection.\n     *\n     * @return {Settings} A copy of the settings collection.\n     */\n    Sigma.prototype.getSettings = function () {\n        return __assign({}, this.settings);\n    };\n    /**\n     * Method returning the current value for a given setting key.\n     *\n     * @param  {string} key - The setting key to get.\n     * @return {any} The value attached to this setting key or undefined if not found\n     */\n    Sigma.prototype.getSetting = function (key) {\n        return this.settings[key];\n    };\n    /**\n     * Method setting the value of a given setting key. Note that this will schedule\n     * a new render next frame.\n     *\n     * @param  {string} key - The setting key to set.\n     * @param  {any}    value - The value to set.\n     * @return {Sigma}\n     */\n    Sigma.prototype.setSetting = function (key, value) {\n        this.settings[key] = value;\n        (0, settings_1.validateSettings)(this.settings);\n        this.handleSettingsUpdate();\n        this.needToProcess = true; // TODO: some keys may work with only needToSoftProcess or even nothing\n        this._scheduleRefresh();\n        return this;\n    };\n    /**\n     * Method updating the value of a given setting key using the provided function.\n     * Note that this will schedule a new render next frame.\n     *\n     * @param  {string}   key     - The setting key to set.\n     * @param  {function} updater - The update function.\n     * @return {Sigma}\n     */\n    Sigma.prototype.updateSetting = function (key, updater) {\n        this.settings[key] = updater(this.settings[key]);\n        (0, settings_1.validateSettings)(this.settings);\n        this.handleSettingsUpdate();\n        this.needToProcess = true; // TODO: some keys may work with only needToSoftProcess or even nothing\n        this._scheduleRefresh();\n        return this;\n    };\n    /**\n     * Method used to resize the renderer.\n     *\n     * @return {Sigma}\n     */\n    Sigma.prototype.resize = function () {\n        var previousWidth = this.width, previousHeight = this.height;\n        this.width = this.container.offsetWidth;\n        this.height = this.container.offsetHeight;\n        this.pixelRatio = (0, utils_1.getPixelRatio)();\n        if (this.width === 0) {\n            if (this.settings.allowInvalidContainer)\n                this.width = 1;\n            else\n                throw new Error(\"Sigma: Container has no width. You can set the allowInvalidContainer setting to true to stop seing this error.\");\n        }\n        if (this.height === 0) {\n            if (this.settings.allowInvalidContainer)\n                this.height = 1;\n            else\n                throw new Error(\"Sigma: Container has no height. You can set the allowInvalidContainer setting to true to stop seing this error.\");\n        }\n        // If nothing has changed, we can stop right here\n        if (previousWidth === this.width && previousHeight === this.height)\n            return this;\n        this.emit(\"resize\");\n        // Sizing dom elements\n        for (var id in this.elements) {\n            var element = this.elements[id];\n            element.style.width = this.width + \"px\";\n            element.style.height = this.height + \"px\";\n        }\n        // Sizing canvas contexts\n        for (var id in this.canvasContexts) {\n            this.elements[id].setAttribute(\"width\", this.width * this.pixelRatio + \"px\");\n            this.elements[id].setAttribute(\"height\", this.height * this.pixelRatio + \"px\");\n            if (this.pixelRatio !== 1)\n                this.canvasContexts[id].scale(this.pixelRatio, this.pixelRatio);\n        }\n        // Sizing WebGL contexts\n        for (var id in this.webGLContexts) {\n            this.elements[id].setAttribute(\"width\", this.width * this.pixelRatio + \"px\");\n            this.elements[id].setAttribute(\"height\", this.height * this.pixelRatio + \"px\");\n            this.webGLContexts[id].viewport(0, 0, this.width * this.pixelRatio, this.height * this.pixelRatio);\n        }\n        return this;\n    };\n    /**\n     * Method used to clear all the canvases.\n     *\n     * @return {Sigma}\n     */\n    Sigma.prototype.clear = function () {\n        this.webGLContexts.nodes.clear(this.webGLContexts.nodes.COLOR_BUFFER_BIT);\n        this.webGLContexts.edges.clear(this.webGLContexts.edges.COLOR_BUFFER_BIT);\n        this.webGLContexts.hoverNodes.clear(this.webGLContexts.hoverNodes.COLOR_BUFFER_BIT);\n        this.canvasContexts.labels.clearRect(0, 0, this.width, this.height);\n        this.canvasContexts.hovers.clearRect(0, 0, this.width, this.height);\n        this.canvasContexts.edgeLabels.clearRect(0, 0, this.width, this.height);\n        return this;\n    };\n    /**\n     * Method used to refresh all computed data.\n     *\n     * @return {Sigma}\n     */\n    Sigma.prototype.refresh = function () {\n        this.needToProcess = true;\n        this._refresh();\n        return this;\n    };\n    /**\n     * Method used to refresh all computed data, at the next available frame.\n     * If this method has already been called this frame, then it will only render once at the next available frame.\n     *\n     * @return {Sigma}\n     */\n    Sigma.prototype.scheduleRefresh = function () {\n        this.needToProcess = true;\n        this._scheduleRefresh();\n        return this;\n    };\n    /**\n     * Method used to (un)zoom, while preserving the position of a viewport point.\n     * Used for instance to zoom \"on the mouse cursor\".\n     *\n     * @param viewportTarget\n     * @param newRatio\n     * @return {CameraState}\n     */\n    Sigma.prototype.getViewportZoomedState = function (viewportTarget, newRatio) {\n        var _a = this.camera.getState(), ratio = _a.ratio, angle = _a.angle, x = _a.x, y = _a.y;\n        // TODO: handle max zoom\n        var ratioDiff = newRatio / ratio;\n        var center = {\n            x: this.width / 2,\n            y: this.height / 2,\n        };\n        var graphMousePosition = this.viewportToFramedGraph(viewportTarget);\n        var graphCenterPosition = this.viewportToFramedGraph(center);\n        return {\n            angle: angle,\n            x: (graphMousePosition.x - graphCenterPosition.x) * (1 - ratioDiff) + x,\n            y: (graphMousePosition.y - graphCenterPosition.y) * (1 - ratioDiff) + y,\n            ratio: newRatio,\n        };\n    };\n    /**\n     * Method returning the abstract rectangle containing the graph according\n     * to the camera's state.\n     *\n     * @return {object} - The view's rectangle.\n     */\n    Sigma.prototype.viewRectangle = function () {\n        // TODO: reduce relative margin?\n        var marginX = (0 * this.width) / 8, marginY = (0 * this.height) / 8;\n        var p1 = this.viewportToFramedGraph({ x: 0 - marginX, y: 0 - marginY }), p2 = this.viewportToFramedGraph({ x: this.width + marginX, y: 0 - marginY }), h = this.viewportToFramedGraph({ x: 0, y: this.height + marginY });\n        return {\n            x1: p1.x,\n            y1: p1.y,\n            x2: p2.x,\n            y2: p2.y,\n            height: p2.y - h.y,\n        };\n    };\n    /**\n     * Method returning the coordinates of a point from the framed graph system to the viewport system. It allows\n     * overriding anything that is used to get the translation matrix, or even the matrix itself.\n     *\n     * Be careful if overriding dimensions, padding or cameraState, as the computation of the matrix is not the lightest\n     * of computations.\n     */\n    Sigma.prototype.framedGraphToViewport = function (coordinates, override) {\n        if (override === void 0) { override = {}; }\n        var recomputeMatrix = !!override.cameraState || !!override.viewportDimensions || !!override.graphDimensions;\n        var matrix = override.matrix\n            ? override.matrix\n            : recomputeMatrix\n                ? (0, utils_1.matrixFromCamera)(override.cameraState || this.camera.getState(), override.viewportDimensions || this.getDimensions(), override.graphDimensions || this.getGraphDimensions(), override.padding || this.getSetting(\"stagePadding\") || 0)\n                : this.matrix;\n        var viewportPos = (0, matrices_1.multiplyVec2)(matrix, coordinates);\n        return {\n            x: ((1 + viewportPos.x) * this.width) / 2,\n            y: ((1 - viewportPos.y) * this.height) / 2,\n        };\n    };\n    /**\n     * Method returning the coordinates of a point from the viewport system to the framed graph system. It allows\n     * overriding anything that is used to get the translation matrix, or even the matrix itself.\n     *\n     * Be careful if overriding dimensions, padding or cameraState, as the computation of the matrix is not the lightest\n     * of computations.\n     */\n    Sigma.prototype.viewportToFramedGraph = function (coordinates, override) {\n        if (override === void 0) { override = {}; }\n        var recomputeMatrix = !!override.cameraState || !!override.viewportDimensions || !override.graphDimensions;\n        var invMatrix = override.matrix\n            ? override.matrix\n            : recomputeMatrix\n                ? (0, utils_1.matrixFromCamera)(override.cameraState || this.camera.getState(), override.viewportDimensions || this.getDimensions(), override.graphDimensions || this.getGraphDimensions(), override.padding || this.getSetting(\"stagePadding\") || 0, true)\n                : this.invMatrix;\n        var res = (0, matrices_1.multiplyVec2)(invMatrix, {\n            x: (coordinates.x / this.width) * 2 - 1,\n            y: 1 - (coordinates.y / this.height) * 2,\n        });\n        if (isNaN(res.x))\n            res.x = 0;\n        if (isNaN(res.y))\n            res.y = 0;\n        return res;\n    };\n    /**\n     * Method used to translate a point's coordinates from the viewport system (pixel distance from the top-left of the\n     * stage) to the graph system (the reference system of data as they are in the given graph instance).\n     *\n     * This method accepts an optional camera which can be useful if you need to translate coordinates\n     * based on a different view than the one being currently being displayed on screen.\n     *\n     * @param {Coordinates}                  viewportPoint\n     * @param {CoordinateConversionOverride} override\n     */\n    Sigma.prototype.viewportToGraph = function (viewportPoint, override) {\n        if (override === void 0) { override = {}; }\n        return this.normalizationFunction.inverse(this.viewportToFramedGraph(viewportPoint, override));\n    };\n    /**\n     * Method used to translate a point's coordinates from the graph system (the reference system of data as they are in\n     * the given graph instance) to the viewport system (pixel distance from the top-left of the stage).\n     *\n     * This method accepts an optional camera which can be useful if you need to translate coordinates\n     * based on a different view than the one being currently being displayed on screen.\n     *\n     * @param {Coordinates}                  graphPoint\n     * @param {CoordinateConversionOverride} override\n     */\n    Sigma.prototype.graphToViewport = function (graphPoint, override) {\n        if (override === void 0) { override = {}; }\n        return this.framedGraphToViewport(this.normalizationFunction(graphPoint), override);\n    };\n    /**\n     * Method returning the graph's bounding box.\n     *\n     * @return {{ x: Extent, y: Extent }}\n     */\n    Sigma.prototype.getBBox = function () {\n        return (0, utils_1.graphExtent)(this.graph);\n    };\n    /**\n     * Method returning the graph's custom bounding box, if any.\n     *\n     * @return {{ x: Extent, y: Extent } | null}\n     */\n    Sigma.prototype.getCustomBBox = function () {\n        return this.customBBox;\n    };\n    /**\n     * Method used to override the graph's bounding box with a custom one. Give `null` as the argument to stop overriding.\n     *\n     * @return {Sigma}\n     */\n    Sigma.prototype.setCustomBBox = function (customBBox) {\n        this.customBBox = customBBox;\n        this._scheduleRefresh();\n        return this;\n    };\n    /**\n     * Method used to shut the container & release event listeners.\n     *\n     * @return {undefined}\n     */\n    Sigma.prototype.kill = function () {\n        var graph = this.graph;\n        // Emitting \"kill\" events so that plugins and such can cleanup\n        this.emit(\"kill\");\n        // Releasing events\n        this.removeAllListeners();\n        // Releasing camera handlers\n        this.camera.removeListener(\"updated\", this.activeListeners.camera);\n        // Releasing DOM events & captors\n        window.removeEventListener(\"resize\", this.activeListeners.handleResize);\n        this.mouseCaptor.kill();\n        this.touchCaptor.kill();\n        // Releasing graph handlers\n        graph.removeListener(\"nodeAdded\", this.activeListeners.dropNodeGraphUpdate);\n        graph.removeListener(\"nodeDropped\", this.activeListeners.graphUpdate);\n        graph.removeListener(\"nodeAttributesUpdated\", this.activeListeners.softGraphUpdate);\n        graph.removeListener(\"eachNodeAttributesUpdated\", this.activeListeners.graphUpdate);\n        graph.removeListener(\"edgeAdded\", this.activeListeners.graphUpdate);\n        graph.removeListener(\"edgeDropped\", this.activeListeners.dropEdgeGraphUpdate);\n        graph.removeListener(\"edgeAttributesUpdated\", this.activeListeners.softGraphUpdate);\n        graph.removeListener(\"eachEdgeAttributesUpdated\", this.activeListeners.graphUpdate);\n        graph.removeListener(\"edgesCleared\", this.activeListeners.clearEdgesGraphUpdate);\n        graph.removeListener(\"cleared\", this.activeListeners.clearGraphUpdate);\n        // Releasing cache & state\n        this.quadtree = new quadtree_1.default();\n        this.nodeDataCache = {};\n        this.edgeDataCache = {};\n        this.nodesWithForcedLabels = [];\n        this.edgesWithForcedLabels = [];\n        this.highlightedNodes.clear();\n        // Clearing frames\n        if (this.renderFrame) {\n            (0, utils_1.cancelFrame)(this.renderFrame);\n            this.renderFrame = null;\n        }\n        if (this.renderHighlightedNodesFrame) {\n            (0, utils_1.cancelFrame)(this.renderHighlightedNodesFrame);\n            this.renderHighlightedNodesFrame = null;\n        }\n        // Destroying canvases\n        var container = this.container;\n        while (container.firstChild)\n            container.removeChild(container.firstChild);\n    };\n    /**\n     * Method used to scale the given size according to the camera's ratio, i.e.\n     * zooming state.\n     *\n     * @param  {number} size - The size to scale (node size, edge thickness etc.).\n     * @return {number}      - The scaled size.\n     */\n    Sigma.prototype.scaleSize = function (size) {\n        return size / this.cameraSizeRatio;\n    };\n    /**\n     * Method that returns the collection of all used canvases.\n     * At the moment, the instantiated canvases are the following, and in the\n     * following order in the DOM:\n     * - `edges`\n     * - `nodes`\n     * - `edgeLabels`\n     * - `labels`\n     * - `hovers`\n     * - `hoverNodes`\n     * - `mouse`\n     *\n     * @return {PlainObject<HTMLCanvasElement>} - The collection of canvases.\n     */\n    Sigma.prototype.getCanvases = function () {\n        return __assign({}, this.elements);\n    };\n    return Sigma;\n}(types_1.TypedEventEmitter));\nexports.default = Sigma;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Sigma = exports.MouseCaptor = exports.QuadTree = exports.Camera = void 0;\n/**\n * Sigma.js Library Endpoint\n * =========================\n *\n * The library endpoint.\n * @module\n */\nvar sigma_1 = __importDefault(require(\"./sigma\"));\nexports.Sigma = sigma_1.default;\nvar camera_1 = __importDefault(require(\"./core/camera\"));\nexports.Camera = camera_1.default;\nvar quadtree_1 = __importDefault(require(\"./core/quadtree\"));\nexports.QuadTree = quadtree_1.default;\nvar mouse_1 = __importDefault(require(\"./core/captors/mouse\"));\nexports.MouseCaptor = mouse_1.default;\nexports.default = sigma_1.default;\n","/**\n * Graphology Utilities\n * =====================\n *\n * Collection of helpful functions used by the implementation.\n */\n\n/**\n * Object.assign-like polyfill.\n *\n * @param  {object} target       - First object.\n * @param  {object} [...objects] - Objects to merge.\n * @return {object}\n */\nfunction assignPolyfill() {\n  const target = arguments[0];\n\n  for (let i = 1, l = arguments.length; i < l; i++) {\n    if (!arguments[i]) continue;\n\n    for (const k in arguments[i]) target[k] = arguments[i][k];\n  }\n\n  return target;\n}\n\nlet assign = assignPolyfill;\n\nif (typeof Object.assign === 'function') assign = Object.assign;\n\nexport {assign};\n\n/**\n * Function returning the first matching edge for given path.\n * Note: this function does not check the existence of source & target. This\n * must be performed by the caller.\n *\n * @param  {Graph}  graph  - Target graph.\n * @param  {any}    source - Source node.\n * @param  {any}    target - Target node.\n * @param  {string} type   - Type of the edge (mixed, directed or undirected).\n * @return {string|null}\n */\nexport function getMatchingEdge(graph, source, target, type) {\n  const sourceData = graph._nodes.get(source);\n\n  let edge = null;\n\n  if (!sourceData) return edge;\n\n  if (type === 'mixed') {\n    edge =\n      (sourceData.out && sourceData.out[target]) ||\n      (sourceData.undirected && sourceData.undirected[target]);\n  } else if (type === 'directed') {\n    edge = sourceData.out && sourceData.out[target];\n  } else {\n    edge = sourceData.undirected && sourceData.undirected[target];\n  }\n\n  return edge;\n}\n\n/**\n * Checks whether the given value is a plain object.\n *\n * @param  {mixed}   value - Target value.\n * @return {boolean}\n */\nexport function isPlainObject(value) {\n  return (\n    typeof value === 'object' && value !== null && value.constructor === Object\n  );\n}\n\n/**\n * Checks whether the given object is empty.\n *\n * @param  {object}  o - Target Object.\n * @return {boolean}\n */\nexport function isEmpty(o) {\n  let k;\n\n  for (k in o) return false;\n\n  return true;\n}\n\n/**\n * Creates a \"private\" property for the given member name by concealing it\n * using the `enumerable` option.\n *\n * @param {object} target - Target object.\n * @param {string} name   - Member name.\n */\nexport function privateProperty(target, name, value) {\n  Object.defineProperty(target, name, {\n    enumerable: false,\n    configurable: false,\n    writable: true,\n    value\n  });\n}\n\n/**\n * Creates a read-only property for the given member name & the given getter.\n *\n * @param {object}   target - Target object.\n * @param {string}   name   - Member name.\n * @param {mixed}    value  - The attached getter or fixed value.\n */\nexport function readOnlyProperty(target, name, value) {\n  const descriptor = {\n    enumerable: true,\n    configurable: true\n  };\n\n  if (typeof value === 'function') {\n    descriptor.get = value;\n  } else {\n    descriptor.value = value;\n    descriptor.writable = false;\n  }\n\n  Object.defineProperty(target, name, descriptor);\n}\n\n/**\n * Returns whether the given object constitute valid hints.\n *\n * @param {object} hints - Target object.\n */\nexport function validateHints(hints) {\n  if (!isPlainObject(hints)) return false;\n\n  if (hints.attributes && !Array.isArray(hints.attributes)) return false;\n\n  return true;\n}\n\n/**\n * Creates a function generating incremental ids for edges.\n *\n * @return {function}\n */\nexport function incrementalIdStartingFromRandomByte() {\n  let i = Math.floor(Math.random() * 256) & 0xff;\n\n  return () => {\n    return i++;\n  };\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","/**\n * Obliterator Iterator Class\n * ===========================\n *\n * Simple class representing the library's iterators.\n */\n\n/**\n * Iterator class.\n *\n * @constructor\n * @param {function} next - Next function.\n */\nfunction Iterator(next) {\n  if (typeof next !== 'function')\n    throw new Error('obliterator/iterator: expecting a function!');\n\n  this.next = next;\n}\n\n/**\n * If symbols are supported, we add `next` to `Symbol.iterator`.\n */\nif (typeof Symbol !== 'undefined')\n  Iterator.prototype[Symbol.iterator] = function () {\n    return this;\n  };\n\n/**\n * Returning an iterator of the given values.\n *\n * @param  {any...} values - Values.\n * @return {Iterator}\n */\nIterator.of = function () {\n  var args = arguments,\n    l = args.length,\n    i = 0;\n\n  return new Iterator(function () {\n    if (i >= l) return {done: true};\n\n    return {done: false, value: args[i++]};\n  });\n};\n\n/**\n * Returning an empty iterator.\n *\n * @return {Iterator}\n */\nIterator.empty = function () {\n  var iterator = new Iterator(function () {\n    return {done: true};\n  });\n\n  return iterator;\n};\n\n/**\n * Returning an iterator over the given indexed sequence.\n *\n * @param  {string|Array} sequence - Target sequence.\n * @return {Iterator}\n */\nIterator.fromSequence = function (sequence) {\n  var i = 0,\n    l = sequence.length;\n\n  return new Iterator(function () {\n    if (i >= l) return {done: true};\n\n    return {done: false, value: sequence[i++]};\n  });\n};\n\n/**\n * Returning whether the given value is an iterator.\n *\n * @param  {any} value - Value.\n * @return {boolean}\n */\nIterator.is = function (value) {\n  if (value instanceof Iterator) return true;\n\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    typeof value.next === 'function'\n  );\n};\n\n/**\n * Exporting.\n */\nmodule.exports = Iterator;\n","exports.ARRAY_BUFFER_SUPPORT = typeof ArrayBuffer !== 'undefined';\nexports.SYMBOL_SUPPORT = typeof Symbol !== 'undefined';\n","/**\n * Obliterator Iter Function\n * ==========================\n *\n * Function coercing values to an iterator. It can be quite useful when needing\n * to handle iterables and iterators the same way.\n */\nvar Iterator = require('./iterator.js');\nvar support = require('./support.js');\n\nvar ARRAY_BUFFER_SUPPORT = support.ARRAY_BUFFER_SUPPORT;\nvar SYMBOL_SUPPORT = support.SYMBOL_SUPPORT;\n\nfunction iterOrNull(target) {\n  // Indexed sequence\n  if (\n    typeof target === 'string' ||\n    Array.isArray(target) ||\n    (ARRAY_BUFFER_SUPPORT && ArrayBuffer.isView(target))\n  )\n    return Iterator.fromSequence(target);\n\n  // Invalid value\n  if (typeof target !== 'object' || target === null) return null;\n\n  // Iterable\n  if (SYMBOL_SUPPORT && typeof target[Symbol.iterator] === 'function')\n    return target[Symbol.iterator]();\n\n  // Iterator duck-typing\n  if (typeof target.next === 'function') return target;\n\n  // Invalid object\n  return null;\n}\n\nmodule.exports = function iter(target) {\n  var iterator = iterOrNull(target);\n\n  if (!iterator)\n    throw new Error(\n      'obliterator: target is not iterable nor a valid iterator.'\n    );\n\n  return iterator;\n};\n","/* eslint no-constant-condition: 0 */\n/**\n * Obliterator Take Function\n * ==========================\n *\n * Function taking n or every value of the given iterator and returns them\n * into an array.\n */\nvar iter = require('./iter.js');\n\n/**\n * Take.\n *\n * @param  {Iterable} iterable - Target iterable.\n * @param  {number}   [n]      - Optional number of items to take.\n * @return {array}\n */\nmodule.exports = function take(iterable, n) {\n  var l = arguments.length > 1 ? n : Infinity,\n    array = l !== Infinity ? new Array(l) : [],\n    step,\n    i = 0;\n\n  var iterator = iter(iterable);\n\n  while (true) {\n    if (i === l) return array;\n\n    step = iterator.next();\n\n    if (step.done) {\n      if (i !== n) array.length = i;\n\n      return array;\n    }\n\n    array[i++] = step.value;\n  }\n};\n","/**\n * Graphology Custom Errors\n * =========================\n *\n * Defining custom errors for ease of use & easy unit tests across\n * implementations (normalized typology rather than relying on error\n * messages to check whether the correct error was found).\n */\nexport class GraphError extends Error {\n  constructor(message) {\n    super();\n    this.name = 'GraphError';\n    this.message = message;\n  }\n}\n\nexport class InvalidArgumentsGraphError extends GraphError {\n  constructor(message) {\n    super(message);\n    this.name = 'InvalidArgumentsGraphError';\n\n    // This is V8 specific to enhance stack readability\n    if (typeof Error.captureStackTrace === 'function')\n      Error.captureStackTrace(\n        this,\n        InvalidArgumentsGraphError.prototype.constructor\n      );\n  }\n}\n\nexport class NotFoundGraphError extends GraphError {\n  constructor(message) {\n    super(message);\n    this.name = 'NotFoundGraphError';\n\n    // This is V8 specific to enhance stack readability\n    if (typeof Error.captureStackTrace === 'function')\n      Error.captureStackTrace(this, NotFoundGraphError.prototype.constructor);\n  }\n}\n\nexport class UsageGraphError extends GraphError {\n  constructor(message) {\n    super(message);\n    this.name = 'UsageGraphError';\n\n    // This is V8 specific to enhance stack readability\n    if (typeof Error.captureStackTrace === 'function')\n      Error.captureStackTrace(this, UsageGraphError.prototype.constructor);\n  }\n}\n","/**\n * Graphology Internal Data Classes\n * =================================\n *\n * Internal classes hopefully reduced to structs by engines & storing\n * necessary information for nodes & edges.\n *\n * Note that those classes don't rely on the `class` keyword to avoid some\n * cruft introduced by most of ES2015 transpilers.\n */\n\n/**\n * MixedNodeData class.\n *\n * @constructor\n * @param {string} string     - The node's key.\n * @param {object} attributes - Node's attributes.\n */\nexport function MixedNodeData(key, attributes) {\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n\n  this.clear();\n}\n\nMixedNodeData.prototype.clear = function () {\n  // Degrees\n  this.inDegree = 0;\n  this.outDegree = 0;\n  this.undirectedDegree = 0;\n\n  // Indices\n  this.in = {};\n  this.out = {};\n  this.undirected = {};\n};\n\n/**\n * DirectedNodeData class.\n *\n * @constructor\n * @param {string} string     - The node's key.\n * @param {object} attributes - Node's attributes.\n */\nexport function DirectedNodeData(key, attributes) {\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n\n  this.clear();\n}\n\nDirectedNodeData.prototype.clear = function () {\n  // Degrees\n  this.inDegree = 0;\n  this.outDegree = 0;\n\n  // Indices\n  this.in = {};\n  this.out = {};\n};\n\n/**\n * UndirectedNodeData class.\n *\n * @constructor\n * @param {string} string     - The node's key.\n * @param {object} attributes - Node's attributes.\n */\nexport function UndirectedNodeData(key, attributes) {\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n\n  this.clear();\n}\n\nUndirectedNodeData.prototype.clear = function () {\n  // Degrees\n  this.undirectedDegree = 0;\n\n  // Indices\n  this.undirected = {};\n};\n\n/**\n * EdgeData class.\n *\n * @constructor\n * @param {boolean} undirected   - Whether the edge is undirected.\n * @param {string}  string       - The edge's key.\n * @param {string}  source       - Source of the edge.\n * @param {string}  target       - Target of the edge.\n * @param {object}  attributes   - Edge's attributes.\n */\nexport function EdgeData(undirected, key, source, target, attributes) {\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n  this.undirected = undirected;\n\n  // Extremities\n  this.source = source;\n  this.target = target;\n}\n\nEdgeData.prototype.attach = function () {\n  let outKey = 'out';\n  let inKey = 'in';\n\n  if (this.undirected) outKey = inKey = 'undirected';\n\n  const source = this.source.key;\n  const target = this.target.key;\n\n  // Handling source\n  this.source[outKey][target] = this;\n\n  if (this.undirected && source === target) return;\n\n  // Handling target\n  this.target[inKey][source] = this;\n};\n\nEdgeData.prototype.attachMulti = function () {\n  let outKey = 'out';\n  let inKey = 'in';\n\n  const source = this.source.key;\n  const target = this.target.key;\n\n  if (this.undirected) outKey = inKey = 'undirected';\n\n  // Handling source\n  const adj = this.source[outKey];\n  const head = adj[target];\n\n  if (typeof head === 'undefined') {\n    adj[target] = this;\n\n    // Self-loop optimization\n    if (!(this.undirected && source === target)) {\n      // Handling target\n      this.target[inKey][source] = this;\n    }\n\n    return;\n  }\n\n  // Prepending to doubly-linked list\n  head.previous = this;\n  this.next = head;\n\n  // Pointing to new head\n  // NOTE: use mutating swap later to avoid lookup?\n  adj[target] = this;\n  this.target[inKey][source] = this;\n};\n\nEdgeData.prototype.detach = function () {\n  const source = this.source.key;\n  const target = this.target.key;\n\n  let outKey = 'out';\n  let inKey = 'in';\n\n  if (this.undirected) outKey = inKey = 'undirected';\n\n  delete this.source[outKey][target];\n\n  // No-op delete in case of undirected self-loop\n  delete this.target[inKey][source];\n};\n\nEdgeData.prototype.detachMulti = function () {\n  const source = this.source.key;\n  const target = this.target.key;\n\n  let outKey = 'out';\n  let inKey = 'in';\n\n  if (this.undirected) outKey = inKey = 'undirected';\n\n  // Deleting from doubly-linked list\n  if (this.previous === undefined) {\n    // We are dealing with the head\n\n    // Should we delete the adjacency entry because it is now empty?\n    if (this.next === undefined) {\n      delete this.source[outKey][target];\n\n      // No-op delete in case of undirected self-loop\n      delete this.target[inKey][source];\n    } else {\n      // Detaching\n      this.next.previous = undefined;\n\n      // NOTE: could avoid the lookups by creating a #.become mutating method\n      this.source[outKey][target] = this.next;\n\n      // No-op delete in case of undirected self-loop\n      this.target[inKey][source] = this.next;\n    }\n  } else {\n    // We are dealing with another list node\n    this.previous.next = this.next;\n\n    // If not last\n    if (this.next !== undefined) {\n      this.next.previous = this.previous;\n    }\n  }\n};\n","/**\n * Graphology Node Attributes methods\n * ===================================\n */\nimport {assign, isPlainObject} from '../utils';\n\nimport {InvalidArgumentsGraphError, NotFoundGraphError} from '../errors';\n\nconst NODE = 0;\nconst SOURCE = 1;\nconst TARGET = 2;\nconst OPPOSITE = 3;\n\nfunction findRelevantNodeData(\n  graph,\n  method,\n  mode,\n  nodeOrEdge,\n  nameOrEdge,\n  add1,\n  add2\n) {\n  let nodeData, edgeData, arg1, arg2;\n\n  nodeOrEdge = '' + nodeOrEdge;\n\n  if (mode === NODE) {\n    nodeData = graph._nodes.get(nodeOrEdge);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${nodeOrEdge}\" node in the graph.`\n      );\n\n    arg1 = nameOrEdge;\n    arg2 = add1;\n  } else if (mode === OPPOSITE) {\n    nameOrEdge = '' + nameOrEdge;\n\n    edgeData = graph._edges.get(nameOrEdge);\n\n    if (!edgeData)\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${nameOrEdge}\" edge in the graph.`\n      );\n\n    const source = edgeData.source.key;\n    const target = edgeData.target.key;\n\n    if (nodeOrEdge === source) {\n      nodeData = edgeData.target;\n    } else if (nodeOrEdge === target) {\n      nodeData = edgeData.source;\n    } else {\n      throw new NotFoundGraphError(\n        `Graph.${method}: the \"${nodeOrEdge}\" node is not attached to the \"${nameOrEdge}\" edge (${source}, ${target}).`\n      );\n    }\n\n    arg1 = add1;\n    arg2 = add2;\n  } else {\n    edgeData = graph._edges.get(nodeOrEdge);\n\n    if (!edgeData)\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${nodeOrEdge}\" edge in the graph.`\n      );\n\n    if (mode === SOURCE) {\n      nodeData = edgeData.source;\n    } else {\n      nodeData = edgeData.target;\n    }\n\n    arg1 = nameOrEdge;\n    arg2 = add1;\n  }\n\n  return [nodeData, arg1, arg2];\n}\n\nfunction attachNodeAttributeGetter(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, name] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    return data.attributes[name];\n  };\n}\n\nfunction attachNodeAttributesGetter(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge) {\n    const [data] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge\n    );\n\n    return data.attributes;\n  };\n}\n\nfunction attachNodeAttributeChecker(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, name] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    return data.attributes.hasOwnProperty(name);\n  };\n}\n\nfunction attachNodeAttributeSetter(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1, add2) {\n    const [data, name, value] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1,\n      add2\n    );\n\n    data.attributes[name] = value;\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\nfunction attachNodeAttributeUpdater(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1, add2) {\n    const [data, name, updater] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1,\n      add2\n    );\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: updater should be a function.`\n      );\n\n    const attributes = data.attributes;\n    const value = updater(attributes[name]);\n\n    attributes[name] = value;\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\nfunction attachNodeAttributeRemover(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, name] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    delete data.attributes[name];\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'remove',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\nfunction attachNodeAttributesReplacer(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, attributes] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided attributes are not a plain object.`\n      );\n\n    data.attributes = attributes;\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'replace',\n      attributes: data.attributes\n    });\n\n    return this;\n  };\n}\n\nfunction attachNodeAttributesMerger(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, attributes] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided attributes are not a plain object.`\n      );\n\n    assign(data.attributes, attributes);\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'merge',\n      attributes: data.attributes,\n      data: attributes\n    });\n\n    return this;\n  };\n}\n\nfunction attachNodeAttributesUpdater(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, updater] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided updater is not a function.`\n      );\n\n    data.attributes = updater(data.attributes);\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'update',\n      attributes: data.attributes\n    });\n\n    return this;\n  };\n}\n\n/**\n * List of methods to attach.\n */\nconst NODE_ATTRIBUTES_METHODS = [\n  {\n    name: element => `get${element}Attribute`,\n    attacher: attachNodeAttributeGetter\n  },\n  {\n    name: element => `get${element}Attributes`,\n    attacher: attachNodeAttributesGetter\n  },\n  {\n    name: element => `has${element}Attribute`,\n    attacher: attachNodeAttributeChecker\n  },\n  {\n    name: element => `set${element}Attribute`,\n    attacher: attachNodeAttributeSetter\n  },\n  {\n    name: element => `update${element}Attribute`,\n    attacher: attachNodeAttributeUpdater\n  },\n  {\n    name: element => `remove${element}Attribute`,\n    attacher: attachNodeAttributeRemover\n  },\n  {\n    name: element => `replace${element}Attributes`,\n    attacher: attachNodeAttributesReplacer\n  },\n  {\n    name: element => `merge${element}Attributes`,\n    attacher: attachNodeAttributesMerger\n  },\n  {\n    name: element => `update${element}Attributes`,\n    attacher: attachNodeAttributesUpdater\n  }\n];\n\n/**\n * Attach every attributes-related methods to a Graph class.\n *\n * @param {function} Graph - Target class.\n */\nexport default function attachNodeAttributesMethods(Graph) {\n  NODE_ATTRIBUTES_METHODS.forEach(function ({name, attacher}) {\n    // For nodes\n    attacher(Graph, name('Node'), NODE);\n\n    // For sources\n    attacher(Graph, name('Source'), SOURCE);\n\n    // For targets\n    attacher(Graph, name('Target'), TARGET);\n\n    // For opposites\n    attacher(Graph, name('Opposite'), OPPOSITE);\n  });\n}\n","/**\n * Graphology Edge Attributes methods\n * ===================================\n */\nimport {assign, isPlainObject, getMatchingEdge} from '../utils';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError,\n  UsageGraphError\n} from '../errors';\n\n/**\n * Attach an attribute getter method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributeGetter(Class, method, type) {\n  /**\n   * Get the desired attribute for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   *\n   * @return {mixed}          - The attribute's value.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element;\n      const target = '' + name;\n\n      name = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    return data.attributes[name];\n  };\n}\n\n/**\n * Attach an attributes getter method onto the provided class.\n *\n * @param {function} Class       - Target class.\n * @param {string}   method      - Method name.\n * @param {string}   type        - Type of the edge to find.\n */\nfunction attachEdgeAttributesGetter(Class, method, type) {\n  /**\n   * Retrieves all the target element's attributes.\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   *\n   * @return {object}          - The element's attributes.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 1) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + arguments[1];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    return data.attributes;\n  };\n}\n\n/**\n * Attach an attribute checker method onto the provided class.\n *\n * @param {function} Class       - Target class.\n * @param {string}   method      - Method name.\n * @param {string}   type        - Type of the edge to find.\n */\nfunction attachEdgeAttributeChecker(Class, method, type) {\n  /**\n   * Checks whether the desired attribute is set for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element;\n      const target = '' + name;\n\n      name = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    return data.attributes.hasOwnProperty(name);\n  };\n}\n\n/**\n * Attach an attribute setter method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributeSetter(Class, method, type) {\n  /**\n   * Set the desired attribute for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   * @param  {mixed}  value   - New attribute value.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   * @param  {mixed}  value   - New attribute value.\n   *\n   * @return {Graph}          - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name, value) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 3) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element;\n      const target = '' + name;\n\n      name = arguments[2];\n      value = arguments[3];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    data.attributes[name] = value;\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute updater method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributeUpdater(Class, method, type) {\n  /**\n   * Update the desired attribute for the given element (node or edge) using\n   * the provided function.\n   *\n   * Arity 2:\n   * @param  {any}      element - Target element.\n   * @param  {string}   name    - Attribute's name.\n   * @param  {function} updater - Updater function.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}      source  - Source element.\n   * @param  {any}      target  - Target element.\n   * @param  {string}   name    - Attribute's name.\n   * @param  {function} updater - Updater function.\n   *\n   * @return {Graph}            - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name, updater) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 3) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element;\n      const target = '' + name;\n\n      name = arguments[2];\n      updater = arguments[3];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: updater should be a function.`\n      );\n\n    data.attributes[name] = updater(data.attributes[name]);\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute remover method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributeRemover(Class, method, type) {\n  /**\n   * Remove the desired attribute for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   *\n   * @return {Graph}          - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element;\n      const target = '' + name;\n\n      name = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    delete data.attributes[name];\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'remove',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute replacer method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributesReplacer(Class, method, type) {\n  /**\n   * Replace the attributes for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element    - Target element.\n   * @param  {object} attributes - New attributes.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source     - Source element.\n   * @param  {any}     target     - Target element.\n   * @param  {object}  attributes - New attributes.\n   *\n   * @return {Graph}              - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, attributes) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + attributes;\n\n      attributes = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided attributes are not a plain object.`\n      );\n\n    data.attributes = attributes;\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'replace',\n      attributes: data.attributes\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute merger method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributesMerger(Class, method, type) {\n  /**\n   * Merge the attributes for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element    - Target element.\n   * @param  {object} attributes - Attributes to merge.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source     - Source element.\n   * @param  {any}     target     - Target element.\n   * @param  {object}  attributes - Attributes to merge.\n   *\n   * @return {Graph}              - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, attributes) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + attributes;\n\n      attributes = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided attributes are not a plain object.`\n      );\n\n    assign(data.attributes, attributes);\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'merge',\n      attributes: data.attributes,\n      data: attributes\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute updater method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributesUpdater(Class, method, type) {\n  /**\n   * Update the attributes of the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}      element - Target element.\n   * @param  {function} updater - Updater function.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}      source  - Source element.\n   * @param  {any}      target  - Target element.\n   * @param  {function} updater - Updater function.\n   *\n   * @return {Graph}            - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, updater) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + updater;\n\n      updater = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided updater is not a function.`\n      );\n\n    data.attributes = updater(data.attributes);\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'update',\n      attributes: data.attributes\n    });\n\n    return this;\n  };\n}\n\n/**\n * List of methods to attach.\n */\nconst EDGE_ATTRIBUTES_METHODS = [\n  {\n    name: element => `get${element}Attribute`,\n    attacher: attachEdgeAttributeGetter\n  },\n  {\n    name: element => `get${element}Attributes`,\n    attacher: attachEdgeAttributesGetter\n  },\n  {\n    name: element => `has${element}Attribute`,\n    attacher: attachEdgeAttributeChecker\n  },\n  {\n    name: element => `set${element}Attribute`,\n    attacher: attachEdgeAttributeSetter\n  },\n  {\n    name: element => `update${element}Attribute`,\n    attacher: attachEdgeAttributeUpdater\n  },\n  {\n    name: element => `remove${element}Attribute`,\n    attacher: attachEdgeAttributeRemover\n  },\n  {\n    name: element => `replace${element}Attributes`,\n    attacher: attachEdgeAttributesReplacer\n  },\n  {\n    name: element => `merge${element}Attributes`,\n    attacher: attachEdgeAttributesMerger\n  },\n  {\n    name: element => `update${element}Attributes`,\n    attacher: attachEdgeAttributesUpdater\n  }\n];\n\n/**\n * Attach every attributes-related methods to a Graph class.\n *\n * @param {function} Graph - Target class.\n */\nexport default function attachEdgeAttributesMethods(Graph) {\n  EDGE_ATTRIBUTES_METHODS.forEach(function ({name, attacher}) {\n    // For edges\n    attacher(Graph, name('Edge'), 'mixed');\n\n    // For directed edges\n    attacher(Graph, name('DirectedEdge'), 'directed');\n\n    // For undirected edges\n    attacher(Graph, name('UndirectedEdge'), 'undirected');\n  });\n}\n","/**\n * Obliterator Chain Function\n * ===========================\n *\n * Variadic function combining the given iterables.\n */\nvar Iterator = require('./iterator.js');\nvar iter = require('./iter.js');\n\n/**\n * Chain.\n *\n * @param  {...Iterator} iterables - Target iterables.\n * @return {Iterator}\n */\nmodule.exports = function chain() {\n  var iterables = arguments;\n  var current = null;\n  var i = -1;\n\n  /* eslint-disable no-constant-condition */\n  return new Iterator(function next() {\n    var step = null;\n\n    do {\n      if (current === null) {\n        i++;\n\n        if (i >= iterables.length) return {done: true};\n\n        current = iter(iterables[i]);\n      }\n\n      step = current.next();\n\n      if (step.done === true) {\n        current = null;\n        continue;\n      }\n\n      break;\n    } while (true);\n\n    return step;\n  });\n};\n","/**\n * Graphology Edge Iteration\n * ==========================\n *\n * Attaching some methods to the Graph class to be able to iterate over a\n * graph's edges.\n */\nimport Iterator from 'obliterator/iterator';\nimport chain from 'obliterator/chain';\nimport take from 'obliterator/take';\n\nimport {InvalidArgumentsGraphError, NotFoundGraphError} from '../errors';\n\n/**\n * Definitions.\n */\nconst EDGES_ITERATION = [\n  {\n    name: 'edges',\n    type: 'mixed'\n  },\n  {\n    name: 'inEdges',\n    type: 'directed',\n    direction: 'in'\n  },\n  {\n    name: 'outEdges',\n    type: 'directed',\n    direction: 'out'\n  },\n  {\n    name: 'inboundEdges',\n    type: 'mixed',\n    direction: 'in'\n  },\n  {\n    name: 'outboundEdges',\n    type: 'mixed',\n    direction: 'out'\n  },\n  {\n    name: 'directedEdges',\n    type: 'directed'\n  },\n  {\n    name: 'undirectedEdges',\n    type: 'undirected'\n  }\n];\n\n/**\n * Function iterating over edges from the given object to match one of them.\n *\n * @param {object}   object   - Target object.\n * @param {function} callback - Function to call.\n */\nfunction forEachSimple(breakable, object, callback, avoid) {\n  let shouldBreak = false;\n\n  for (const k in object) {\n    if (k === avoid) continue;\n\n    const edgeData = object[k];\n\n    shouldBreak = callback(\n      edgeData.key,\n      edgeData.attributes,\n      edgeData.source.key,\n      edgeData.target.key,\n      edgeData.source.attributes,\n      edgeData.target.attributes,\n      edgeData.undirected\n    );\n\n    if (breakable && shouldBreak) return edgeData.key;\n  }\n\n  return;\n}\n\nfunction forEachMulti(breakable, object, callback, avoid) {\n  let edgeData, source, target;\n\n  let shouldBreak = false;\n\n  for (const k in object) {\n    if (k === avoid) continue;\n\n    edgeData = object[k];\n\n    do {\n      source = edgeData.source;\n      target = edgeData.target;\n\n      shouldBreak = callback(\n        edgeData.key,\n        edgeData.attributes,\n        source.key,\n        target.key,\n        source.attributes,\n        target.attributes,\n        edgeData.undirected\n      );\n\n      if (breakable && shouldBreak) return edgeData.key;\n\n      edgeData = edgeData.next;\n    } while (edgeData !== undefined);\n  }\n\n  return;\n}\n\n/**\n * Function returning an iterator over edges from the given object.\n *\n * @param  {object}   object - Target object.\n * @return {Iterator}\n */\nfunction createIterator(object, avoid) {\n  const keys = Object.keys(object);\n  const l = keys.length;\n\n  let edgeData;\n  let i = 0;\n\n  return new Iterator(function next() {\n    do {\n      if (!edgeData) {\n        if (i >= l) return {done: true};\n\n        const k = keys[i++];\n\n        if (k === avoid) {\n          edgeData = undefined;\n          continue;\n        }\n\n        edgeData = object[k];\n      } else {\n        edgeData = edgeData.next;\n      }\n    } while (!edgeData);\n\n    return {\n      done: false,\n      value: {\n        edge: edgeData.key,\n        attributes: edgeData.attributes,\n        source: edgeData.source.key,\n        target: edgeData.target.key,\n        sourceAttributes: edgeData.source.attributes,\n        targetAttributes: edgeData.target.attributes,\n        undirected: edgeData.undirected\n      }\n    };\n  });\n}\n\n/**\n * Function iterating over the egdes from the object at given key to match\n * one of them.\n *\n * @param {object}   object   - Target object.\n * @param {mixed}    k        - Neighbor key.\n * @param {function} callback - Callback to use.\n */\nfunction forEachForKeySimple(breakable, object, k, callback) {\n  const edgeData = object[k];\n\n  if (!edgeData) return;\n\n  const sourceData = edgeData.source;\n  const targetData = edgeData.target;\n\n  if (\n    callback(\n      edgeData.key,\n      edgeData.attributes,\n      sourceData.key,\n      targetData.key,\n      sourceData.attributes,\n      targetData.attributes,\n      edgeData.undirected\n    ) &&\n    breakable\n  )\n    return edgeData.key;\n}\n\nfunction forEachForKeyMulti(breakable, object, k, callback) {\n  let edgeData = object[k];\n\n  if (!edgeData) return;\n\n  let shouldBreak = false;\n\n  do {\n    shouldBreak = callback(\n      edgeData.key,\n      edgeData.attributes,\n      edgeData.source.key,\n      edgeData.target.key,\n      edgeData.source.attributes,\n      edgeData.target.attributes,\n      edgeData.undirected\n    );\n\n    if (breakable && shouldBreak) return edgeData.key;\n\n    edgeData = edgeData.next;\n  } while (edgeData !== undefined);\n\n  return;\n}\n\n/**\n * Function returning an iterator over the egdes from the object at given key.\n *\n * @param  {object}   object   - Target object.\n * @param  {mixed}    k        - Neighbor key.\n * @return {Iterator}\n */\nfunction createIteratorForKey(object, k) {\n  let edgeData = object[k];\n\n  if (edgeData.next !== undefined) {\n    return new Iterator(function () {\n      if (!edgeData) return {done: true};\n\n      const value = {\n        edge: edgeData.key,\n        attributes: edgeData.attributes,\n        source: edgeData.source.key,\n        target: edgeData.target.key,\n        sourceAttributes: edgeData.source.attributes,\n        targetAttributes: edgeData.target.attributes,\n        undirected: edgeData.undirected\n      };\n\n      edgeData = edgeData.next;\n\n      return {\n        done: false,\n        value\n      };\n    });\n  }\n\n  return Iterator.of({\n    edge: edgeData.key,\n    attributes: edgeData.attributes,\n    source: edgeData.source.key,\n    target: edgeData.target.key,\n    sourceAttributes: edgeData.source.attributes,\n    targetAttributes: edgeData.target.attributes,\n    undirected: edgeData.undirected\n  });\n}\n\n/**\n * Function creating an array of edges for the given type.\n *\n * @param  {Graph}   graph - Target Graph instance.\n * @param  {string}  type  - Type of edges to retrieve.\n * @return {array}         - Array of edges.\n */\nfunction createEdgeArray(graph, type) {\n  if (graph.size === 0) return [];\n\n  if (type === 'mixed' || type === graph.type) {\n    if (typeof Array.from === 'function')\n      return Array.from(graph._edges.keys());\n\n    return take(graph._edges.keys(), graph._edges.size);\n  }\n\n  const size =\n    type === 'undirected' ? graph.undirectedSize : graph.directedSize;\n\n  const list = new Array(size),\n    mask = type === 'undirected';\n\n  const iterator = graph._edges.values();\n\n  let i = 0;\n  let step, data;\n\n  while (((step = iterator.next()), step.done !== true)) {\n    data = step.value;\n\n    if (data.undirected === mask) list[i++] = data.key;\n  }\n\n  return list;\n}\n\n/**\n * Function iterating over a graph's edges using a callback to match one of\n * them.\n *\n * @param  {Graph}    graph    - Target Graph instance.\n * @param  {string}   type     - Type of edges to retrieve.\n * @param  {function} callback - Function to call.\n */\nfunction forEachEdge(breakable, graph, type, callback) {\n  if (graph.size === 0) return;\n\n  const shouldFilter = type !== 'mixed' && type !== graph.type;\n  const mask = type === 'undirected';\n\n  let step, data;\n  let shouldBreak = false;\n  const iterator = graph._edges.values();\n\n  while (((step = iterator.next()), step.done !== true)) {\n    data = step.value;\n\n    if (shouldFilter && data.undirected !== mask) continue;\n\n    const {key, attributes, source, target} = data;\n\n    shouldBreak = callback(\n      key,\n      attributes,\n      source.key,\n      target.key,\n      source.attributes,\n      target.attributes,\n      data.undirected\n    );\n\n    if (breakable && shouldBreak) return key;\n  }\n\n  return;\n}\n\n/**\n * Function creating an iterator of edges for the given type.\n *\n * @param  {Graph}    graph - Target Graph instance.\n * @param  {string}   type  - Type of edges to retrieve.\n * @return {Iterator}\n */\nfunction createEdgeIterator(graph, type) {\n  if (graph.size === 0) return Iterator.empty();\n\n  const shouldFilter = type !== 'mixed' && type !== graph.type;\n  const mask = type === 'undirected';\n\n  const iterator = graph._edges.values();\n\n  return new Iterator(function next() {\n    let step, data;\n\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      step = iterator.next();\n\n      if (step.done) return step;\n\n      data = step.value;\n\n      if (shouldFilter && data.undirected !== mask) continue;\n\n      break;\n    }\n\n    const value = {\n      edge: data.key,\n      attributes: data.attributes,\n      source: data.source.key,\n      target: data.target.key,\n      sourceAttributes: data.source.attributes,\n      targetAttributes: data.target.attributes,\n      undirected: data.undirected\n    };\n\n    return {value, done: false};\n  });\n}\n\n/**\n * Function iterating over a node's edges using a callback to match one of them.\n *\n * @param  {boolean}  multi     - Whether the graph is multi or not.\n * @param  {string}   type      - Type of edges to retrieve.\n * @param  {string}   direction - In or out?\n * @param  {any}      nodeData  - Target node's data.\n * @param  {function} callback  - Function to call.\n */\nfunction forEachEdgeForNode(\n  breakable,\n  multi,\n  type,\n  direction,\n  nodeData,\n  callback\n) {\n  const fn = multi ? forEachMulti : forEachSimple;\n\n  let found;\n\n  if (type !== 'undirected') {\n    if (direction !== 'out') {\n      found = fn(breakable, nodeData.in, callback);\n\n      if (breakable && found) return found;\n    }\n    if (direction !== 'in') {\n      found = fn(\n        breakable,\n        nodeData.out,\n        callback,\n        !direction ? nodeData.key : undefined\n      );\n\n      if (breakable && found) return found;\n    }\n  }\n\n  if (type !== 'directed') {\n    found = fn(breakable, nodeData.undirected, callback);\n\n    if (breakable && found) return found;\n  }\n\n  return;\n}\n\n/**\n * Function creating an array of edges for the given type & the given node.\n *\n * @param  {boolean} multi     - Whether the graph is multi or not.\n * @param  {string}  type      - Type of edges to retrieve.\n * @param  {string}  direction - In or out?\n * @param  {any}     nodeData  - Target node's data.\n * @return {array}             - Array of edges.\n */\nfunction createEdgeArrayForNode(multi, type, direction, nodeData) {\n  const edges = []; // TODO: possibility to know size beforehand or factorize with map\n\n  forEachEdgeForNode(false, multi, type, direction, nodeData, function (key) {\n    edges.push(key);\n  });\n\n  return edges;\n}\n\n/**\n * Function iterating over a node's edges using a callback.\n *\n * @param  {string}   type      - Type of edges to retrieve.\n * @param  {string}   direction - In or out?\n * @param  {any}      nodeData  - Target node's data.\n * @return {Iterator}\n */\nfunction createEdgeIteratorForNode(type, direction, nodeData) {\n  let iterator = Iterator.empty();\n\n  if (type !== 'undirected') {\n    if (direction !== 'out' && typeof nodeData.in !== 'undefined')\n      iterator = chain(iterator, createIterator(nodeData.in));\n    if (direction !== 'in' && typeof nodeData.out !== 'undefined')\n      iterator = chain(\n        iterator,\n        createIterator(nodeData.out, !direction ? nodeData.key : undefined)\n      );\n  }\n\n  if (type !== 'directed' && typeof nodeData.undirected !== 'undefined') {\n    iterator = chain(iterator, createIterator(nodeData.undirected));\n  }\n\n  return iterator;\n}\n\n/**\n * Function iterating over edges for the given path using a callback to match\n * one of them.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {boolean}  multi      - Whether the graph is multi.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {string}   target     - Target node.\n * @param  {function} callback   - Function to call.\n */\nfunction forEachEdgeForPath(\n  breakable,\n  type,\n  multi,\n  direction,\n  sourceData,\n  target,\n  callback\n) {\n  const fn = multi ? forEachForKeyMulti : forEachForKeySimple;\n\n  let found;\n\n  if (type !== 'undirected') {\n    if (typeof sourceData.in !== 'undefined' && direction !== 'out') {\n      found = fn(breakable, sourceData.in, target, callback);\n\n      if (breakable && found) return found;\n    }\n\n    if (\n      typeof sourceData.out !== 'undefined' &&\n      direction !== 'in' &&\n      (direction || sourceData.key !== target)\n    ) {\n      found = fn(breakable, sourceData.out, target, callback);\n\n      if (breakable && found) return found;\n    }\n  }\n\n  if (type !== 'directed') {\n    if (typeof sourceData.undirected !== 'undefined') {\n      found = fn(breakable, sourceData.undirected, target, callback);\n\n      if (breakable && found) return found;\n    }\n  }\n\n  return;\n}\n\n/**\n * Function creating an array of edges for the given path.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {boolean}  multi      - Whether the graph is multi.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {any}      target     - Target node.\n * @return {array}               - Array of edges.\n */\nfunction createEdgeArrayForPath(type, multi, direction, sourceData, target) {\n  const edges = []; // TODO: possibility to know size beforehand or factorize with map\n\n  forEachEdgeForPath(\n    false,\n    type,\n    multi,\n    direction,\n    sourceData,\n    target,\n    function (key) {\n      edges.push(key);\n    }\n  );\n\n  return edges;\n}\n\n/**\n * Function returning an iterator over edges for the given path.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {string}   target     - Target node.\n * @param  {function} callback   - Function to call.\n */\nfunction createEdgeIteratorForPath(type, direction, sourceData, target) {\n  let iterator = Iterator.empty();\n\n  if (type !== 'undirected') {\n    if (\n      typeof sourceData.in !== 'undefined' &&\n      direction !== 'out' &&\n      target in sourceData.in\n    )\n      iterator = chain(iterator, createIteratorForKey(sourceData.in, target));\n\n    if (\n      typeof sourceData.out !== 'undefined' &&\n      direction !== 'in' &&\n      target in sourceData.out &&\n      (direction || sourceData.key !== target)\n    )\n      iterator = chain(iterator, createIteratorForKey(sourceData.out, target));\n  }\n\n  if (type !== 'directed') {\n    if (\n      typeof sourceData.undirected !== 'undefined' &&\n      target in sourceData.undirected\n    )\n      iterator = chain(\n        iterator,\n        createIteratorForKey(sourceData.undirected, target)\n      );\n  }\n\n  return iterator;\n}\n\n/**\n * Function attaching an edge array creator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachEdgeArrayCreator(Class, description) {\n  const {name, type, direction} = description;\n\n  /**\n   * Function returning an array of certain edges.\n   *\n   * Arity 0: Return all the relevant edges.\n   *\n   * Arity 1: Return all of a node's relevant edges.\n   * @param  {any}   node   - Target node.\n   *\n   * Arity 2: Return the relevant edges across the given path.\n   * @param  {any}   source - Source node.\n   * @param  {any}   target - Target node.\n   *\n   * @return {array|number} - The edges or the number of edges.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[name] = function (source, target) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return [];\n\n    if (!arguments.length) return createEdgeArray(this, type);\n\n    if (arguments.length === 1) {\n      source = '' + source;\n\n      const nodeData = this._nodes.get(source);\n\n      if (typeof nodeData === 'undefined')\n        throw new NotFoundGraphError(\n          `Graph.${name}: could not find the \"${source}\" node in the graph.`\n        );\n\n      // Iterating over a node's edges\n      return createEdgeArrayForNode(\n        this.multi,\n        type === 'mixed' ? this.type : type,\n        direction,\n        nodeData\n      );\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${name}:  could not find the \"${source}\" source node in the graph.`\n        );\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(\n          `Graph.${name}:  could not find the \"${target}\" target node in the graph.`\n        );\n\n      // Iterating over the edges between source & target\n      return createEdgeArrayForPath(\n        type,\n        this.multi,\n        direction,\n        sourceData,\n        target\n      );\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.${name}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`\n    );\n  };\n}\n\n/**\n * Function attaching a edge callback iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachForEachEdge(Class, description) {\n  const {name, type, direction} = description;\n\n  const forEachName = 'forEach' + name[0].toUpperCase() + name.slice(1, -1);\n\n  /**\n   * Function iterating over the graph's relevant edges by applying the given\n   * callback.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[forEachName] = function (source, target, callback) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type) return;\n\n    if (arguments.length === 1) {\n      callback = source;\n      return forEachEdge(false, this, type, callback);\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      callback = target;\n\n      const nodeData = this._nodes.get(source);\n\n      if (typeof nodeData === 'undefined')\n        throw new NotFoundGraphError(\n          `Graph.${forEachName}: could not find the \"${source}\" node in the graph.`\n        );\n\n      // Iterating over a node's edges\n      // TODO: maybe attach the sub method to the instance dynamically?\n      return forEachEdgeForNode(\n        false,\n        this.multi,\n        type === 'mixed' ? this.type : type,\n        direction,\n        nodeData,\n        callback\n      );\n    }\n\n    if (arguments.length === 3) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${forEachName}:  could not find the \"${source}\" source node in the graph.`\n        );\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(\n          `Graph.${forEachName}:  could not find the \"${target}\" target node in the graph.`\n        );\n\n      // Iterating over the edges between source & target\n      return forEachEdgeForPath(\n        false,\n        type,\n        this.multi,\n        direction,\n        sourceData,\n        target,\n        callback\n      );\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.${forEachName}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`\n    );\n  };\n\n  /**\n   * Function mapping the graph's relevant edges by applying the given\n   * callback.\n   *\n   * Arity 1: Map all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Map all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Map the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const mapName = 'map' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[mapName] = function () {\n    const args = Array.prototype.slice.call(arguments);\n    const callback = args.pop();\n\n    let result;\n\n    // We know the result length beforehand\n    if (args.length === 0) {\n      let length = 0;\n\n      if (type !== 'directed') length += this.undirectedSize;\n      if (type !== 'undirected') length += this.directedSize;\n\n      result = new Array(length);\n\n      let i = 0;\n\n      args.push((e, ea, s, t, sa, ta, u) => {\n        result[i++] = callback(e, ea, s, t, sa, ta, u);\n      });\n    }\n\n    // We don't know the result length beforehand\n    // TODO: we can in some instances of simple graphs, knowing degree\n    else {\n      result = [];\n\n      args.push((e, ea, s, t, sa, ta, u) => {\n        result.push(callback(e, ea, s, t, sa, ta, u));\n      });\n    }\n\n    this[forEachName].apply(this, args);\n\n    return result;\n  };\n\n  /**\n   * Function filtering the graph's relevant edges using the provided predicate\n   * function.\n   *\n   * Arity 1: Filter all the relevant edges.\n   * @param  {function} predicate - Predicate to use.\n   *\n   * Arity 2: Filter all of a node's relevant edges.\n   * @param  {any}      node      - Target node.\n   * @param  {function} predicate - Predicate to use.\n   *\n   * Arity 3: Filter the relevant edges across the given path.\n   * @param  {any}      source    - Source node.\n   * @param  {any}      target    - Target node.\n   * @param  {function} predicate - Predicate to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const filterName = 'filter' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[filterName] = function () {\n    const args = Array.prototype.slice.call(arguments);\n    const callback = args.pop();\n\n    const result = [];\n\n    args.push((e, ea, s, t, sa, ta, u) => {\n      if (callback(e, ea, s, t, sa, ta, u)) result.push(e);\n    });\n\n    this[forEachName].apply(this, args);\n\n    return result;\n  };\n\n  /**\n   * Function reducing the graph's relevant edges using the provided accumulator\n   * function.\n   *\n   * Arity 1: Reduce all the relevant edges.\n   * @param  {function} accumulator  - Accumulator to use.\n   * @param  {any}      initialValue - Initial value.\n   *\n   * Arity 2: Reduce all of a node's relevant edges.\n   * @param  {any}      node         - Target node.\n   * @param  {function} accumulator  - Accumulator to use.\n   * @param  {any}      initialValue - Initial value.\n   *\n   * Arity 3: Reduce the relevant edges across the given path.\n   * @param  {any}      source       - Source node.\n   * @param  {any}      target       - Target node.\n   * @param  {function} accumulator  - Accumulator to use.\n   * @param  {any}      initialValue - Initial value.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const reduceName = 'reduce' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[reduceName] = function () {\n    let args = Array.prototype.slice.call(arguments);\n\n    if (args.length < 2 || args.length > 4) {\n      throw new InvalidArgumentsGraphError(\n        `Graph.${reduceName}: invalid number of arguments (expecting 2, 3 or 4 and got ${args.length}).`\n      );\n    }\n\n    if (\n      typeof args[args.length - 1] === 'function' &&\n      typeof args[args.length - 2] !== 'function'\n    ) {\n      throw new InvalidArgumentsGraphError(\n        `Graph.${reduceName}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`\n      );\n    }\n\n    let callback;\n    let initialValue;\n\n    if (args.length === 2) {\n      callback = args[0];\n      initialValue = args[1];\n      args = [];\n    } else if (args.length === 3) {\n      callback = args[1];\n      initialValue = args[2];\n      args = [args[0]];\n    } else if (args.length === 4) {\n      callback = args[2];\n      initialValue = args[3];\n      args = [args[0], args[1]];\n    }\n\n    let accumulator = initialValue;\n\n    args.push((e, ea, s, t, sa, ta, u) => {\n      accumulator = callback(accumulator, e, ea, s, t, sa, ta, u);\n    });\n\n    this[forEachName].apply(this, args);\n\n    return accumulator;\n  };\n}\n\n/**\n * Function attaching a breakable edge callback iterator method to the Graph\n * prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachFindEdge(Class, description) {\n  const {name, type, direction} = description;\n\n  const findEdgeName = 'find' + name[0].toUpperCase() + name.slice(1, -1);\n\n  /**\n   * Function iterating over the graph's relevant edges in order to match\n   * one of them using the provided predicate function.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[findEdgeName] = function (source, target, callback) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return false;\n\n    if (arguments.length === 1) {\n      callback = source;\n      return forEachEdge(true, this, type, callback);\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      callback = target;\n\n      const nodeData = this._nodes.get(source);\n\n      if (typeof nodeData === 'undefined')\n        throw new NotFoundGraphError(\n          `Graph.${findEdgeName}: could not find the \"${source}\" node in the graph.`\n        );\n\n      // Iterating over a node's edges\n      // TODO: maybe attach the sub method to the instance dynamically?\n      return forEachEdgeForNode(\n        true,\n        this.multi,\n        type === 'mixed' ? this.type : type,\n        direction,\n        nodeData,\n        callback\n      );\n    }\n\n    if (arguments.length === 3) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${findEdgeName}:  could not find the \"${source}\" source node in the graph.`\n        );\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(\n          `Graph.${findEdgeName}:  could not find the \"${target}\" target node in the graph.`\n        );\n\n      // Iterating over the edges between source & target\n      return forEachEdgeForPath(\n        true,\n        type,\n        this.multi,\n        direction,\n        sourceData,\n        target,\n        callback\n      );\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.${findEdgeName}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`\n    );\n  };\n\n  /**\n   * Function iterating over the graph's relevant edges in order to assert\n   * whether any one of them matches the provided predicate function.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const someName = 'some' + name[0].toUpperCase() + name.slice(1, -1);\n\n  Class.prototype[someName] = function () {\n    const args = Array.prototype.slice.call(arguments);\n    const callback = args.pop();\n\n    args.push((e, ea, s, t, sa, ta, u) => {\n      return callback(e, ea, s, t, sa, ta, u);\n    });\n\n    const found = this[findEdgeName].apply(this, args);\n\n    if (found) return true;\n\n    return false;\n  };\n\n  /**\n   * Function iterating over the graph's relevant edges in order to assert\n   * whether all of them matche the provided predicate function.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const everyName = 'every' + name[0].toUpperCase() + name.slice(1, -1);\n\n  Class.prototype[everyName] = function () {\n    const args = Array.prototype.slice.call(arguments);\n    const callback = args.pop();\n\n    args.push((e, ea, s, t, sa, ta, u) => {\n      return !callback(e, ea, s, t, sa, ta, u);\n    });\n\n    const found = this[findEdgeName].apply(this, args);\n\n    if (found) return false;\n\n    return true;\n  };\n}\n\n/**\n * Function attaching an edge iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachEdgeIteratorCreator(Class, description) {\n  const {name: originalName, type, direction} = description;\n\n  const name = originalName.slice(0, -1) + 'Entries';\n\n  /**\n   * Function returning an iterator over the graph's edges.\n   *\n   * Arity 0: Iterate over all the relevant edges.\n   *\n   * Arity 1: Iterate over all of a node's relevant edges.\n   * @param  {any}   node   - Target node.\n   *\n   * Arity 2: Iterate over the relevant edges across the given path.\n   * @param  {any}   source - Source node.\n   * @param  {any}   target - Target node.\n   *\n   * @return {array|number} - The edges or the number of edges.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[name] = function (source, target) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return Iterator.empty();\n\n    if (!arguments.length) return createEdgeIterator(this, type);\n\n    if (arguments.length === 1) {\n      source = '' + source;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${name}: could not find the \"${source}\" node in the graph.`\n        );\n\n      // Iterating over a node's edges\n      return createEdgeIteratorForNode(type, direction, sourceData);\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${name}:  could not find the \"${source}\" source node in the graph.`\n        );\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(\n          `Graph.${name}:  could not find the \"${target}\" target node in the graph.`\n        );\n\n      // Iterating over the edges between source & target\n      return createEdgeIteratorForPath(type, direction, sourceData, target);\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.${name}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`\n    );\n  };\n}\n\n/**\n * Function attaching every edge iteration method to the Graph class.\n *\n * @param {function} Graph - Graph class.\n */\nexport default function attachEdgeIterationMethods(Graph) {\n  EDGES_ITERATION.forEach(description => {\n    attachEdgeArrayCreator(Graph, description);\n    attachForEachEdge(Graph, description);\n    attachFindEdge(Graph, description);\n    attachEdgeIteratorCreator(Graph, description);\n  });\n}\n","/**\n * Graphology Neighbor Iteration\n * ==============================\n *\n * Attaching some methods to the Graph class to be able to iterate over\n * neighbors.\n */\nimport Iterator from 'obliterator/iterator';\nimport chain from 'obliterator/chain';\n\nimport {NotFoundGraphError, InvalidArgumentsGraphError} from '../errors';\n\n/**\n * Definitions.\n */\nconst NEIGHBORS_ITERATION = [\n  {\n    name: 'neighbors',\n    type: 'mixed'\n  },\n  {\n    name: 'inNeighbors',\n    type: 'directed',\n    direction: 'in'\n  },\n  {\n    name: 'outNeighbors',\n    type: 'directed',\n    direction: 'out'\n  },\n  {\n    name: 'inboundNeighbors',\n    type: 'mixed',\n    direction: 'in'\n  },\n  {\n    name: 'outboundNeighbors',\n    type: 'mixed',\n    direction: 'out'\n  },\n  {\n    name: 'directedNeighbors',\n    type: 'directed'\n  },\n  {\n    name: 'undirectedNeighbors',\n    type: 'undirected'\n  }\n];\n\n/**\n * Helpers.\n */\nfunction CompositeSetWrapper() {\n  this.A = null;\n  this.B = null;\n}\n\nCompositeSetWrapper.prototype.wrap = function (set) {\n  if (this.A === null) this.A = set;\n  else if (this.B === null) this.B = set;\n};\n\nCompositeSetWrapper.prototype.has = function (key) {\n  if (this.A !== null && key in this.A) return true;\n  if (this.B !== null && key in this.B) return true;\n  return false;\n};\n\n/**\n * Function iterating over the given node's relevant neighbors to match\n * one of them using a predicated function.\n *\n * @param  {string}   type      - Type of neighbors.\n * @param  {string}   direction - Direction.\n * @param  {any}      nodeData  - Target node's data.\n * @param  {function} callback  - Callback to use.\n */\nfunction forEachInObjectOnce(breakable, visited, nodeData, object, callback) {\n  for (const k in object) {\n    const edgeData = object[k];\n\n    const sourceData = edgeData.source;\n    const targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    if (visited && visited.has(neighborData.key)) continue;\n\n    const shouldBreak = callback(neighborData.key, neighborData.attributes);\n\n    if (breakable && shouldBreak) return neighborData.key;\n  }\n\n  return;\n}\n\nfunction forEachNeighbor(breakable, type, direction, nodeData, callback) {\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected')\n      return forEachInObjectOnce(\n        breakable,\n        null,\n        nodeData,\n        nodeData.undirected,\n        callback\n      );\n\n    if (typeof direction === 'string')\n      return forEachInObjectOnce(\n        breakable,\n        null,\n        nodeData,\n        nodeData[direction],\n        callback\n      );\n  }\n\n  // Else we need to keep a set of neighbors not to return duplicates\n  // We cheat by querying the other adjacencies\n  const visited = new CompositeSetWrapper();\n\n  let found;\n\n  if (type !== 'undirected') {\n    if (direction !== 'out') {\n      found = forEachInObjectOnce(\n        breakable,\n        null,\n        nodeData,\n        nodeData.in,\n        callback\n      );\n\n      if (breakable && found) return found;\n\n      visited.wrap(nodeData.in);\n    }\n    if (direction !== 'in') {\n      found = forEachInObjectOnce(\n        breakable,\n        visited,\n        nodeData,\n        nodeData.out,\n        callback\n      );\n\n      if (breakable && found) return found;\n\n      visited.wrap(nodeData.out);\n    }\n  }\n\n  if (type !== 'directed') {\n    found = forEachInObjectOnce(\n      breakable,\n      visited,\n      nodeData,\n      nodeData.undirected,\n      callback\n    );\n\n    if (breakable && found) return found;\n  }\n\n  return;\n}\n\n/**\n * Function creating an array of relevant neighbors for the given node.\n *\n * @param  {string}       type      - Type of neighbors.\n * @param  {string}       direction - Direction.\n * @param  {any}          nodeData  - Target node's data.\n * @return {Array}                  - The list of neighbors.\n */\nfunction createNeighborArrayForNode(type, direction, nodeData) {\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected') return Object.keys(nodeData.undirected);\n\n    if (typeof direction === 'string') return Object.keys(nodeData[direction]);\n  }\n\n  const neighbors = [];\n\n  forEachNeighbor(false, type, direction, nodeData, function (key) {\n    neighbors.push(key);\n  });\n\n  return neighbors;\n}\n\n/**\n * Function returning an iterator over the given node's relevant neighbors.\n *\n * @param  {string}   type      - Type of neighbors.\n * @param  {string}   direction - Direction.\n * @param  {any}      nodeData  - Target node's data.\n * @return {Iterator}\n */\nfunction createDedupedObjectIterator(visited, nodeData, object) {\n  const keys = Object.keys(object);\n  const l = keys.length;\n\n  let i = 0;\n\n  return new Iterator(function next() {\n    let neighborData = null;\n\n    do {\n      if (i >= l) {\n        if (visited) visited.wrap(object);\n        return {done: true};\n      }\n\n      const edgeData = object[keys[i++]];\n\n      const sourceData = edgeData.source;\n      const targetData = edgeData.target;\n\n      neighborData = sourceData === nodeData ? targetData : sourceData;\n\n      if (visited && visited.has(neighborData.key)) {\n        neighborData = null;\n        continue;\n      }\n    } while (neighborData === null);\n\n    return {\n      done: false,\n      value: {neighbor: neighborData.key, attributes: neighborData.attributes}\n    };\n  });\n}\n\nfunction createNeighborIterator(type, direction, nodeData) {\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected')\n      return createDedupedObjectIterator(null, nodeData, nodeData.undirected);\n\n    if (typeof direction === 'string')\n      return createDedupedObjectIterator(null, nodeData, nodeData[direction]);\n  }\n\n  let iterator = Iterator.empty();\n\n  // Else we need to keep a set of neighbors not to return duplicates\n  // We cheat by querying the other adjacencies\n  const visited = new CompositeSetWrapper();\n\n  if (type !== 'undirected') {\n    if (direction !== 'out') {\n      iterator = chain(\n        iterator,\n        createDedupedObjectIterator(visited, nodeData, nodeData.in)\n      );\n    }\n    if (direction !== 'in') {\n      iterator = chain(\n        iterator,\n        createDedupedObjectIterator(visited, nodeData, nodeData.out)\n      );\n    }\n  }\n\n  if (type !== 'directed') {\n    iterator = chain(\n      iterator,\n      createDedupedObjectIterator(visited, nodeData, nodeData.undirected)\n    );\n  }\n\n  return iterator;\n}\n\n/**\n * Function attaching a neighbors array creator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachNeighborArrayCreator(Class, description) {\n  const {name, type, direction} = description;\n\n  /**\n   * Function returning an array of certain neighbors.\n   *\n   * @param  {any}   node   - Target node.\n   * @return {array} - The neighbors of neighbors.\n   *\n   * @throws {Error} - Will throw if node is not found in the graph.\n   */\n  Class.prototype[name] = function (node) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return [];\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(\n        `Graph.${name}: could not find the \"${node}\" node in the graph.`\n      );\n\n    // Here, we want to iterate over a node's relevant neighbors\n    return createNeighborArrayForNode(\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData\n    );\n  };\n}\n\n/**\n * Function attaching a neighbors callback iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachForEachNeighbor(Class, description) {\n  const {name, type, direction} = description;\n\n  const forEachName = 'forEach' + name[0].toUpperCase() + name.slice(1, -1);\n\n  /**\n   * Function iterating over all the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[forEachName] = function (node, callback) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type) return;\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(\n        `Graph.${forEachName}: could not find the \"${node}\" node in the graph.`\n      );\n\n    // Here, we want to iterate over a node's relevant neighbors\n    forEachNeighbor(\n      false,\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData,\n      callback\n    );\n  };\n\n  /**\n   * Function mapping the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const mapName = 'map' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[mapName] = function (node, callback) {\n    // TODO: optimize when size is known beforehand\n    const result = [];\n\n    this[forEachName](node, (n, a) => {\n      result.push(callback(n, a));\n    });\n\n    return result;\n  };\n\n  /**\n   * Function filtering the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const filterName = 'filter' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[filterName] = function (node, callback) {\n    const result = [];\n\n    this[forEachName](node, (n, a) => {\n      if (callback(n, a)) result.push(n);\n    });\n\n    return result;\n  };\n\n  /**\n   * Function reducing the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const reduceName = 'reduce' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[reduceName] = function (node, callback, initialValue) {\n    if (arguments.length < 3)\n      throw new InvalidArgumentsGraphError(\n        `Graph.${reduceName}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`\n      );\n\n    let accumulator = initialValue;\n\n    this[forEachName](node, (n, a) => {\n      accumulator = callback(accumulator, n, a);\n    });\n\n    return accumulator;\n  };\n}\n\n/**\n * Function attaching a breakable neighbors callback iterator method to the\n * Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachFindNeighbor(Class, description) {\n  const {name, type, direction} = description;\n\n  const capitalizedSingular = name[0].toUpperCase() + name.slice(1, -1);\n\n  const findName = 'find' + capitalizedSingular;\n\n  /**\n   * Function iterating over all the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[findName] = function (node, callback) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type) return;\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(\n        `Graph.${findName}: could not find the \"${node}\" node in the graph.`\n      );\n\n    // Here, we want to iterate over a node's relevant neighbors\n    return forEachNeighbor(\n      true,\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData,\n      callback\n    );\n  };\n\n  /**\n   * Function iterating over all the relevant neighbors to find if any of them\n   * matches the given predicate.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const someName = 'some' + capitalizedSingular;\n\n  Class.prototype[someName] = function (node, callback) {\n    const found = this[findName](node, callback);\n\n    if (found) return true;\n\n    return false;\n  };\n\n  /**\n   * Function iterating over all the relevant neighbors to find if all of them\n   * matche the given predicate.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const everyName = 'every' + capitalizedSingular;\n\n  Class.prototype[everyName] = function (node, callback) {\n    const found = this[findName](node, (n, a) => {\n      return !callback(n, a);\n    });\n\n    if (found) return false;\n\n    return true;\n  };\n}\n\n/**\n * Function attaching a neighbors callback iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachNeighborIteratorCreator(Class, description) {\n  const {name, type, direction} = description;\n\n  const iteratorName = name.slice(0, -1) + 'Entries';\n\n  /**\n   * Function returning an iterator over all the relevant neighbors.\n   *\n   * @param  {any}      node     - Target node.\n   * @return {Iterator}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[iteratorName] = function (node) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return Iterator.empty();\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(\n        `Graph.${iteratorName}: could not find the \"${node}\" node in the graph.`\n      );\n\n    // Here, we want to iterate over a node's relevant neighbors\n    return createNeighborIterator(\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData\n    );\n  };\n}\n\n/**\n * Function attaching every neighbor iteration method to the Graph class.\n *\n * @param {function} Graph - Graph class.\n */\nexport default function attachNeighborIterationMethods(Graph) {\n  NEIGHBORS_ITERATION.forEach(description => {\n    attachNeighborArrayCreator(Graph, description);\n    attachForEachNeighbor(Graph, description);\n    attachFindNeighbor(Graph, description);\n    attachNeighborIteratorCreator(Graph, description);\n  });\n}\n","/**\n * Graphology Adjacency Iteration\n * ===============================\n *\n * Attaching some methods to the Graph class to be able to iterate over a\n * graph's adjacency.\n */\n\n/**\n * Function iterating over a simple graph's adjacency using a callback.\n *\n * @param {boolean}  breakable         - Can we break?\n * @param {boolean}  assymetric        - Whether to emit undirected edges only once.\n * @param {boolean}  disconnectedNodes - Whether to emit disconnected nodes.\n * @param {Graph}    graph             - Target Graph instance.\n * @param {callback} function          - Iteration callback.\n */\nexport function forEachAdjacency(\n  breakable,\n  assymetric,\n  disconnectedNodes,\n  graph,\n  callback\n) {\n  const iterator = graph._nodes.values();\n\n  const type = graph.type;\n\n  let step, sourceData, neighbor, adj, edgeData, targetData, shouldBreak;\n\n  while (((step = iterator.next()), step.done !== true)) {\n    let hasEdges = false;\n\n    sourceData = step.value;\n\n    if (type !== 'undirected') {\n      adj = sourceData.out;\n\n      for (neighbor in adj) {\n        edgeData = adj[neighbor];\n\n        do {\n          targetData = edgeData.target;\n\n          hasEdges = true;\n          shouldBreak = callback(\n            sourceData.key,\n            targetData.key,\n            sourceData.attributes,\n            targetData.attributes,\n            edgeData.key,\n            edgeData.attributes,\n            edgeData.undirected\n          );\n\n          if (breakable && shouldBreak) return edgeData;\n\n          edgeData = edgeData.next;\n        } while (edgeData);\n      }\n    }\n\n    if (type !== 'directed') {\n      adj = sourceData.undirected;\n\n      for (neighbor in adj) {\n        if (assymetric && sourceData.key > neighbor) continue;\n\n        edgeData = adj[neighbor];\n\n        do {\n          targetData = edgeData.target;\n\n          if (targetData.key !== neighbor) targetData = edgeData.source;\n\n          hasEdges = true;\n          shouldBreak = callback(\n            sourceData.key,\n            targetData.key,\n            sourceData.attributes,\n            targetData.attributes,\n            edgeData.key,\n            edgeData.attributes,\n            edgeData.undirected\n          );\n\n          if (breakable && shouldBreak) return edgeData;\n\n          edgeData = edgeData.next;\n        } while (edgeData);\n      }\n    }\n\n    if (disconnectedNodes && !hasEdges) {\n      shouldBreak = callback(\n        sourceData.key,\n        null,\n        sourceData.attributes,\n        null,\n        null,\n        null,\n        null\n      );\n\n      if (breakable && shouldBreak) return null;\n    }\n  }\n\n  return;\n}\n","/**\n * Graphology Serialization Utilities\n * ===================================\n *\n * Collection of functions used by the graph serialization schemes.\n */\nimport {InvalidArgumentsGraphError} from './errors';\nimport {assign, isPlainObject, isEmpty} from './utils';\n\n/**\n * Formats internal node data into a serialized node.\n *\n * @param  {any}    key  - The node's key.\n * @param  {object} data - Internal node's data.\n * @return {array}       - The serialized node.\n */\nexport function serializeNode(key, data) {\n  const serialized = {key};\n\n  if (!isEmpty(data.attributes))\n    serialized.attributes = assign({}, data.attributes);\n\n  return serialized;\n}\n\n/**\n * Formats internal edge data into a serialized edge.\n *\n * @param  {string} type - The graph's type.\n * @param  {any}    key  - The edge's key.\n * @param  {object} data - Internal edge's data.\n * @return {array}       - The serialized edge.\n */\nexport function serializeEdge(type, key, data) {\n  const serialized = {\n    key,\n    source: data.source.key,\n    target: data.target.key\n  };\n\n  if (!isEmpty(data.attributes))\n    serialized.attributes = assign({}, data.attributes);\n\n  if (type === 'mixed' && data.undirected) serialized.undirected = true;\n\n  return serialized;\n}\n\n/**\n * Checks whether the given value is a serialized node.\n *\n * @param  {mixed} value - Target value.\n * @return {string|null}\n */\nexport function validateSerializedNode(value) {\n  if (!isPlainObject(value))\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: invalid serialized node. A serialized node should be a plain object with at least a \"key\" property.'\n    );\n\n  if (!('key' in value))\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: serialized node is missing its key.'\n    );\n\n  if (\n    'attributes' in value &&\n    (!isPlainObject(value.attributes) || value.attributes === null)\n  )\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.'\n    );\n}\n\n/**\n * Checks whether the given value is a serialized edge.\n *\n * @param  {mixed} value - Target value.\n * @return {string|null}\n */\nexport function validateSerializedEdge(value) {\n  if (!isPlainObject(value))\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: invalid serialized edge. A serialized edge should be a plain object with at least a \"source\" & \"target\" property.'\n    );\n\n  if (!('source' in value))\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: serialized edge is missing its source.'\n    );\n\n  if (!('target' in value))\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: serialized edge is missing its target.'\n    );\n\n  if (\n    'attributes' in value &&\n    (!isPlainObject(value.attributes) || value.attributes === null)\n  )\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.'\n    );\n\n  if ('undirected' in value && typeof value.undirected !== 'boolean')\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: invalid undirectedness information. Undirected should be boolean or omitted.'\n    );\n}\n","/* eslint no-nested-ternary: 0 */\n/**\n * Graphology Reference Implementation\n * ====================================\n *\n * Reference implementation of the graphology specs.\n */\nimport {EventEmitter} from 'events';\nimport Iterator from 'obliterator/iterator';\nimport take from 'obliterator/take';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError,\n  UsageGraphError\n} from './errors';\n\nimport {\n  MixedNodeData,\n  DirectedNodeData,\n  UndirectedNodeData,\n  EdgeData\n} from './data';\n\nimport attachNodeAttributesMethods from './attributes/nodes';\nimport attachEdgeAttributesMethods from './attributes/edges';\nimport attachEdgeIterationMethods from './iteration/edges';\nimport attachNeighborIterationMethods from './iteration/neighbors';\nimport {forEachAdjacency} from './iteration/adjacency';\n\nimport {\n  serializeNode,\n  serializeEdge,\n  validateSerializedNode,\n  validateSerializedEdge\n} from './serialization';\n\nimport {\n  assign,\n  getMatchingEdge,\n  isPlainObject,\n  privateProperty,\n  readOnlyProperty,\n  incrementalIdStartingFromRandomByte,\n  validateHints\n} from './utils';\n\n/**\n * Constants.\n */\nconst INSTANCE_ID = incrementalIdStartingFromRandomByte();\n\n/**\n * Enums.\n */\nconst TYPES = new Set(['directed', 'undirected', 'mixed']);\n\nconst EMITTER_PROPS = new Set([\n  'domain',\n  '_events',\n  '_eventsCount',\n  '_maxListeners'\n]);\n\nconst EDGE_ADD_METHODS = [\n  {\n    name: verb => `${verb}Edge`,\n    generateKey: true\n  },\n  {\n    name: verb => `${verb}DirectedEdge`,\n    generateKey: true,\n    type: 'directed'\n  },\n  {\n    name: verb => `${verb}UndirectedEdge`,\n    generateKey: true,\n    type: 'undirected'\n  },\n  {\n    name: verb => `${verb}EdgeWithKey`\n  },\n  {\n    name: verb => `${verb}DirectedEdgeWithKey`,\n    type: 'directed'\n  },\n  {\n    name: verb => `${verb}UndirectedEdgeWithKey`,\n    type: 'undirected'\n  }\n];\n\n/**\n * Default options.\n */\nconst DEFAULTS = {\n  allowSelfLoops: true,\n  multi: false,\n  type: 'mixed'\n};\n\n/**\n * Abstract functions used by the Graph class for various methods.\n */\n\n/**\n * Internal method used to add a node to the given graph\n *\n * @param  {Graph}   graph           - Target graph.\n * @param  {any}     node            - The node's key.\n * @param  {object}  [attributes]    - Optional attributes.\n * @return {NodeData}                - Created node data.\n */\nfunction addNode(graph, node, attributes) {\n  if (attributes && !isPlainObject(attributes))\n    throw new InvalidArgumentsGraphError(\n      `Graph.addNode: invalid attributes. Expecting an object but got \"${attributes}\"`\n    );\n\n  // String coercion\n  node = '' + node;\n  attributes = attributes || {};\n\n  if (graph._nodes.has(node))\n    throw new UsageGraphError(\n      `Graph.addNode: the \"${node}\" node already exist in the graph.`\n    );\n\n  const data = new graph.NodeDataClass(node, attributes);\n\n  // Adding the node to internal register\n  graph._nodes.set(node, data);\n\n  // Emitting\n  graph.emit('nodeAdded', {\n    key: node,\n    attributes\n  });\n\n  return data;\n}\n\n/**\n * Same as the above but without sanity checks because we call this in contexts\n * where necessary checks were already done.\n */\nfunction unsafeAddNode(graph, node, attributes) {\n  const data = new graph.NodeDataClass(node, attributes);\n\n  graph._nodes.set(node, data);\n\n  graph.emit('nodeAdded', {\n    key: node,\n    attributes\n  });\n\n  return data;\n}\n\n/**\n * Internal method used to add an arbitrary edge to the given graph.\n *\n * @param  {Graph}   graph           - Target graph.\n * @param  {string}  name            - Name of the child method for errors.\n * @param  {boolean} mustGenerateKey - Should the graph generate an id?\n * @param  {boolean} undirected      - Whether the edge is undirected.\n * @param  {any}     edge            - The edge's key.\n * @param  {any}     source          - The source node.\n * @param  {any}     target          - The target node.\n * @param  {object}  [attributes]    - Optional attributes.\n * @return {any}                     - The edge.\n *\n * @throws {Error} - Will throw if the graph is of the wrong type.\n * @throws {Error} - Will throw if the given attributes are not an object.\n * @throws {Error} - Will throw if source or target doesn't exist.\n * @throws {Error} - Will throw if the edge already exist.\n */\nfunction addEdge(\n  graph,\n  name,\n  mustGenerateKey,\n  undirected,\n  edge,\n  source,\n  target,\n  attributes\n) {\n  // Checking validity of operation\n  if (!undirected && graph.type === 'undirected')\n    throw new UsageGraphError(\n      `Graph.${name}: you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead.`\n    );\n\n  if (undirected && graph.type === 'directed')\n    throw new UsageGraphError(\n      `Graph.${name}: you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead.`\n    );\n\n  if (attributes && !isPlainObject(attributes))\n    throw new InvalidArgumentsGraphError(\n      `Graph.${name}: invalid attributes. Expecting an object but got \"${attributes}\"`\n    );\n\n  // Coercion of source & target:\n  source = '' + source;\n  target = '' + target;\n  attributes = attributes || {};\n\n  if (!graph.allowSelfLoops && source === target)\n    throw new UsageGraphError(\n      `Graph.${name}: source & target are the same (\"${source}\"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`\n    );\n\n  const sourceData = graph._nodes.get(source),\n    targetData = graph._nodes.get(target);\n\n  if (!sourceData)\n    throw new NotFoundGraphError(\n      `Graph.${name}: source node \"${source}\" not found.`\n    );\n\n  if (!targetData)\n    throw new NotFoundGraphError(\n      `Graph.${name}: target node \"${target}\" not found.`\n    );\n\n  // Must the graph generate an id for this edge?\n  const eventData = {\n    key: null,\n    undirected,\n    source,\n    target,\n    attributes\n  };\n\n  if (mustGenerateKey) {\n    // NOTE: in this case we can guarantee that the key does not already\n    // exist and is already correctly casted as a string\n    edge = graph._edgeKeyGenerator();\n  } else {\n    // Coercion of edge key\n    edge = '' + edge;\n\n    // Here, we have a key collision\n    if (graph._edges.has(edge))\n      throw new UsageGraphError(\n        `Graph.${name}: the \"${edge}\" edge already exists in the graph.`\n      );\n  }\n\n  // Here, we might have a source / target collision\n  if (\n    !graph.multi &&\n    (undirected\n      ? typeof sourceData.undirected[target] !== 'undefined'\n      : typeof sourceData.out[target] !== 'undefined')\n  ) {\n    throw new UsageGraphError(\n      `Graph.${name}: an edge linking \"${source}\" to \"${target}\" already exists. If you really want to add multiple edges linking those nodes, you should create a multi graph by using the 'multi' option.`\n    );\n  }\n\n  // Storing some data\n  const edgeData = new EdgeData(\n    undirected,\n    edge,\n    sourceData,\n    targetData,\n    attributes\n  );\n\n  // Adding the edge to the internal register\n  graph._edges.set(edge, edgeData);\n\n  // Incrementing node degree counters\n  const isSelfLoop = source === target;\n\n  if (undirected) {\n    sourceData.undirectedDegree++;\n    targetData.undirectedDegree++;\n\n    if (isSelfLoop) graph._undirectedSelfLoopCount++;\n  } else {\n    sourceData.outDegree++;\n    targetData.inDegree++;\n\n    if (isSelfLoop) graph._directedSelfLoopCount++;\n  }\n\n  // Updating relevant index\n  if (graph.multi) edgeData.attachMulti();\n  else edgeData.attach();\n\n  if (undirected) graph._undirectedSize++;\n  else graph._directedSize++;\n\n  // Emitting\n  eventData.key = edge;\n\n  graph.emit('edgeAdded', eventData);\n\n  return edge;\n}\n\n/**\n * Internal method used to add an arbitrary edge to the given graph.\n *\n * @param  {Graph}   graph           - Target graph.\n * @param  {string}  name            - Name of the child method for errors.\n * @param  {boolean} mustGenerateKey - Should the graph generate an id?\n * @param  {boolean} undirected      - Whether the edge is undirected.\n * @param  {any}     edge            - The edge's key.\n * @param  {any}     source          - The source node.\n * @param  {any}     target          - The target node.\n * @param  {object}  [attributes]    - Optional attributes.\n * @param  {boolean} [asUpdater]       - Are we updating or merging?\n * @return {any}                     - The edge.\n *\n * @throws {Error} - Will throw if the graph is of the wrong type.\n * @throws {Error} - Will throw if the given attributes are not an object.\n * @throws {Error} - Will throw if source or target doesn't exist.\n * @throws {Error} - Will throw if the edge already exist.\n */\nfunction mergeEdge(\n  graph,\n  name,\n  mustGenerateKey,\n  undirected,\n  edge,\n  source,\n  target,\n  attributes,\n  asUpdater\n) {\n  // Checking validity of operation\n  if (!undirected && graph.type === 'undirected')\n    throw new UsageGraphError(\n      `Graph.${name}: you cannot merge/update a directed edge to an undirected graph. Use the #.mergeEdge/#.updateEdge or #.addUndirectedEdge instead.`\n    );\n\n  if (undirected && graph.type === 'directed')\n    throw new UsageGraphError(\n      `Graph.${name}: you cannot merge/update an undirected edge to a directed graph. Use the #.mergeEdge/#.updateEdge or #.addDirectedEdge instead.`\n    );\n\n  if (attributes) {\n    if (asUpdater) {\n      if (typeof attributes !== 'function')\n        throw new InvalidArgumentsGraphError(\n          `Graph.${name}: invalid updater function. Expecting a function but got \"${attributes}\"`\n        );\n    } else {\n      if (!isPlainObject(attributes))\n        throw new InvalidArgumentsGraphError(\n          `Graph.${name}: invalid attributes. Expecting an object but got \"${attributes}\"`\n        );\n    }\n  }\n\n  // Coercion of source & target:\n  source = '' + source;\n  target = '' + target;\n\n  let updater;\n\n  if (asUpdater) {\n    updater = attributes;\n    attributes = undefined;\n  }\n\n  if (!graph.allowSelfLoops && source === target)\n    throw new UsageGraphError(\n      `Graph.${name}: source & target are the same (\"${source}\"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`\n    );\n\n  let sourceData = graph._nodes.get(source);\n  let targetData = graph._nodes.get(target);\n  let edgeData;\n\n  // Do we need to handle duplicate?\n  let alreadyExistingEdgeData;\n\n  if (!mustGenerateKey) {\n    edgeData = graph._edges.get(edge);\n\n    if (edgeData) {\n      // Here, we need to ensure, if the user gave a key, that source & target\n      // are consistent\n      if (edgeData.source.key !== source || edgeData.target.key !== target) {\n        // If source or target inconsistent\n        if (\n          !undirected ||\n          edgeData.source.key !== target ||\n          edgeData.target.key !== source\n        ) {\n          // If directed, or source/target aren't flipped\n          throw new UsageGraphError(\n            `Graph.${name}: inconsistency detected when attempting to merge the \"${edge}\" edge with \"${source}\" source & \"${target}\" target vs. (\"${edgeData.source.key}\", \"${edgeData.target.key}\").`\n          );\n        }\n      }\n\n      alreadyExistingEdgeData = edgeData;\n    }\n  }\n\n  // Here, we might have a source / target collision\n  if (!alreadyExistingEdgeData && !graph.multi && sourceData) {\n    alreadyExistingEdgeData = undirected\n      ? sourceData.undirected[target]\n      : sourceData.out[target];\n  }\n\n  // Handling duplicates\n  if (alreadyExistingEdgeData) {\n    const info = [alreadyExistingEdgeData.key, false, false, false];\n\n    // We can skip the attribute merging part if the user did not provide them\n    if (asUpdater ? !updater : !attributes) return info;\n\n    // Updating the attributes\n    if (asUpdater) {\n      const oldAttributes = alreadyExistingEdgeData.attributes;\n      alreadyExistingEdgeData.attributes = updater(oldAttributes);\n\n      graph.emit('edgeAttributesUpdated', {\n        type: 'replace',\n        key: alreadyExistingEdgeData.key,\n        attributes: alreadyExistingEdgeData.attributes\n      });\n    }\n\n    // Merging the attributes\n    else {\n      assign(alreadyExistingEdgeData.attributes, attributes);\n\n      graph.emit('edgeAttributesUpdated', {\n        type: 'merge',\n        key: alreadyExistingEdgeData.key,\n        attributes: alreadyExistingEdgeData.attributes,\n        data: attributes\n      });\n    }\n\n    return info;\n  }\n\n  attributes = attributes || {};\n\n  if (asUpdater && updater) attributes = updater(attributes);\n\n  // Must the graph generate an id for this edge?\n  const eventData = {\n    key: null,\n    undirected,\n    source,\n    target,\n    attributes\n  };\n\n  if (mustGenerateKey) {\n    // NOTE: in this case we can guarantee that the key does not already\n    // exist and is already correctly casted as a string\n    edge = graph._edgeKeyGenerator();\n  } else {\n    // Coercion of edge key\n    edge = '' + edge;\n\n    // Here, we have a key collision\n    if (graph._edges.has(edge))\n      throw new UsageGraphError(\n        `Graph.${name}: the \"${edge}\" edge already exists in the graph.`\n      );\n  }\n\n  let sourceWasAdded = false;\n  let targetWasAdded = false;\n\n  if (!sourceData) {\n    sourceData = unsafeAddNode(graph, source, {});\n    sourceWasAdded = true;\n\n    if (source === target) {\n      targetData = sourceData;\n      targetWasAdded = true;\n    }\n  }\n  if (!targetData) {\n    targetData = unsafeAddNode(graph, target, {});\n    targetWasAdded = true;\n  }\n\n  // Storing some data\n  edgeData = new EdgeData(undirected, edge, sourceData, targetData, attributes);\n\n  // Adding the edge to the internal register\n  graph._edges.set(edge, edgeData);\n\n  // Incrementing node degree counters\n  const isSelfLoop = source === target;\n\n  if (undirected) {\n    sourceData.undirectedDegree++;\n    targetData.undirectedDegree++;\n\n    if (isSelfLoop) graph._undirectedSelfLoopCount++;\n  } else {\n    sourceData.outDegree++;\n    targetData.inDegree++;\n\n    if (isSelfLoop) graph._directedSelfLoopCount++;\n  }\n\n  // Updating relevant index\n  if (graph.multi) edgeData.attachMulti();\n  else edgeData.attach();\n\n  if (undirected) graph._undirectedSize++;\n  else graph._directedSize++;\n\n  // Emitting\n  eventData.key = edge;\n\n  graph.emit('edgeAdded', eventData);\n\n  return [edge, true, sourceWasAdded, targetWasAdded];\n}\n\n/**\n * Internal method used to drop an edge.\n *\n * @param  {Graph}    graph    - Target graph.\n * @param  {EdgeData} edgeData - Data of the edge to drop.\n */\nfunction dropEdgeFromData(graph, edgeData) {\n  // Dropping the edge from the register\n  graph._edges.delete(edgeData.key);\n\n  // Updating related degrees\n  const {source: sourceData, target: targetData, attributes} = edgeData;\n\n  const undirected = edgeData.undirected;\n\n  const isSelfLoop = sourceData === targetData;\n\n  if (undirected) {\n    sourceData.undirectedDegree--;\n    targetData.undirectedDegree--;\n\n    if (isSelfLoop) graph._undirectedSelfLoopCount--;\n  } else {\n    sourceData.outDegree--;\n    targetData.inDegree--;\n\n    if (isSelfLoop) graph._directedSelfLoopCount--;\n  }\n\n  // Clearing index\n  if (graph.multi) edgeData.detachMulti();\n  else edgeData.detach();\n\n  if (undirected) graph._undirectedSize--;\n  else graph._directedSize--;\n\n  // Emitting\n  graph.emit('edgeDropped', {\n    key: edgeData.key,\n    attributes,\n    source: sourceData.key,\n    target: targetData.key,\n    undirected\n  });\n}\n\n/**\n * Graph class\n *\n * @constructor\n * @param  {object}  [options] - Options:\n * @param  {boolean}   [allowSelfLoops] - Allow self loops?\n * @param  {string}    [type]           - Type of the graph.\n * @param  {boolean}   [map]            - Allow references as keys?\n * @param  {boolean}   [multi]          - Allow parallel edges?\n *\n * @throws {Error} - Will throw if the arguments are not valid.\n */\nexport default class Graph extends EventEmitter {\n  constructor(options) {\n    super();\n\n    //-- Solving options\n    options = assign({}, DEFAULTS, options);\n\n    // Enforcing options validity\n    if (typeof options.multi !== 'boolean')\n      throw new InvalidArgumentsGraphError(\n        `Graph.constructor: invalid 'multi' option. Expecting a boolean but got \"${options.multi}\".`\n      );\n\n    if (!TYPES.has(options.type))\n      throw new InvalidArgumentsGraphError(\n        `Graph.constructor: invalid 'type' option. Should be one of \"mixed\", \"directed\" or \"undirected\" but got \"${options.type}\".`\n      );\n\n    if (typeof options.allowSelfLoops !== 'boolean')\n      throw new InvalidArgumentsGraphError(\n        `Graph.constructor: invalid 'allowSelfLoops' option. Expecting a boolean but got \"${options.allowSelfLoops}\".`\n      );\n\n    //-- Private properties\n\n    // Utilities\n    const NodeDataClass =\n      options.type === 'mixed'\n        ? MixedNodeData\n        : options.type === 'directed'\n        ? DirectedNodeData\n        : UndirectedNodeData;\n\n    privateProperty(this, 'NodeDataClass', NodeDataClass);\n\n    // Internal edge key generator\n\n    // NOTE: this internal generator produce keys that are strings\n    // composed of a weird prefix, an incremental instance id starting from\n    // a random byte and finally an internal instance incremental id.\n    // All this to avoid intra-frame and cross-frame adversarial inputs\n    // that can force a single #.addEdge call to degenerate into a O(n)\n    // available key search loop.\n\n    // It also ensures that automatically generated edge keys are unlikely\n    // to produce collisions with arbitrary keys given by users.\n    const instancePrefix = 'geid_' + INSTANCE_ID() + '_';\n    let edgeId = 0;\n\n    const edgeKeyGenerator = () => {\n      let availableEdgeKey;\n\n      do {\n        availableEdgeKey = instancePrefix + edgeId++;\n      } while (this._edges.has(availableEdgeKey));\n\n      return availableEdgeKey;\n    };\n\n    // Indexes\n    privateProperty(this, '_attributes', {});\n    privateProperty(this, '_nodes', new Map());\n    privateProperty(this, '_edges', new Map());\n    privateProperty(this, '_directedSize', 0);\n    privateProperty(this, '_undirectedSize', 0);\n    privateProperty(this, '_directedSelfLoopCount', 0);\n    privateProperty(this, '_undirectedSelfLoopCount', 0);\n    privateProperty(this, '_edgeKeyGenerator', edgeKeyGenerator);\n\n    // Options\n    privateProperty(this, '_options', options);\n\n    // Emitter properties\n    EMITTER_PROPS.forEach(prop => privateProperty(this, prop, this[prop]));\n\n    //-- Properties readers\n    readOnlyProperty(this, 'order', () => this._nodes.size);\n    readOnlyProperty(this, 'size', () => this._edges.size);\n    readOnlyProperty(this, 'directedSize', () => this._directedSize);\n    readOnlyProperty(this, 'undirectedSize', () => this._undirectedSize);\n    readOnlyProperty(\n      this,\n      'selfLoopCount',\n      () => this._directedSelfLoopCount + this._undirectedSelfLoopCount\n    );\n    readOnlyProperty(\n      this,\n      'directedSelfLoopCount',\n      () => this._directedSelfLoopCount\n    );\n    readOnlyProperty(\n      this,\n      'undirectedSelfLoopCount',\n      () => this._undirectedSelfLoopCount\n    );\n    readOnlyProperty(this, 'multi', this._options.multi);\n    readOnlyProperty(this, 'type', this._options.type);\n    readOnlyProperty(this, 'allowSelfLoops', this._options.allowSelfLoops);\n    readOnlyProperty(this, 'implementation', () => 'graphology');\n  }\n\n  _resetInstanceCounters() {\n    this._directedSize = 0;\n    this._undirectedSize = 0;\n    this._directedSelfLoopCount = 0;\n    this._undirectedSelfLoopCount = 0;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Read\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning whether the given node is found in the graph.\n   *\n   * @param  {any}     node - The node.\n   * @return {boolean}\n   */\n  hasNode(node) {\n    return this._nodes.has('' + node);\n  }\n\n  /**\n   * Method returning whether the given directed edge is found in the graph.\n   *\n   * Arity 1:\n   * @param  {any}     edge - The edge's key.\n   *\n   * Arity 2:\n   * @param  {any}     source - The edge's source.\n   * @param  {any}     target - The edge's target.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the arguments are invalid.\n   */\n  hasDirectedEdge(source, target) {\n    // Early termination\n    if (this.type === 'undirected') return false;\n\n    if (arguments.length === 1) {\n      const edge = '' + source;\n\n      const edgeData = this._edges.get(edge);\n\n      return !!edgeData && !edgeData.undirected;\n    } else if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      // If the node source or the target is not in the graph we break\n      const nodeData = this._nodes.get(source);\n\n      if (!nodeData) return false;\n\n      // Is there a directed edge pointing toward target?\n      const edges = nodeData.out[target];\n\n      if (!edges) return false;\n\n      return this.multi ? !!edges.size : true;\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`\n    );\n  }\n\n  /**\n   * Method returning whether the given undirected edge is found in the graph.\n   *\n   * Arity 1:\n   * @param  {any}     edge - The edge's key.\n   *\n   * Arity 2:\n   * @param  {any}     source - The edge's source.\n   * @param  {any}     target - The edge's target.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the arguments are invalid.\n   */\n  hasUndirectedEdge(source, target) {\n    // Early termination\n    if (this.type === 'directed') return false;\n\n    if (arguments.length === 1) {\n      const edge = '' + source;\n\n      const edgeData = this._edges.get(edge);\n\n      return !!edgeData && edgeData.undirected;\n    } else if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      // If the node source or the target is not in the graph we break\n      const nodeData = this._nodes.get(source);\n\n      if (!nodeData) return false;\n\n      // Is there a directed edge pointing toward target?\n      const edges = nodeData.undirected[target];\n\n      if (!edges) return false;\n\n      return this.multi ? !!edges.size : true;\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`\n    );\n  }\n\n  /**\n   * Method returning whether the given edge is found in the graph.\n   *\n   * Arity 1:\n   * @param  {any}     edge - The edge's key.\n   *\n   * Arity 2:\n   * @param  {any}     source - The edge's source.\n   * @param  {any}     target - The edge's target.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the arguments are invalid.\n   */\n  hasEdge(source, target) {\n    if (arguments.length === 1) {\n      const edge = '' + source;\n\n      return this._edges.has(edge);\n    } else if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      // If the node source or the target is not in the graph we break\n      const nodeData = this._nodes.get(source);\n\n      if (!nodeData) return false;\n\n      // Is there a directed edge pointing toward target?\n      let edges = typeof nodeData.out !== 'undefined' && nodeData.out[target];\n\n      if (!edges)\n        edges =\n          typeof nodeData.undirected !== 'undefined' &&\n          nodeData.undirected[target];\n\n      if (!edges) return false;\n\n      return this.multi ? !!edges.size : true;\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.hasEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`\n    );\n  }\n\n  /**\n   * Method returning the edge matching source & target in a directed fashion.\n   *\n   * @param  {any} source - The edge's source.\n   * @param  {any} target - The edge's target.\n   *\n   * @return {any|undefined}\n   *\n   * @throws {Error} - Will throw if the graph is multi.\n   * @throws {Error} - Will throw if source or target doesn't exist.\n   */\n  directedEdge(source, target) {\n    if (this.type === 'undirected') return;\n\n    source = '' + source;\n    target = '' + target;\n\n    if (this.multi)\n      throw new UsageGraphError(\n        'Graph.directedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.directedEdges instead.'\n      );\n\n    const sourceData = this._nodes.get(source);\n\n    if (!sourceData)\n      throw new NotFoundGraphError(\n        `Graph.directedEdge: could not find the \"${source}\" source node in the graph.`\n      );\n\n    if (!this._nodes.has(target))\n      throw new NotFoundGraphError(\n        `Graph.directedEdge: could not find the \"${target}\" target node in the graph.`\n      );\n\n    const edgeData = (sourceData.out && sourceData.out[target]) || undefined;\n\n    if (edgeData) return edgeData.key;\n  }\n\n  /**\n   * Method returning the edge matching source & target in a undirected fashion.\n   *\n   * @param  {any} source - The edge's source.\n   * @param  {any} target - The edge's target.\n   *\n   * @return {any|undefined}\n   *\n   * @throws {Error} - Will throw if the graph is multi.\n   * @throws {Error} - Will throw if source or target doesn't exist.\n   */\n  undirectedEdge(source, target) {\n    if (this.type === 'directed') return;\n\n    source = '' + source;\n    target = '' + target;\n\n    if (this.multi)\n      throw new UsageGraphError(\n        'Graph.undirectedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.undirectedEdges instead.'\n      );\n\n    const sourceData = this._nodes.get(source);\n\n    if (!sourceData)\n      throw new NotFoundGraphError(\n        `Graph.undirectedEdge: could not find the \"${source}\" source node in the graph.`\n      );\n\n    if (!this._nodes.has(target))\n      throw new NotFoundGraphError(\n        `Graph.undirectedEdge: could not find the \"${target}\" target node in the graph.`\n      );\n\n    const edgeData =\n      (sourceData.undirected && sourceData.undirected[target]) || undefined;\n\n    if (edgeData) return edgeData.key;\n  }\n\n  /**\n   * Method returning the edge matching source & target in a mixed fashion.\n   *\n   * @param  {any} source - The edge's source.\n   * @param  {any} target - The edge's target.\n   *\n   * @return {any|undefined}\n   *\n   * @throws {Error} - Will throw if the graph is multi.\n   * @throws {Error} - Will throw if source or target doesn't exist.\n   */\n  edge(source, target) {\n    if (this.multi)\n      throw new UsageGraphError(\n        'Graph.edge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.edges instead.'\n      );\n\n    source = '' + source;\n    target = '' + target;\n\n    const sourceData = this._nodes.get(source);\n\n    if (!sourceData)\n      throw new NotFoundGraphError(\n        `Graph.edge: could not find the \"${source}\" source node in the graph.`\n      );\n\n    if (!this._nodes.has(target))\n      throw new NotFoundGraphError(\n        `Graph.edge: could not find the \"${target}\" target node in the graph.`\n      );\n\n    const edgeData =\n      (sourceData.out && sourceData.out[target]) ||\n      (sourceData.undirected && sourceData.undirected[target]) ||\n      undefined;\n\n    if (edgeData) return edgeData.key;\n  }\n\n  /**\n   * Method returning whether two nodes are directed neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areDirectedNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areDirectedNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return false;\n\n    return neighbor in nodeData.in || neighbor in nodeData.out;\n  }\n\n  /**\n   * Method returning whether two nodes are out neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areOutNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areOutNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return false;\n\n    return neighbor in nodeData.out;\n  }\n\n  /**\n   * Method returning whether two nodes are in neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areInNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areInNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return false;\n\n    return neighbor in nodeData.in;\n  }\n\n  /**\n   * Method returning whether two nodes are undirected neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areUndirectedNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areUndirectedNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'directed') return false;\n\n    return neighbor in nodeData.undirected;\n  }\n\n  /**\n   * Method returning whether two nodes are neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type !== 'undirected') {\n      if (neighbor in nodeData.in || neighbor in nodeData.out) return true;\n    }\n\n    if (this.type !== 'directed') {\n      if (neighbor in nodeData.undirected) return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Method returning whether two nodes are inbound neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areInboundNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areInboundNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type !== 'undirected') {\n      if (neighbor in nodeData.in) return true;\n    }\n\n    if (this.type !== 'directed') {\n      if (neighbor in nodeData.undirected) return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Method returning whether two nodes are outbound neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areOutboundNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areOutboundNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type !== 'undirected') {\n      if (neighbor in nodeData.out) return true;\n    }\n\n    if (this.type !== 'directed') {\n      if (neighbor in nodeData.undirected) return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Method returning the given node's in degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  inDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.inDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.inDegree;\n  }\n\n  /**\n   * Method returning the given node's out degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  outDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.outDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.outDegree;\n  }\n\n  /**\n   * Method returning the given node's directed degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  directedDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.directedDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.inDegree + nodeData.outDegree;\n  }\n\n  /**\n   * Method returning the given node's undirected degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  undirectedDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.undirectedDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'directed') return 0;\n\n    return nodeData.undirectedDegree;\n  }\n\n  /**\n   * Method returning the given node's inbound degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's inbound degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  inboundDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.inboundDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    let degree = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree;\n    }\n\n    if (this.type !== 'undirected') {\n      degree += nodeData.inDegree;\n    }\n\n    return degree;\n  }\n\n  /**\n   * Method returning the given node's outbound degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's outbound degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  outboundDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.outboundDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    let degree = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree;\n    }\n\n    if (this.type !== 'undirected') {\n      degree += nodeData.outDegree;\n    }\n\n    return degree;\n  }\n\n  /**\n   * Method returning the given node's directed degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  degree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.degree: could not find the \"${node}\" node in the graph.`\n      );\n\n    let degree = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree;\n    }\n\n    if (this.type !== 'undirected') {\n      degree += nodeData.inDegree + nodeData.outDegree;\n    }\n\n    return degree;\n  }\n\n  /**\n   * Method returning the given node's in degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  inDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.inDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    const self = nodeData.in[node];\n    const loops = self ? (this.multi ? self.size : 1) : 0;\n\n    return nodeData.inDegree - loops;\n  }\n\n  /**\n   * Method returning the given node's out degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  outDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.outDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    const self = nodeData.out[node];\n    const loops = self ? (this.multi ? self.size : 1) : 0;\n\n    return nodeData.outDegree - loops;\n  }\n\n  /**\n   * Method returning the given node's directed degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  directedDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.directedDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    const self = nodeData.out[node];\n    const loops = self ? (this.multi ? self.size : 1) : 0;\n\n    return nodeData.inDegree + nodeData.outDegree - loops * 2;\n  }\n\n  /**\n   * Method returning the given node's undirected degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  undirectedDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.undirectedDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'directed') return 0;\n\n    const self = nodeData.undirected[node];\n    const loops = self ? (this.multi ? self.size : 1) : 0;\n\n    return nodeData.undirectedDegree - loops * 2;\n  }\n\n  /**\n   * Method returning the given node's inbound degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's inbound degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  inboundDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.inboundDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    let self;\n    let degree = 0;\n    let loops = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree;\n\n      self = nodeData.undirected[node];\n      loops += (self ? (this.multi ? self.size : 1) : 0) * 2;\n    }\n\n    if (this.type !== 'undirected') {\n      degree += nodeData.inDegree;\n\n      self = nodeData.out[node];\n      loops += self ? (this.multi ? self.size : 1) : 0;\n    }\n\n    return degree - loops;\n  }\n\n  /**\n   * Method returning the given node's outbound degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's outbound degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  outboundDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.outboundDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    let self;\n    let degree = 0;\n    let loops = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree;\n\n      self = nodeData.undirected[node];\n      loops += (self ? (this.multi ? self.size : 1) : 0) * 2;\n    }\n\n    if (this.type !== 'undirected') {\n      degree += nodeData.outDegree;\n\n      self = nodeData.in[node];\n      loops += self ? (this.multi ? self.size : 1) : 0;\n    }\n\n    return degree - loops;\n  }\n\n  /**\n   * Method returning the given node's directed degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  degreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.degreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    let self;\n    let degree = 0;\n    let loops = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree;\n\n      self = nodeData.undirected[node];\n      loops += (self ? (this.multi ? self.size : 1) : 0) * 2;\n    }\n\n    if (this.type !== 'undirected') {\n      degree += nodeData.inDegree + nodeData.outDegree;\n\n      self = nodeData.out[node];\n      loops += (self ? (this.multi ? self.size : 1) : 0) * 2;\n    }\n\n    return degree - loops;\n  }\n\n  /**\n   * Method returning the given edge's source.\n   *\n   * @param  {any} edge - The edge's key.\n   * @return {any}      - The edge's source.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  source(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.source: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.source.key;\n  }\n\n  /**\n   * Method returning the given edge's target.\n   *\n   * @param  {any} edge - The edge's key.\n   * @return {any}      - The edge's target.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  target(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.target: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.target.key;\n  }\n\n  /**\n   * Method returning the given edge's extremities.\n   *\n   * @param  {any}   edge - The edge's key.\n   * @return {array}      - The edge's extremities.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  extremities(edge) {\n    edge = '' + edge;\n\n    const edgeData = this._edges.get(edge);\n\n    if (!edgeData)\n      throw new NotFoundGraphError(\n        `Graph.extremities: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return [edgeData.source.key, edgeData.target.key];\n  }\n\n  /**\n   * Given a node & an edge, returns the other extremity of the edge.\n   *\n   * @param  {any}   node - The node's key.\n   * @param  {any}   edge - The edge's key.\n   * @return {any}        - The related node.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph or if the\n   *                   edge & node are not related.\n   */\n  opposite(node, edge) {\n    node = '' + node;\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.opposite: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    const source = data.source.key;\n    const target = data.target.key;\n\n    if (node === source) return target;\n    if (node === target) return source;\n\n    throw new NotFoundGraphError(\n      `Graph.opposite: the \"${node}\" node is not attached to the \"${edge}\" edge (${source}, ${target}).`\n    );\n  }\n\n  /**\n   * Returns whether the given edge has the given node as extremity.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @param  {any}     node - The node's key.\n   * @return {boolean}      - The related node.\n   *\n   * @throws {Error} - Will throw if either the node or the edge isn't in the graph.\n   */\n  hasExtremity(edge, node) {\n    edge = '' + edge;\n    node = '' + node;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.hasExtremity: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.source.key === node || data.target.key === node;\n  }\n\n  /**\n   * Method returning whether the given edge is undirected.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  isUndirected(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.isUndirected: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.undirected;\n  }\n\n  /**\n   * Method returning whether the given edge is directed.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  isDirected(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.isDirected: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return !data.undirected;\n  }\n\n  /**\n   * Method returning whether the given edge is a self loop.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  isSelfLoop(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.isSelfLoop: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.source === data.target;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Mutation\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method used to add a node to the graph.\n   *\n   * @param  {any}    node         - The node.\n   * @param  {object} [attributes] - Optional attributes.\n   * @return {any}                 - The node.\n   *\n   * @throws {Error} - Will throw if the given node already exist.\n   * @throws {Error} - Will throw if the given attributes are not an object.\n   */\n  addNode(node, attributes) {\n    const nodeData = addNode(this, node, attributes);\n\n    return nodeData.key;\n  }\n\n  /**\n   * Method used to merge a node into the graph.\n   *\n   * @param  {any}    node         - The node.\n   * @param  {object} [attributes] - Optional attributes.\n   * @return {any}                 - The node.\n   */\n  mergeNode(node, attributes) {\n    if (attributes && !isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.mergeNode: invalid attributes. Expecting an object but got \"${attributes}\"`\n      );\n\n    // String coercion\n    node = '' + node;\n    attributes = attributes || {};\n\n    // If the node already exists, we merge the attributes\n    let data = this._nodes.get(node);\n\n    if (data) {\n      if (attributes) {\n        assign(data.attributes, attributes);\n\n        this.emit('nodeAttributesUpdated', {\n          type: 'merge',\n          key: node,\n          attributes: data.attributes,\n          data: attributes\n        });\n      }\n      return [node, false];\n    }\n\n    data = new this.NodeDataClass(node, attributes);\n\n    // Adding the node to internal register\n    this._nodes.set(node, data);\n\n    // Emitting\n    this.emit('nodeAdded', {\n      key: node,\n      attributes\n    });\n\n    return [node, true];\n  }\n\n  /**\n   * Method used to add a node if it does not exist in the graph or else to\n   * update its attributes using a function.\n   *\n   * @param  {any}      node      - The node.\n   * @param  {function} [updater] - Optional updater function.\n   * @return {any}                - The node.\n   */\n  updateNode(node, updater) {\n    if (updater && typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        `Graph.updateNode: invalid updater function. Expecting a function but got \"${updater}\"`\n      );\n\n    // String coercion\n    node = '' + node;\n\n    // If the node already exists, we update the attributes\n    let data = this._nodes.get(node);\n\n    if (data) {\n      if (updater) {\n        const oldAttributes = data.attributes;\n        data.attributes = updater(oldAttributes);\n\n        this.emit('nodeAttributesUpdated', {\n          type: 'replace',\n          key: node,\n          attributes: data.attributes\n        });\n      }\n      return [node, false];\n    }\n\n    const attributes = updater ? updater({}) : {};\n\n    data = new this.NodeDataClass(node, attributes);\n\n    // Adding the node to internal register\n    this._nodes.set(node, data);\n\n    // Emitting\n    this.emit('nodeAdded', {\n      key: node,\n      attributes\n    });\n\n    return [node, true];\n  }\n\n  /**\n   * Method used to drop a single node & all its attached edges from the graph.\n   *\n   * @param  {any}    node - The node.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the node doesn't exist.\n   */\n  dropNode(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.dropNode: could not find the \"${node}\" node in the graph.`\n      );\n\n    let edgeData;\n\n    // Removing attached edges\n    // NOTE: we could be faster here, but this is such a pain to maintain\n    if (this.type !== 'undirected') {\n      for (const neighbor in nodeData.out) {\n        edgeData = nodeData.out[neighbor];\n\n        do {\n          dropEdgeFromData(this, edgeData);\n          edgeData = edgeData.next;\n        } while (edgeData);\n      }\n\n      for (const neighbor in nodeData.in) {\n        edgeData = nodeData.in[neighbor];\n\n        do {\n          dropEdgeFromData(this, edgeData);\n          edgeData = edgeData.next;\n        } while (edgeData);\n      }\n    }\n\n    if (this.type !== 'directed') {\n      for (const neighbor in nodeData.undirected) {\n        edgeData = nodeData.undirected[neighbor];\n\n        do {\n          dropEdgeFromData(this, edgeData);\n          edgeData = edgeData.next;\n        } while (edgeData);\n      }\n    }\n\n    // Dropping the node from the register\n    this._nodes.delete(node);\n\n    // Emitting\n    this.emit('nodeDropped', {\n      key: node,\n      attributes: nodeData.attributes\n    });\n  }\n\n  /**\n   * Method used to drop a single edge from the graph.\n   *\n   * Arity 1:\n   * @param  {any}    edge - The edge.\n   *\n   * Arity 2:\n   * @param  {any}    source - Source node.\n   * @param  {any}    target - Target node.\n   *\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the edge doesn't exist.\n   */\n  dropEdge(edge) {\n    let edgeData;\n\n    if (arguments.length > 1) {\n      const source = '' + arguments[0];\n      const target = '' + arguments[1];\n\n      edgeData = getMatchingEdge(this, source, target, this.type);\n\n      if (!edgeData)\n        throw new NotFoundGraphError(\n          `Graph.dropEdge: could not find the \"${source}\" -> \"${target}\" edge in the graph.`\n        );\n    } else {\n      edge = '' + edge;\n\n      edgeData = this._edges.get(edge);\n\n      if (!edgeData)\n        throw new NotFoundGraphError(\n          `Graph.dropEdge: could not find the \"${edge}\" edge in the graph.`\n        );\n    }\n\n    dropEdgeFromData(this, edgeData);\n\n    return this;\n  }\n\n  /**\n   * Method used to drop a single directed edge from the graph.\n   *\n   * @param  {any}    source - Source node.\n   * @param  {any}    target - Target node.\n   *\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the edge doesn't exist.\n   */\n  dropDirectedEdge(source, target) {\n    if (arguments.length < 2)\n      throw new UsageGraphError(\n        'Graph.dropDirectedEdge: it does not make sense to try and drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.'\n      );\n\n    if (this.multi)\n      throw new UsageGraphError(\n        'Graph.dropDirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.'\n      );\n\n    source = '' + source;\n    target = '' + target;\n\n    const edgeData = getMatchingEdge(this, source, target, 'directed');\n\n    if (!edgeData)\n      throw new NotFoundGraphError(\n        `Graph.dropDirectedEdge: could not find a \"${source}\" -> \"${target}\" edge in the graph.`\n      );\n\n    dropEdgeFromData(this, edgeData);\n\n    return this;\n  }\n\n  /**\n   * Method used to drop a single undirected edge from the graph.\n   *\n   * @param  {any}    source - Source node.\n   * @param  {any}    target - Target node.\n   *\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the edge doesn't exist.\n   */\n  dropUndirectedEdge(source, target) {\n    if (arguments.length < 2)\n      throw new UsageGraphError(\n        'Graph.dropUndirectedEdge: it does not make sense to drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.'\n      );\n\n    if (this.multi)\n      throw new UsageGraphError(\n        'Graph.dropUndirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.'\n      );\n\n    const edgeData = getMatchingEdge(this, source, target, 'undirected');\n\n    if (!edgeData)\n      throw new NotFoundGraphError(\n        `Graph.dropUndirectedEdge: could not find a \"${source}\" -> \"${target}\" edge in the graph.`\n      );\n\n    dropEdgeFromData(this, edgeData);\n\n    return this;\n  }\n\n  /**\n   * Method used to remove every edge & every node from the graph.\n   *\n   * @return {Graph}\n   */\n  clear() {\n    // Clearing edges\n    this._edges.clear();\n\n    // Clearing nodes\n    this._nodes.clear();\n\n    // Reset counters\n    this._resetInstanceCounters();\n\n    // Emitting\n    this.emit('cleared');\n  }\n\n  /**\n   * Method used to remove every edge from the graph.\n   *\n   * @return {Graph}\n   */\n  clearEdges() {\n    // Clearing structure index\n    const iterator = this._nodes.values();\n\n    let step;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      step.value.clear();\n    }\n\n    // Clearing edges\n    this._edges.clear();\n\n    // Reset counters\n    this._resetInstanceCounters();\n\n    // Emitting\n    this.emit('edgesCleared');\n  }\n\n  /**---------------------------------------------------------------------------\n   * Attributes-related methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning the desired graph's attribute.\n   *\n   * @param  {string} name - Name of the attribute.\n   * @return {any}\n   */\n  getAttribute(name) {\n    return this._attributes[name];\n  }\n\n  /**\n   * Method returning the graph's attributes.\n   *\n   * @return {object}\n   */\n  getAttributes() {\n    return this._attributes;\n  }\n\n  /**\n   * Method returning whether the graph has the desired attribute.\n   *\n   * @param  {string}  name - Name of the attribute.\n   * @return {boolean}\n   */\n  hasAttribute(name) {\n    return this._attributes.hasOwnProperty(name);\n  }\n\n  /**\n   * Method setting a value for the desired graph's attribute.\n   *\n   * @param  {string}  name  - Name of the attribute.\n   * @param  {any}     value - Value for the attribute.\n   * @return {Graph}\n   */\n  setAttribute(name, value) {\n    this._attributes[name] = value;\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'set',\n      attributes: this._attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method using a function to update the desired graph's attribute's value.\n   *\n   * @param  {string}   name    - Name of the attribute.\n   * @param  {function} updater - Function use to update the attribute's value.\n   * @return {Graph}\n   */\n  updateAttribute(name, updater) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateAttribute: updater should be a function.'\n      );\n\n    const value = this._attributes[name];\n\n    this._attributes[name] = updater(value);\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'set',\n      attributes: this._attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method removing the desired graph's attribute.\n   *\n   * @param  {string} name  - Name of the attribute.\n   * @return {Graph}\n   */\n  removeAttribute(name) {\n    delete this._attributes[name];\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'remove',\n      attributes: this._attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method replacing the graph's attributes.\n   *\n   * @param  {object} attributes - New attributes.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if given attributes are not a plain object.\n   */\n  replaceAttributes(attributes) {\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        'Graph.replaceAttributes: provided attributes are not a plain object.'\n      );\n\n    this._attributes = attributes;\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'replace',\n      attributes: this._attributes\n    });\n\n    return this;\n  }\n\n  /**\n   * Method merging the graph's attributes.\n   *\n   * @param  {object} attributes - Attributes to merge.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if given attributes are not a plain object.\n   */\n  mergeAttributes(attributes) {\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        'Graph.mergeAttributes: provided attributes are not a plain object.'\n      );\n\n    assign(this._attributes, attributes);\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'merge',\n      attributes: this._attributes,\n      data: attributes\n    });\n\n    return this;\n  }\n\n  /**\n   * Method updating the graph's attributes.\n   *\n   * @param  {function} updater - Function used to update the attributes.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if given updater is not a function.\n   */\n  updateAttributes(updater) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateAttributes: provided updater is not a function.'\n      );\n\n    this._attributes = updater(this._attributes);\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'update',\n      attributes: this._attributes\n    });\n\n    return this;\n  }\n\n  /**\n   * Method used to update each node's attributes using the given function.\n   *\n   * @param {function}  updater - Updater function to use.\n   * @param {object}    [hints] - Optional hints.\n   */\n  updateEachNodeAttributes(updater, hints) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateEachNodeAttributes: expecting an updater function.'\n      );\n\n    if (hints && !validateHints(hints))\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateEachNodeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n      nodeData.attributes = updater(nodeData.key, nodeData.attributes);\n    }\n\n    this.emit('eachNodeAttributesUpdated', {\n      hints: hints ? hints : null\n    });\n  }\n\n  /**\n   * Method used to update each edge's attributes using the given function.\n   *\n   * @param {function}  updater - Updater function to use.\n   * @param {object}    [hints] - Optional hints.\n   */\n  updateEachEdgeAttributes(updater, hints) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateEachEdgeAttributes: expecting an updater function.'\n      );\n\n    if (hints && !validateHints(hints))\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateEachEdgeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}'\n      );\n\n    const iterator = this._edges.values();\n\n    let step, edgeData, sourceData, targetData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      edgeData = step.value;\n      sourceData = edgeData.source;\n      targetData = edgeData.target;\n\n      edgeData.attributes = updater(\n        edgeData.key,\n        edgeData.attributes,\n        sourceData.key,\n        targetData.key,\n        sourceData.attributes,\n        targetData.attributes,\n        edgeData.undirected\n      );\n    }\n\n    this.emit('eachEdgeAttributesUpdated', {\n      hints: hints ? hints : null\n    });\n  }\n\n  /**---------------------------------------------------------------------------\n   * Iteration-related methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method iterating over the graph's adjacency using the given callback.\n   *\n   * @param  {function}  callback - Callback to use.\n   */\n  forEachAdjacencyEntry(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.forEachAdjacencyEntry: expecting a callback.'\n      );\n\n    forEachAdjacency(false, false, false, this, callback);\n  }\n  forEachAdjacencyEntryWithOrphans(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.forEachAdjacencyEntryWithOrphans: expecting a callback.'\n      );\n\n    forEachAdjacency(false, false, true, this, callback);\n  }\n\n  /**\n   * Method iterating over the graph's assymetric adjacency using the given callback.\n   *\n   * @param  {function}  callback - Callback to use.\n   */\n  forEachAssymetricAdjacencyEntry(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.forEachAssymetricAdjacencyEntry: expecting a callback.'\n      );\n\n    forEachAdjacency(false, true, false, this, callback);\n  }\n  forEachAssymetricAdjacencyEntryWithOrphans(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.forEachAssymetricAdjacencyEntryWithOrphans: expecting a callback.'\n      );\n\n    forEachAdjacency(false, true, true, this, callback);\n  }\n\n  /**\n   * Method returning the list of the graph's nodes.\n   *\n   * @return {array} - The nodes.\n   */\n  nodes() {\n    if (typeof Array.from === 'function') return Array.from(this._nodes.keys());\n\n    return take(this._nodes.keys(), this._nodes.size);\n  }\n\n  /**\n   * Method iterating over the graph's nodes using the given callback.\n   *\n   * @param  {function}  callback - Callback (key, attributes, index).\n   */\n  forEachNode(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.forEachNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n      callback(nodeData.key, nodeData.attributes);\n    }\n  }\n\n  /**\n   * Method iterating attempting to find a node matching the given predicate\n   * function.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  findNode(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.findNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n\n      if (callback(nodeData.key, nodeData.attributes)) return nodeData.key;\n    }\n\n    return;\n  }\n\n  /**\n   * Method mapping nodes.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  mapNodes(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.mapNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    const result = new Array(this.order);\n    let i = 0;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n      result[i++] = callback(nodeData.key, nodeData.attributes);\n    }\n\n    return result;\n  }\n\n  /**\n   * Method returning whether some node verify the given predicate.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  someNode(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.someNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n\n      if (callback(nodeData.key, nodeData.attributes)) return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Method returning whether all node verify the given predicate.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  everyNode(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.everyNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n\n      if (!callback(nodeData.key, nodeData.attributes)) return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Method filtering nodes.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  filterNodes(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.filterNodes: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    const result = [];\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n\n      if (callback(nodeData.key, nodeData.attributes))\n        result.push(nodeData.key);\n    }\n\n    return result;\n  }\n\n  /**\n   * Method reducing nodes.\n   *\n   * @param  {function}  callback - Callback (accumulator, key, attributes).\n   */\n  reduceNodes(callback, initialValue) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.reduceNodes: expecting a callback.'\n      );\n\n    if (arguments.length < 2)\n      throw new InvalidArgumentsGraphError(\n        'Graph.reduceNodes: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.'\n      );\n\n    let accumulator = initialValue;\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n      accumulator = callback(accumulator, nodeData.key, nodeData.attributes);\n    }\n\n    return accumulator;\n  }\n\n  /**\n   * Method returning an iterator over the graph's node entries.\n   *\n   * @return {Iterator}\n   */\n  nodeEntries() {\n    const iterator = this._nodes.values();\n\n    return new Iterator(() => {\n      const step = iterator.next();\n\n      if (step.done) return step;\n\n      const data = step.value;\n\n      return {\n        value: {node: data.key, attributes: data.attributes},\n        done: false\n      };\n    });\n  }\n\n  /**---------------------------------------------------------------------------\n   * Serialization\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method used to export the whole graph.\n   *\n   * @return {object} - The serialized graph.\n   */\n  export() {\n    const nodes = new Array(this._nodes.size);\n\n    let i = 0;\n\n    this._nodes.forEach((data, key) => {\n      nodes[i++] = serializeNode(key, data);\n    });\n\n    const edges = new Array(this._edges.size);\n\n    i = 0;\n\n    this._edges.forEach((data, key) => {\n      edges[i++] = serializeEdge(this.type, key, data);\n    });\n\n    return {\n      options: {\n        type: this.type,\n        multi: this.multi,\n        allowSelfLoops: this.allowSelfLoops\n      },\n      attributes: this.getAttributes(),\n      nodes,\n      edges\n    };\n  }\n\n  /**\n   * Method used to import a serialized graph.\n   *\n   * @param  {object|Graph} data  - The serialized graph.\n   * @param  {boolean}      merge - Whether to merge data.\n   * @return {Graph}              - Returns itself for chaining.\n   */\n  import(data, merge = false) {\n    // Importing a Graph instance directly\n    if (data instanceof Graph) {\n      // Nodes\n      data.forEachNode((n, a) => {\n        if (merge) this.mergeNode(n, a);\n        else this.addNode(n, a);\n      });\n\n      // Edges\n      data.forEachEdge((e, a, s, t, _sa, _ta, u) => {\n        if (merge) {\n          if (u) this.mergeUndirectedEdgeWithKey(e, s, t, a);\n          else this.mergeDirectedEdgeWithKey(e, s, t, a);\n        } else {\n          if (u) this.addUndirectedEdgeWithKey(e, s, t, a);\n          else this.addDirectedEdgeWithKey(e, s, t, a);\n        }\n      });\n\n      return this;\n    }\n\n    // Importing a serialized graph\n    if (!isPlainObject(data))\n      throw new InvalidArgumentsGraphError(\n        'Graph.import: invalid argument. Expecting a serialized graph or, alternatively, a Graph instance.'\n      );\n\n    if (data.attributes) {\n      if (!isPlainObject(data.attributes))\n        throw new InvalidArgumentsGraphError(\n          'Graph.import: invalid attributes. Expecting a plain object.'\n        );\n\n      if (merge) this.mergeAttributes(data.attributes);\n      else this.replaceAttributes(data.attributes);\n    }\n\n    let i, l, list, node, edge;\n\n    if (data.nodes) {\n      list = data.nodes;\n\n      if (!Array.isArray(list))\n        throw new InvalidArgumentsGraphError(\n          'Graph.import: invalid nodes. Expecting an array.'\n        );\n\n      for (i = 0, l = list.length; i < l; i++) {\n        node = list[i];\n\n        // Validating\n        validateSerializedNode(node);\n\n        // Adding the node\n        const {key, attributes} = node;\n\n        if (merge) this.mergeNode(key, attributes);\n        else this.addNode(key, attributes);\n      }\n    }\n\n    if (data.edges) {\n      let undirectedByDefault = false;\n\n      if (this.type === 'undirected') {\n        undirectedByDefault = true;\n      }\n\n      list = data.edges;\n\n      if (!Array.isArray(list))\n        throw new InvalidArgumentsGraphError(\n          'Graph.import: invalid edges. Expecting an array.'\n        );\n\n      for (i = 0, l = list.length; i < l; i++) {\n        edge = list[i];\n\n        // Validating\n        validateSerializedEdge(edge);\n\n        // Adding the edge\n        const {\n          source,\n          target,\n          attributes,\n          undirected = undirectedByDefault\n        } = edge;\n\n        let method;\n\n        if ('key' in edge) {\n          method = merge\n            ? undirected\n              ? this.mergeUndirectedEdgeWithKey\n              : this.mergeDirectedEdgeWithKey\n            : undirected\n            ? this.addUndirectedEdgeWithKey\n            : this.addDirectedEdgeWithKey;\n\n          method.call(this, edge.key, source, target, attributes);\n        } else {\n          method = merge\n            ? undirected\n              ? this.mergeUndirectedEdge\n              : this.mergeDirectedEdge\n            : undirected\n            ? this.addUndirectedEdge\n            : this.addDirectedEdge;\n\n          method.call(this, source, target, attributes);\n        }\n      }\n    }\n\n    return this;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Utils\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning a null copy of the graph, i.e. a graph without nodes\n   * & edges but with the exact same options.\n   *\n   * @param  {object} options - Options to merge with the current ones.\n   * @return {Graph}          - The null copy.\n   */\n  nullCopy(options) {\n    const graph = new Graph(assign({}, this._options, options));\n    graph.replaceAttributes(assign({}, this.getAttributes()));\n    return graph;\n  }\n\n  /**\n   * Method returning an empty copy of the graph, i.e. a graph without edges but\n   * with the exact same options.\n   *\n   * @param  {object} options - Options to merge with the current ones.\n   * @return {Graph}          - The empty copy.\n   */\n  emptyCopy(options) {\n    const graph = this.nullCopy(options);\n\n    this._nodes.forEach((nodeData, key) => {\n      const attributes = assign({}, nodeData.attributes);\n\n      // NOTE: no need to emit events since user cannot access the instance yet\n      nodeData = new graph.NodeDataClass(key, attributes);\n      graph._nodes.set(key, nodeData);\n    });\n\n    return graph;\n  }\n\n  /**\n   * Method returning an exact copy of the graph.\n   *\n   * @param  {object} options - Upgrade options.\n   * @return {Graph}          - The copy.\n   */\n  copy(options) {\n    options = options || {};\n\n    if (\n      typeof options.type === 'string' &&\n      options.type !== this.type &&\n      options.type !== 'mixed'\n    )\n      throw new UsageGraphError(\n        `Graph.copy: cannot create an incompatible copy from \"${this.type}\" type to \"${options.type}\" because this would mean losing information about the current graph.`\n      );\n\n    if (\n      typeof options.multi === 'boolean' &&\n      options.multi !== this.multi &&\n      options.multi !== true\n    )\n      throw new UsageGraphError(\n        'Graph.copy: cannot create an incompatible copy by downgrading a multi graph to a simple one because this would mean losing information about the current graph.'\n      );\n\n    if (\n      typeof options.allowSelfLoops === 'boolean' &&\n      options.allowSelfLoops !== this.allowSelfLoops &&\n      options.allowSelfLoops !== true\n    )\n      throw new UsageGraphError(\n        'Graph.copy: cannot create an incompatible copy from a graph allowing self loops to one that does not because this would mean losing information about the current graph.'\n      );\n\n    const graph = this.emptyCopy(options);\n\n    const iterator = this._edges.values();\n\n    let step, edgeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      edgeData = step.value;\n\n      // NOTE: no need to emit events since user cannot access the instance yet\n      addEdge(\n        graph,\n        'copy',\n        false,\n        edgeData.undirected,\n        edgeData.key,\n        edgeData.source.key,\n        edgeData.target.key,\n        assign({}, edgeData.attributes)\n      );\n    }\n\n    return graph;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Known methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method used by JavaScript to perform JSON serialization.\n   *\n   * @return {object} - The serialized graph.\n   */\n  toJSON() {\n    return this.export();\n  }\n\n  /**\n   * Method returning [object Graph].\n   */\n  toString() {\n    return '[object Graph]';\n  }\n\n  /**\n   * Method used internally by node's console to display a custom object.\n   *\n   * @return {object} - Formatted object representation of the graph.\n   */\n  inspect() {\n    const nodes = {};\n    this._nodes.forEach((data, key) => {\n      nodes[key] = data.attributes;\n    });\n\n    const edges = {},\n      multiIndex = {};\n\n    this._edges.forEach((data, key) => {\n      const direction = data.undirected ? '--' : '->';\n\n      let label = '';\n\n      let source = data.source.key;\n      let target = data.target.key;\n      let tmp;\n\n      if (data.undirected && source > target) {\n        tmp = source;\n        source = target;\n        target = tmp;\n      }\n\n      const desc = `(${source})${direction}(${target})`;\n\n      if (!key.startsWith('geid_')) {\n        label += `[${key}]: `;\n      } else if (this.multi) {\n        if (typeof multiIndex[desc] === 'undefined') {\n          multiIndex[desc] = 0;\n        } else {\n          multiIndex[desc]++;\n        }\n\n        label += `${multiIndex[desc]}. `;\n      }\n\n      label += desc;\n\n      edges[label] = data.attributes;\n    });\n\n    const dummy = {};\n\n    for (const k in this) {\n      if (\n        this.hasOwnProperty(k) &&\n        !EMITTER_PROPS.has(k) &&\n        typeof this[k] !== 'function' &&\n        typeof k !== 'symbol'\n      )\n        dummy[k] = this[k];\n    }\n\n    dummy.attributes = this._attributes;\n    dummy.nodes = nodes;\n    dummy.edges = edges;\n\n    privateProperty(dummy, 'constructor', this.constructor);\n\n    return dummy;\n  }\n}\n\n/**\n * Attaching methods to the prototype.\n *\n * Here, we are attaching a wide variety of methods to the Graph class'\n * prototype when those are very numerous and when their creation is\n * abstracted.\n */\n\n/**\n * Attaching custom inspect method for node >= 10.\n */\nif (typeof Symbol !== 'undefined')\n  Graph.prototype[Symbol.for('nodejs.util.inspect.custom')] =\n    Graph.prototype.inspect;\n\n/**\n * Related to edge addition.\n */\nEDGE_ADD_METHODS.forEach(method => {\n  ['add', 'merge', 'update'].forEach(verb => {\n    const name = method.name(verb);\n    const fn = verb === 'add' ? addEdge : mergeEdge;\n\n    if (method.generateKey) {\n      Graph.prototype[name] = function (source, target, attributes) {\n        return fn(\n          this,\n          name,\n          true,\n          (method.type || this.type) === 'undirected',\n          null,\n          source,\n          target,\n          attributes,\n          verb === 'update'\n        );\n      };\n    } else {\n      Graph.prototype[name] = function (edge, source, target, attributes) {\n        return fn(\n          this,\n          name,\n          false,\n          (method.type || this.type) === 'undirected',\n          edge,\n          source,\n          target,\n          attributes,\n          verb === 'update'\n        );\n      };\n    }\n  });\n});\n\n/**\n * Attributes-related.\n */\nattachNodeAttributesMethods(Graph);\nattachEdgeAttributesMethods(Graph);\n\n/**\n * Edge iteration-related.\n */\nattachEdgeIterationMethods(Graph);\n\n/**\n * Neighbor iteration-related.\n */\nattachNeighborIterationMethods(Graph);\n","/**\n * Graphology Helper Classes\n * ==========================\n *\n * Building some higher-order classes instantiating the graph with\n * predefinite options.\n */\nimport {assign} from './utils';\nimport Graph from './graph';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError,\n  UsageGraphError\n} from './errors';\n\n/**\n * Alternative constructors.\n */\nclass DirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'directed'}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== false)\n      throw new InvalidArgumentsGraphError(\n        'DirectedGraph.from: inconsistent indication that the graph should be multi in given options!'\n      );\n\n    if (finalOptions.type !== 'directed')\n      throw new InvalidArgumentsGraphError(\n        'DirectedGraph.from: inconsistent \"' +\n          finalOptions.type +\n          '\" type in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\nclass UndirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'undirected'}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== false)\n      throw new InvalidArgumentsGraphError(\n        'UndirectedGraph.from: inconsistent indication that the graph should be multi in given options!'\n      );\n\n    if (finalOptions.type !== 'undirected')\n      throw new InvalidArgumentsGraphError(\n        'UndirectedGraph.from: inconsistent \"' +\n          finalOptions.type +\n          '\" type in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\nclass MultiGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({multi: true}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== true)\n      throw new InvalidArgumentsGraphError(\n        'MultiGraph.from: inconsistent indication that the graph should be simple in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\nclass MultiDirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'directed', multi: true}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== true)\n      throw new InvalidArgumentsGraphError(\n        'MultiDirectedGraph.from: inconsistent indication that the graph should be simple in given options!'\n      );\n\n    if (finalOptions.type !== 'directed')\n      throw new InvalidArgumentsGraphError(\n        'MultiDirectedGraph.from: inconsistent \"' +\n          finalOptions.type +\n          '\" type in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\nclass MultiUndirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'undirected', multi: true}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== true)\n      throw new InvalidArgumentsGraphError(\n        'MultiUndirectedGraph.from: inconsistent indication that the graph should be simple in given options!'\n      );\n\n    if (finalOptions.type !== 'undirected')\n      throw new InvalidArgumentsGraphError(\n        'MultiUndirectedGraph.from: inconsistent \"' +\n          finalOptions.type +\n          '\" type in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\n\n/**\n * Attaching static #.from method to each of the constructors.\n */\nfunction attachStaticFromMethod(Class) {\n  /**\n   * Builds a graph from serialized data or another graph's data.\n   *\n   * @param  {Graph|SerializedGraph} data      - Hydratation data.\n   * @param  {object}                [options] - Options.\n   * @return {Class}\n   */\n  Class.from = function (data, options) {\n    // Merging given options with serialized ones\n    const finalOptions = assign({}, data.options, options);\n\n    const instance = new Class(finalOptions);\n    instance.import(data);\n\n    return instance;\n  };\n}\n\nattachStaticFromMethod(Graph);\nattachStaticFromMethod(DirectedGraph);\nattachStaticFromMethod(UndirectedGraph);\nattachStaticFromMethod(MultiGraph);\nattachStaticFromMethod(MultiDirectedGraph);\nattachStaticFromMethod(MultiUndirectedGraph);\n\nGraph.Graph = Graph;\nGraph.DirectedGraph = DirectedGraph;\nGraph.UndirectedGraph = UndirectedGraph;\nGraph.MultiGraph = MultiGraph;\nGraph.MultiDirectedGraph = MultiDirectedGraph;\nGraph.MultiUndirectedGraph = MultiUndirectedGraph;\n\nGraph.InvalidArgumentsGraphError = InvalidArgumentsGraphError;\nGraph.NotFoundGraphError = NotFoundGraphError;\nGraph.UsageGraphError = UsageGraphError;\n\nexport {\n  Graph,\n  DirectedGraph,\n  UndirectedGraph,\n  MultiGraph,\n  MultiDirectedGraph,\n  MultiUndirectedGraph\n};\n","/**\n * Graphology ForceAtlas2 Layout Webworker\n * ========================================\n *\n * Web worker able to run the layout in a separate thread.\n */\nmodule.exports = function worker() {\n  var NODES, EDGES;\n\n  var moduleShim = {};\n\n  (function () {\n    /* eslint no-constant-condition: 0 */\n/**\n * Graphology ForceAtlas2 Iteration\n * =================================\n *\n * Function used to perform a single iteration of the algorithm.\n */\n\n/**\n * Matrices properties accessors.\n */\nvar NODE_X = 0;\nvar NODE_Y = 1;\nvar NODE_DX = 2;\nvar NODE_DY = 3;\nvar NODE_OLD_DX = 4;\nvar NODE_OLD_DY = 5;\nvar NODE_MASS = 6;\nvar NODE_CONVERGENCE = 7;\nvar NODE_SIZE = 8;\nvar NODE_FIXED = 9;\n\nvar EDGE_SOURCE = 0;\nvar EDGE_TARGET = 1;\nvar EDGE_WEIGHT = 2;\n\nvar REGION_NODE = 0;\nvar REGION_CENTER_X = 1;\nvar REGION_CENTER_Y = 2;\nvar REGION_SIZE = 3;\nvar REGION_NEXT_SIBLING = 4;\nvar REGION_FIRST_CHILD = 5;\nvar REGION_MASS = 6;\nvar REGION_MASS_CENTER_X = 7;\nvar REGION_MASS_CENTER_Y = 8;\n\nvar SUBDIVISION_ATTEMPTS = 3;\n\n/**\n * Constants.\n */\nvar PPN = 10;\nvar PPE = 3;\nvar PPR = 9;\n\nvar MAX_FORCE = 10;\n\n/**\n * Function used to perform a single interation of the algorithm.\n *\n * @param  {object}       options    - Layout options.\n * @param  {Float32Array} NodeMatrix - Node data.\n * @param  {Float32Array} EdgeMatrix - Edge data.\n * @return {object}                  - Some metadata.\n */\nmoduleShim.exports = function iterate(options, NodeMatrix, EdgeMatrix) {\n  // Initializing variables\n  var l, r, n, n1, n2, rn, e, w, g, s;\n\n  var order = NodeMatrix.length,\n    size = EdgeMatrix.length;\n\n  var adjustSizes = options.adjustSizes;\n\n  var thetaSquared = options.barnesHutTheta * options.barnesHutTheta;\n\n  var outboundAttCompensation, coefficient, xDist, yDist, ewc, distance, factor;\n\n  var RegionMatrix = [];\n\n  // 1) Initializing layout data\n  //-----------------------------\n\n  // Resetting positions & computing max values\n  for (n = 0; n < order; n += PPN) {\n    NodeMatrix[n + NODE_OLD_DX] = NodeMatrix[n + NODE_DX];\n    NodeMatrix[n + NODE_OLD_DY] = NodeMatrix[n + NODE_DY];\n    NodeMatrix[n + NODE_DX] = 0;\n    NodeMatrix[n + NODE_DY] = 0;\n  }\n\n  // If outbound attraction distribution, compensate\n  if (options.outboundAttractionDistribution) {\n    outboundAttCompensation = 0;\n    for (n = 0; n < order; n += PPN) {\n      outboundAttCompensation += NodeMatrix[n + NODE_MASS];\n    }\n\n    outboundAttCompensation /= order / PPN;\n  }\n\n  // 1.bis) Barnes-Hut computation\n  //------------------------------\n\n  if (options.barnesHutOptimize) {\n    // Setting up\n    var minX = Infinity,\n      maxX = -Infinity,\n      minY = Infinity,\n      maxY = -Infinity,\n      q,\n      q2,\n      subdivisionAttempts;\n\n    // Computing min and max values\n    for (n = 0; n < order; n += PPN) {\n      minX = Math.min(minX, NodeMatrix[n + NODE_X]);\n      maxX = Math.max(maxX, NodeMatrix[n + NODE_X]);\n      minY = Math.min(minY, NodeMatrix[n + NODE_Y]);\n      maxY = Math.max(maxY, NodeMatrix[n + NODE_Y]);\n    }\n\n    // squarify bounds, it's a quadtree\n    var dx = maxX - minX,\n      dy = maxY - minY;\n    if (dx > dy) {\n      minY -= (dx - dy) / 2;\n      maxY = minY + dx;\n    } else {\n      minX -= (dy - dx) / 2;\n      maxX = minX + dy;\n    }\n\n    // Build the Barnes Hut root region\n    RegionMatrix[0 + REGION_NODE] = -1;\n    RegionMatrix[0 + REGION_CENTER_X] = (minX + maxX) / 2;\n    RegionMatrix[0 + REGION_CENTER_Y] = (minY + maxY) / 2;\n    RegionMatrix[0 + REGION_SIZE] = Math.max(maxX - minX, maxY - minY);\n    RegionMatrix[0 + REGION_NEXT_SIBLING] = -1;\n    RegionMatrix[0 + REGION_FIRST_CHILD] = -1;\n    RegionMatrix[0 + REGION_MASS] = 0;\n    RegionMatrix[0 + REGION_MASS_CENTER_X] = 0;\n    RegionMatrix[0 + REGION_MASS_CENTER_Y] = 0;\n\n    // Add each node in the tree\n    l = 1;\n    for (n = 0; n < order; n += PPN) {\n      // Current region, starting with root\n      r = 0;\n      subdivisionAttempts = SUBDIVISION_ATTEMPTS;\n\n      while (true) {\n        // Are there sub-regions?\n\n        // We look at first child index\n        if (RegionMatrix[r + REGION_FIRST_CHILD] >= 0) {\n          // There are sub-regions\n\n          // We just iterate to find a \"leaf\" of the tree\n          // that is an empty region or a region with a single node\n          // (see next case)\n\n          // Find the quadrant of n\n          if (NodeMatrix[n + NODE_X] < RegionMatrix[r + REGION_CENTER_X]) {\n            if (NodeMatrix[n + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {\n              // Top Left quarter\n              q = RegionMatrix[r + REGION_FIRST_CHILD];\n            } else {\n              // Bottom Left quarter\n              q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR;\n            }\n          } else {\n            if (NodeMatrix[n + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {\n              // Top Right quarter\n              q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 2;\n            } else {\n              // Bottom Right quarter\n              q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 3;\n            }\n          }\n\n          // Update center of mass and mass (we only do it for non-leave regions)\n          RegionMatrix[r + REGION_MASS_CENTER_X] =\n            (RegionMatrix[r + REGION_MASS_CENTER_X] *\n              RegionMatrix[r + REGION_MASS] +\n              NodeMatrix[n + NODE_X] * NodeMatrix[n + NODE_MASS]) /\n            (RegionMatrix[r + REGION_MASS] + NodeMatrix[n + NODE_MASS]);\n\n          RegionMatrix[r + REGION_MASS_CENTER_Y] =\n            (RegionMatrix[r + REGION_MASS_CENTER_Y] *\n              RegionMatrix[r + REGION_MASS] +\n              NodeMatrix[n + NODE_Y] * NodeMatrix[n + NODE_MASS]) /\n            (RegionMatrix[r + REGION_MASS] + NodeMatrix[n + NODE_MASS]);\n\n          RegionMatrix[r + REGION_MASS] += NodeMatrix[n + NODE_MASS];\n\n          // Iterate on the right quadrant\n          r = q;\n          continue;\n        } else {\n          // There are no sub-regions: we are in a \"leaf\"\n\n          // Is there a node in this leave?\n          if (RegionMatrix[r + REGION_NODE] < 0) {\n            // There is no node in region:\n            // we record node n and go on\n            RegionMatrix[r + REGION_NODE] = n;\n            break;\n          } else {\n            // There is a node in this region\n\n            // We will need to create sub-regions, stick the two\n            // nodes (the old one r[0] and the new one n) in two\n            // subregions. If they fall in the same quadrant,\n            // we will iterate.\n\n            // Create sub-regions\n            RegionMatrix[r + REGION_FIRST_CHILD] = l * PPR;\n            w = RegionMatrix[r + REGION_SIZE] / 2; // new size (half)\n\n            // NOTE: we use screen coordinates\n            // from Top Left to Bottom Right\n\n            // Top Left sub-region\n            g = RegionMatrix[r + REGION_FIRST_CHILD];\n\n            RegionMatrix[g + REGION_NODE] = -1;\n            RegionMatrix[g + REGION_CENTER_X] =\n              RegionMatrix[r + REGION_CENTER_X] - w;\n            RegionMatrix[g + REGION_CENTER_Y] =\n              RegionMatrix[r + REGION_CENTER_Y] - w;\n            RegionMatrix[g + REGION_SIZE] = w;\n            RegionMatrix[g + REGION_NEXT_SIBLING] = g + PPR;\n            RegionMatrix[g + REGION_FIRST_CHILD] = -1;\n            RegionMatrix[g + REGION_MASS] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_X] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_Y] = 0;\n\n            // Bottom Left sub-region\n            g += PPR;\n            RegionMatrix[g + REGION_NODE] = -1;\n            RegionMatrix[g + REGION_CENTER_X] =\n              RegionMatrix[r + REGION_CENTER_X] - w;\n            RegionMatrix[g + REGION_CENTER_Y] =\n              RegionMatrix[r + REGION_CENTER_Y] + w;\n            RegionMatrix[g + REGION_SIZE] = w;\n            RegionMatrix[g + REGION_NEXT_SIBLING] = g + PPR;\n            RegionMatrix[g + REGION_FIRST_CHILD] = -1;\n            RegionMatrix[g + REGION_MASS] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_X] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_Y] = 0;\n\n            // Top Right sub-region\n            g += PPR;\n            RegionMatrix[g + REGION_NODE] = -1;\n            RegionMatrix[g + REGION_CENTER_X] =\n              RegionMatrix[r + REGION_CENTER_X] + w;\n            RegionMatrix[g + REGION_CENTER_Y] =\n              RegionMatrix[r + REGION_CENTER_Y] - w;\n            RegionMatrix[g + REGION_SIZE] = w;\n            RegionMatrix[g + REGION_NEXT_SIBLING] = g + PPR;\n            RegionMatrix[g + REGION_FIRST_CHILD] = -1;\n            RegionMatrix[g + REGION_MASS] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_X] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_Y] = 0;\n\n            // Bottom Right sub-region\n            g += PPR;\n            RegionMatrix[g + REGION_NODE] = -1;\n            RegionMatrix[g + REGION_CENTER_X] =\n              RegionMatrix[r + REGION_CENTER_X] + w;\n            RegionMatrix[g + REGION_CENTER_Y] =\n              RegionMatrix[r + REGION_CENTER_Y] + w;\n            RegionMatrix[g + REGION_SIZE] = w;\n            RegionMatrix[g + REGION_NEXT_SIBLING] =\n              RegionMatrix[r + REGION_NEXT_SIBLING];\n            RegionMatrix[g + REGION_FIRST_CHILD] = -1;\n            RegionMatrix[g + REGION_MASS] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_X] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_Y] = 0;\n\n            l += 4;\n\n            // Now the goal is to find two different sub-regions\n            // for the two nodes: the one previously recorded (r[0])\n            // and the one we want to add (n)\n\n            // Find the quadrant of the old node\n            if (\n              NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_X] <\n              RegionMatrix[r + REGION_CENTER_X]\n            ) {\n              if (\n                NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_Y] <\n                RegionMatrix[r + REGION_CENTER_Y]\n              ) {\n                // Top Left quarter\n                q = RegionMatrix[r + REGION_FIRST_CHILD];\n              } else {\n                // Bottom Left quarter\n                q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR;\n              }\n            } else {\n              if (\n                NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_Y] <\n                RegionMatrix[r + REGION_CENTER_Y]\n              ) {\n                // Top Right quarter\n                q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 2;\n              } else {\n                // Bottom Right quarter\n                q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 3;\n              }\n            }\n\n            // We remove r[0] from the region r, add its mass to r and record it in q\n            RegionMatrix[r + REGION_MASS] =\n              NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_MASS];\n            RegionMatrix[r + REGION_MASS_CENTER_X] =\n              NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_X];\n            RegionMatrix[r + REGION_MASS_CENTER_Y] =\n              NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_Y];\n\n            RegionMatrix[q + REGION_NODE] = RegionMatrix[r + REGION_NODE];\n            RegionMatrix[r + REGION_NODE] = -1;\n\n            // Find the quadrant of n\n            if (NodeMatrix[n + NODE_X] < RegionMatrix[r + REGION_CENTER_X]) {\n              if (NodeMatrix[n + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {\n                // Top Left quarter\n                q2 = RegionMatrix[r + REGION_FIRST_CHILD];\n              } else {\n                // Bottom Left quarter\n                q2 = RegionMatrix[r + REGION_FIRST_CHILD] + PPR;\n              }\n            } else {\n              if (NodeMatrix[n + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {\n                // Top Right quarter\n                q2 = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 2;\n              } else {\n                // Bottom Right quarter\n                q2 = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 3;\n              }\n            }\n\n            if (q === q2) {\n              // If both nodes are in the same quadrant,\n              // we have to try it again on this quadrant\n              if (subdivisionAttempts--) {\n                r = q;\n                continue; // while\n              } else {\n                // we are out of precision here, and we cannot subdivide anymore\n                // but we have to break the loop anyway\n                subdivisionAttempts = SUBDIVISION_ATTEMPTS;\n                break; // while\n              }\n            }\n\n            // If both quadrants are different, we record n\n            // in its quadrant\n            RegionMatrix[q2 + REGION_NODE] = n;\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  // 2) Repulsion\n  //--------------\n  // NOTES: adjustSizes = antiCollision & scalingRatio = coefficient\n\n  if (options.barnesHutOptimize) {\n    coefficient = options.scalingRatio;\n\n    // Applying repulsion through regions\n    for (n = 0; n < order; n += PPN) {\n      // Computing leaf quad nodes iteration\n\n      r = 0; // Starting with root region\n      while (true) {\n        if (RegionMatrix[r + REGION_FIRST_CHILD] >= 0) {\n          // The region has sub-regions\n\n          // We run the Barnes Hut test to see if we are at the right distance\n          distance =\n            Math.pow(\n              NodeMatrix[n + NODE_X] - RegionMatrix[r + REGION_MASS_CENTER_X],\n              2\n            ) +\n            Math.pow(\n              NodeMatrix[n + NODE_Y] - RegionMatrix[r + REGION_MASS_CENTER_Y],\n              2\n            );\n\n          s = RegionMatrix[r + REGION_SIZE];\n\n          if ((4 * s * s) / distance < thetaSquared) {\n            // We treat the region as a single body, and we repulse\n\n            xDist =\n              NodeMatrix[n + NODE_X] - RegionMatrix[r + REGION_MASS_CENTER_X];\n            yDist =\n              NodeMatrix[n + NODE_Y] - RegionMatrix[r + REGION_MASS_CENTER_Y];\n\n            if (adjustSizes === true) {\n              //-- Linear Anti-collision Repulsion\n              if (distance > 0) {\n                factor =\n                  (coefficient *\n                    NodeMatrix[n + NODE_MASS] *\n                    RegionMatrix[r + REGION_MASS]) /\n                  distance;\n\n                NodeMatrix[n + NODE_DX] += xDist * factor;\n                NodeMatrix[n + NODE_DY] += yDist * factor;\n              } else if (distance < 0) {\n                factor =\n                  (-coefficient *\n                    NodeMatrix[n + NODE_MASS] *\n                    RegionMatrix[r + REGION_MASS]) /\n                  Math.sqrt(distance);\n\n                NodeMatrix[n + NODE_DX] += xDist * factor;\n                NodeMatrix[n + NODE_DY] += yDist * factor;\n              }\n            } else {\n              //-- Linear Repulsion\n              if (distance > 0) {\n                factor =\n                  (coefficient *\n                    NodeMatrix[n + NODE_MASS] *\n                    RegionMatrix[r + REGION_MASS]) /\n                  distance;\n\n                NodeMatrix[n + NODE_DX] += xDist * factor;\n                NodeMatrix[n + NODE_DY] += yDist * factor;\n              }\n            }\n\n            // When this is done, we iterate. We have to look at the next sibling.\n            r = RegionMatrix[r + REGION_NEXT_SIBLING];\n            if (r < 0) break; // No next sibling: we have finished the tree\n\n            continue;\n          } else {\n            // The region is too close and we have to look at sub-regions\n            r = RegionMatrix[r + REGION_FIRST_CHILD];\n            continue;\n          }\n        } else {\n          // The region has no sub-region\n          // If there is a node r[0] and it is not n, then repulse\n          rn = RegionMatrix[r + REGION_NODE];\n\n          if (rn >= 0 && rn !== n) {\n            xDist = NodeMatrix[n + NODE_X] - NodeMatrix[rn + NODE_X];\n            yDist = NodeMatrix[n + NODE_Y] - NodeMatrix[rn + NODE_Y];\n\n            distance = xDist * xDist + yDist * yDist;\n\n            if (adjustSizes === true) {\n              //-- Linear Anti-collision Repulsion\n              if (distance > 0) {\n                factor =\n                  (coefficient *\n                    NodeMatrix[n + NODE_MASS] *\n                    NodeMatrix[rn + NODE_MASS]) /\n                  distance;\n\n                NodeMatrix[n + NODE_DX] += xDist * factor;\n                NodeMatrix[n + NODE_DY] += yDist * factor;\n              } else if (distance < 0) {\n                factor =\n                  (-coefficient *\n                    NodeMatrix[n + NODE_MASS] *\n                    NodeMatrix[rn + NODE_MASS]) /\n                  Math.sqrt(distance);\n\n                NodeMatrix[n + NODE_DX] += xDist * factor;\n                NodeMatrix[n + NODE_DY] += yDist * factor;\n              }\n            } else {\n              //-- Linear Repulsion\n              if (distance > 0) {\n                factor =\n                  (coefficient *\n                    NodeMatrix[n + NODE_MASS] *\n                    NodeMatrix[rn + NODE_MASS]) /\n                  distance;\n\n                NodeMatrix[n + NODE_DX] += xDist * factor;\n                NodeMatrix[n + NODE_DY] += yDist * factor;\n              }\n            }\n          }\n\n          // When this is done, we iterate. We have to look at the next sibling.\n          r = RegionMatrix[r + REGION_NEXT_SIBLING];\n\n          if (r < 0) break; // No next sibling: we have finished the tree\n\n          continue;\n        }\n      }\n    }\n  } else {\n    coefficient = options.scalingRatio;\n\n    // Square iteration\n    for (n1 = 0; n1 < order; n1 += PPN) {\n      for (n2 = 0; n2 < n1; n2 += PPN) {\n        // Common to both methods\n        xDist = NodeMatrix[n1 + NODE_X] - NodeMatrix[n2 + NODE_X];\n        yDist = NodeMatrix[n1 + NODE_Y] - NodeMatrix[n2 + NODE_Y];\n\n        if (adjustSizes === true) {\n          //-- Anticollision Linear Repulsion\n          distance =\n            Math.sqrt(xDist * xDist + yDist * yDist) -\n            NodeMatrix[n1 + NODE_SIZE] -\n            NodeMatrix[n2 + NODE_SIZE];\n\n          if (distance > 0) {\n            factor =\n              (coefficient *\n                NodeMatrix[n1 + NODE_MASS] *\n                NodeMatrix[n2 + NODE_MASS]) /\n              distance /\n              distance;\n\n            // Updating nodes' dx and dy\n            NodeMatrix[n1 + NODE_DX] += xDist * factor;\n            NodeMatrix[n1 + NODE_DY] += yDist * factor;\n\n            NodeMatrix[n2 + NODE_DX] += xDist * factor;\n            NodeMatrix[n2 + NODE_DY] += yDist * factor;\n          } else if (distance < 0) {\n            factor =\n              100 *\n              coefficient *\n              NodeMatrix[n1 + NODE_MASS] *\n              NodeMatrix[n2 + NODE_MASS];\n\n            // Updating nodes' dx and dy\n            NodeMatrix[n1 + NODE_DX] += xDist * factor;\n            NodeMatrix[n1 + NODE_DY] += yDist * factor;\n\n            NodeMatrix[n2 + NODE_DX] -= xDist * factor;\n            NodeMatrix[n2 + NODE_DY] -= yDist * factor;\n          }\n        } else {\n          //-- Linear Repulsion\n          distance = Math.sqrt(xDist * xDist + yDist * yDist);\n\n          if (distance > 0) {\n            factor =\n              (coefficient *\n                NodeMatrix[n1 + NODE_MASS] *\n                NodeMatrix[n2 + NODE_MASS]) /\n              distance /\n              distance;\n\n            // Updating nodes' dx and dy\n            NodeMatrix[n1 + NODE_DX] += xDist * factor;\n            NodeMatrix[n1 + NODE_DY] += yDist * factor;\n\n            NodeMatrix[n2 + NODE_DX] -= xDist * factor;\n            NodeMatrix[n2 + NODE_DY] -= yDist * factor;\n          }\n        }\n      }\n    }\n  }\n\n  // 3) Gravity\n  //------------\n  g = options.gravity / options.scalingRatio;\n  coefficient = options.scalingRatio;\n  for (n = 0; n < order; n += PPN) {\n    factor = 0;\n\n    // Common to both methods\n    xDist = NodeMatrix[n + NODE_X];\n    yDist = NodeMatrix[n + NODE_Y];\n    distance = Math.sqrt(Math.pow(xDist, 2) + Math.pow(yDist, 2));\n\n    if (options.strongGravityMode) {\n      //-- Strong gravity\n      if (distance > 0) factor = coefficient * NodeMatrix[n + NODE_MASS] * g;\n    } else {\n      //-- Linear Anti-collision Repulsion n\n      if (distance > 0)\n        factor = (coefficient * NodeMatrix[n + NODE_MASS] * g) / distance;\n    }\n\n    // Updating node's dx and dy\n    NodeMatrix[n + NODE_DX] -= xDist * factor;\n    NodeMatrix[n + NODE_DY] -= yDist * factor;\n  }\n\n  // 4) Attraction\n  //---------------\n  coefficient =\n    1 * (options.outboundAttractionDistribution ? outboundAttCompensation : 1);\n\n  // TODO: simplify distance\n  // TODO: coefficient is always used as -c --> optimize?\n  for (e = 0; e < size; e += PPE) {\n    n1 = EdgeMatrix[e + EDGE_SOURCE];\n    n2 = EdgeMatrix[e + EDGE_TARGET];\n    w = EdgeMatrix[e + EDGE_WEIGHT];\n\n    // Edge weight influence\n    ewc = Math.pow(w, options.edgeWeightInfluence);\n\n    // Common measures\n    xDist = NodeMatrix[n1 + NODE_X] - NodeMatrix[n2 + NODE_X];\n    yDist = NodeMatrix[n1 + NODE_Y] - NodeMatrix[n2 + NODE_Y];\n\n    // Applying attraction to nodes\n    if (adjustSizes === true) {\n      distance =\n        Math.sqrt(xDist * xDist + yDist * yDist) -\n        NodeMatrix[n1 + NODE_SIZE] -\n        NodeMatrix[n2 + NODE_SIZE];\n\n      if (options.linLogMode) {\n        if (options.outboundAttractionDistribution) {\n          //-- LinLog Degree Distributed Anti-collision Attraction\n          if (distance > 0) {\n            factor =\n              (-coefficient * ewc * Math.log(1 + distance)) /\n              distance /\n              NodeMatrix[n1 + NODE_MASS];\n          }\n        } else {\n          //-- LinLog Anti-collision Attraction\n          if (distance > 0) {\n            factor = (-coefficient * ewc * Math.log(1 + distance)) / distance;\n          }\n        }\n      } else {\n        if (options.outboundAttractionDistribution) {\n          //-- Linear Degree Distributed Anti-collision Attraction\n          if (distance > 0) {\n            factor = (-coefficient * ewc) / NodeMatrix[n1 + NODE_MASS];\n          }\n        } else {\n          //-- Linear Anti-collision Attraction\n          if (distance > 0) {\n            factor = -coefficient * ewc;\n          }\n        }\n      }\n    } else {\n      distance = Math.sqrt(Math.pow(xDist, 2) + Math.pow(yDist, 2));\n\n      if (options.linLogMode) {\n        if (options.outboundAttractionDistribution) {\n          //-- LinLog Degree Distributed Attraction\n          if (distance > 0) {\n            factor =\n              (-coefficient * ewc * Math.log(1 + distance)) /\n              distance /\n              NodeMatrix[n1 + NODE_MASS];\n          }\n        } else {\n          //-- LinLog Attraction\n          if (distance > 0)\n            factor = (-coefficient * ewc * Math.log(1 + distance)) / distance;\n        }\n      } else {\n        if (options.outboundAttractionDistribution) {\n          //-- Linear Attraction Mass Distributed\n          // NOTE: Distance is set to 1 to override next condition\n          distance = 1;\n          factor = (-coefficient * ewc) / NodeMatrix[n1 + NODE_MASS];\n        } else {\n          //-- Linear Attraction\n          // NOTE: Distance is set to 1 to override next condition\n          distance = 1;\n          factor = -coefficient * ewc;\n        }\n      }\n    }\n\n    // Updating nodes' dx and dy\n    // TODO: if condition or factor = 1?\n    if (distance > 0) {\n      // Updating nodes' dx and dy\n      NodeMatrix[n1 + NODE_DX] += xDist * factor;\n      NodeMatrix[n1 + NODE_DY] += yDist * factor;\n\n      NodeMatrix[n2 + NODE_DX] -= xDist * factor;\n      NodeMatrix[n2 + NODE_DY] -= yDist * factor;\n    }\n  }\n\n  // 5) Apply Forces\n  //-----------------\n  var force, swinging, traction, nodespeed, newX, newY;\n\n  // MATH: sqrt and square distances\n  if (adjustSizes === true) {\n    for (n = 0; n < order; n += PPN) {\n      if (NodeMatrix[n + NODE_FIXED] !== 1) {\n        force = Math.sqrt(\n          Math.pow(NodeMatrix[n + NODE_DX], 2) +\n            Math.pow(NodeMatrix[n + NODE_DY], 2)\n        );\n\n        if (force > MAX_FORCE) {\n          NodeMatrix[n + NODE_DX] =\n            (NodeMatrix[n + NODE_DX] * MAX_FORCE) / force;\n          NodeMatrix[n + NODE_DY] =\n            (NodeMatrix[n + NODE_DY] * MAX_FORCE) / force;\n        }\n\n        swinging =\n          NodeMatrix[n + NODE_MASS] *\n          Math.sqrt(\n            (NodeMatrix[n + NODE_OLD_DX] - NodeMatrix[n + NODE_DX]) *\n              (NodeMatrix[n + NODE_OLD_DX] - NodeMatrix[n + NODE_DX]) +\n              (NodeMatrix[n + NODE_OLD_DY] - NodeMatrix[n + NODE_DY]) *\n                (NodeMatrix[n + NODE_OLD_DY] - NodeMatrix[n + NODE_DY])\n          );\n\n        traction =\n          Math.sqrt(\n            (NodeMatrix[n + NODE_OLD_DX] + NodeMatrix[n + NODE_DX]) *\n              (NodeMatrix[n + NODE_OLD_DX] + NodeMatrix[n + NODE_DX]) +\n              (NodeMatrix[n + NODE_OLD_DY] + NodeMatrix[n + NODE_DY]) *\n                (NodeMatrix[n + NODE_OLD_DY] + NodeMatrix[n + NODE_DY])\n          ) / 2;\n\n        nodespeed = (0.1 * Math.log(1 + traction)) / (1 + Math.sqrt(swinging));\n\n        // Updating node's positon\n        newX =\n          NodeMatrix[n + NODE_X] +\n          NodeMatrix[n + NODE_DX] * (nodespeed / options.slowDown);\n        NodeMatrix[n + NODE_X] = newX;\n\n        newY =\n          NodeMatrix[n + NODE_Y] +\n          NodeMatrix[n + NODE_DY] * (nodespeed / options.slowDown);\n        NodeMatrix[n + NODE_Y] = newY;\n      }\n    }\n  } else {\n    for (n = 0; n < order; n += PPN) {\n      if (NodeMatrix[n + NODE_FIXED] !== 1) {\n        swinging =\n          NodeMatrix[n + NODE_MASS] *\n          Math.sqrt(\n            (NodeMatrix[n + NODE_OLD_DX] - NodeMatrix[n + NODE_DX]) *\n              (NodeMatrix[n + NODE_OLD_DX] - NodeMatrix[n + NODE_DX]) +\n              (NodeMatrix[n + NODE_OLD_DY] - NodeMatrix[n + NODE_DY]) *\n                (NodeMatrix[n + NODE_OLD_DY] - NodeMatrix[n + NODE_DY])\n          );\n\n        traction =\n          Math.sqrt(\n            (NodeMatrix[n + NODE_OLD_DX] + NodeMatrix[n + NODE_DX]) *\n              (NodeMatrix[n + NODE_OLD_DX] + NodeMatrix[n + NODE_DX]) +\n              (NodeMatrix[n + NODE_OLD_DY] + NodeMatrix[n + NODE_DY]) *\n                (NodeMatrix[n + NODE_OLD_DY] + NodeMatrix[n + NODE_DY])\n          ) / 2;\n\n        nodespeed =\n          (NodeMatrix[n + NODE_CONVERGENCE] * Math.log(1 + traction)) /\n          (1 + Math.sqrt(swinging));\n\n        // Updating node convergence\n        NodeMatrix[n + NODE_CONVERGENCE] = Math.min(\n          1,\n          Math.sqrt(\n            (nodespeed *\n              (Math.pow(NodeMatrix[n + NODE_DX], 2) +\n                Math.pow(NodeMatrix[n + NODE_DY], 2))) /\n              (1 + Math.sqrt(swinging))\n          )\n        );\n\n        // Updating node's positon\n        newX =\n          NodeMatrix[n + NODE_X] +\n          NodeMatrix[n + NODE_DX] * (nodespeed / options.slowDown);\n        NodeMatrix[n + NODE_X] = newX;\n\n        newY =\n          NodeMatrix[n + NODE_Y] +\n          NodeMatrix[n + NODE_DY] * (nodespeed / options.slowDown);\n        NodeMatrix[n + NODE_Y] = newY;\n      }\n    }\n  }\n\n  // We return the information about the layout (no need to return the matrices)\n  return {};\n};\n\n  })();\n\n  var iterate = moduleShim.exports;\n\n  self.addEventListener('message', function (event) {\n    var data = event.data;\n\n    NODES = new Float32Array(data.nodes);\n\n    if (data.edges) EDGES = new Float32Array(data.edges);\n\n    // Running the iteration\n    iterate(data.settings, NODES, EDGES);\n\n    // Sending result to supervisor\n    self.postMessage(\n      {\n        nodes: NODES.buffer\n      },\n      [NODES.buffer]\n    );\n  });\n};\n\n","/**\n * Graphology Weight Getter\n * =========================\n *\n * Function creating weight getters.\n */\nfunction coerceWeight(value) {\n  // Ensuring target value is a correct number\n  if (typeof value !== 'number' || isNaN(value)) return 1;\n\n  return value;\n}\n\nfunction createNodeValueGetter(nameOrFunction, defaultValue) {\n  var getter = {};\n\n  var coerceToDefault = function (v) {\n    if (typeof v === 'undefined') return defaultValue;\n\n    return v;\n  };\n\n  if (typeof defaultValue === 'function') coerceToDefault = defaultValue;\n\n  var get = function (attributes) {\n    return coerceToDefault(attributes[nameOrFunction]);\n  };\n\n  var returnDefault = function () {\n    return coerceToDefault(undefined);\n  };\n\n  if (typeof nameOrFunction === 'string') {\n    getter.fromAttributes = get;\n    getter.fromGraph = function (graph, node) {\n      return get(graph.getNodeAttributes(node));\n    };\n    getter.fromEntry = function (node, attributes) {\n      return get(attributes);\n    };\n  } else if (typeof nameOrFunction === 'function') {\n    getter.fromAttributes = function () {\n      throw new Error(\n        'graphology-utils/getters/createNodeValueGetter: irrelevant usage.'\n      );\n    };\n    getter.fromGraph = function (graph, node) {\n      return coerceToDefault(\n        nameOrFunction(node, graph.getNodeAttributes(node))\n      );\n    };\n    getter.fromEntry = function (node, attributes) {\n      return coerceToDefault(nameOrFunction(node, attributes));\n    };\n  } else {\n    getter.fromAttributes = returnDefault;\n    getter.fromGraph = returnDefault;\n    getter.fromEntry = returnDefault;\n  }\n\n  return getter;\n}\n\nfunction createEdgeValueGetter(nameOrFunction, defaultValue) {\n  var getter = {};\n\n  var coerceToDefault = function (v) {\n    if (typeof v === 'undefined') return defaultValue;\n\n    return v;\n  };\n\n  if (typeof defaultValue === 'function') coerceToDefault = defaultValue;\n\n  var get = function (attributes) {\n    return coerceToDefault(attributes[nameOrFunction]);\n  };\n\n  var returnDefault = function () {\n    return coerceToDefault(undefined);\n  };\n\n  if (typeof nameOrFunction === 'string') {\n    getter.fromAttributes = get;\n    getter.fromGraph = function (graph, edge) {\n      return get(graph.getEdgeAttributes(edge));\n    };\n    getter.fromEntry = function (edge, attributes) {\n      return get(attributes);\n    };\n    getter.fromPartialEntry = getter.fromEntry;\n    getter.fromMinimalEntry = getter.fromEntry;\n  } else if (typeof nameOrFunction === 'function') {\n    getter.fromAttributes = function () {\n      throw new Error(\n        'graphology-utils/getters/createEdgeValueGetter: irrelevant usage.'\n      );\n    };\n    getter.fromGraph = function (graph, edge) {\n      // TODO: we can do better, check #310\n      var extremities = graph.extremities(edge);\n      return coerceToDefault(\n        nameOrFunction(\n          edge,\n          graph.getEdgeAttributes(edge),\n          extremities[0],\n          extremities[1],\n          graph.getNodeAttributes(extremities[0]),\n          graph.getNodeAttributes(extremities[1]),\n          graph.isUndirected(edge)\n        )\n      );\n    };\n    getter.fromEntry = function (e, a, s, t, sa, ta, u) {\n      return coerceToDefault(nameOrFunction(e, a, s, t, sa, ta, u));\n    };\n    getter.fromPartialEntry = function (e, a, s, t) {\n      return coerceToDefault(nameOrFunction(e, a, s, t));\n    };\n    getter.fromMinimalEntry = function (e, a) {\n      return coerceToDefault(nameOrFunction(e, a));\n    };\n  } else {\n    getter.fromAttributes = returnDefault;\n    getter.fromGraph = returnDefault;\n    getter.fromEntry = returnDefault;\n    getter.fromMinimalEntry = returnDefault;\n  }\n\n  return getter;\n}\n\nexports.createNodeValueGetter = createNodeValueGetter;\nexports.createEdgeValueGetter = createEdgeValueGetter;\nexports.createEdgeWeightGetter = function (name) {\n  return createEdgeValueGetter(name, coerceWeight);\n};\n","/**\n * Graphology ForceAtlas2 Helpers\n * ===============================\n *\n * Miscellaneous helper functions.\n */\n\n/**\n * Constants.\n */\nvar PPN = 10;\nvar PPE = 3;\n\n/**\n * Very simple Object.assign-like function.\n *\n * @param  {object} target       - First object.\n * @param  {object} [...objects] - Objects to merge.\n * @return {object}\n */\nexports.assign = function (target) {\n  target = target || {};\n\n  var objects = Array.prototype.slice.call(arguments).slice(1),\n    i,\n    k,\n    l;\n\n  for (i = 0, l = objects.length; i < l; i++) {\n    if (!objects[i]) continue;\n\n    for (k in objects[i]) target[k] = objects[i][k];\n  }\n\n  return target;\n};\n\n/**\n * Function used to validate the given settings.\n *\n * @param  {object}      settings - Settings to validate.\n * @return {object|null}\n */\nexports.validateSettings = function (settings) {\n  if ('linLogMode' in settings && typeof settings.linLogMode !== 'boolean')\n    return {message: 'the `linLogMode` setting should be a boolean.'};\n\n  if (\n    'outboundAttractionDistribution' in settings &&\n    typeof settings.outboundAttractionDistribution !== 'boolean'\n  )\n    return {\n      message:\n        'the `outboundAttractionDistribution` setting should be a boolean.'\n    };\n\n  if ('adjustSizes' in settings && typeof settings.adjustSizes !== 'boolean')\n    return {message: 'the `adjustSizes` setting should be a boolean.'};\n\n  if (\n    'edgeWeightInfluence' in settings &&\n    typeof settings.edgeWeightInfluence !== 'number'\n  )\n    return {\n      message: 'the `edgeWeightInfluence` setting should be a number.'\n    };\n\n  if (\n    'scalingRatio' in settings &&\n    !(typeof settings.scalingRatio === 'number' && settings.scalingRatio >= 0)\n  )\n    return {message: 'the `scalingRatio` setting should be a number >= 0.'};\n\n  if (\n    'strongGravityMode' in settings &&\n    typeof settings.strongGravityMode !== 'boolean'\n  )\n    return {message: 'the `strongGravityMode` setting should be a boolean.'};\n\n  if (\n    'gravity' in settings &&\n    !(typeof settings.gravity === 'number' && settings.gravity >= 0)\n  )\n    return {message: 'the `gravity` setting should be a number >= 0.'};\n\n  if (\n    'slowDown' in settings &&\n    !(typeof settings.slowDown === 'number' || settings.slowDown >= 0)\n  )\n    return {message: 'the `slowDown` setting should be a number >= 0.'};\n\n  if (\n    'barnesHutOptimize' in settings &&\n    typeof settings.barnesHutOptimize !== 'boolean'\n  )\n    return {message: 'the `barnesHutOptimize` setting should be a boolean.'};\n\n  if (\n    'barnesHutTheta' in settings &&\n    !(\n      typeof settings.barnesHutTheta === 'number' &&\n      settings.barnesHutTheta >= 0\n    )\n  )\n    return {message: 'the `barnesHutTheta` setting should be a number >= 0.'};\n\n  return null;\n};\n\n/**\n * Function generating a flat matrix for both nodes & edges of the given graph.\n *\n * @param  {Graph}    graph         - Target graph.\n * @param  {function} getEdgeWeight - Edge weight getter function.\n * @return {object}                 - Both matrices.\n */\nexports.graphToByteArrays = function (graph, getEdgeWeight) {\n  var order = graph.order;\n  var size = graph.size;\n  var index = {};\n  var j;\n\n  // NOTE: float32 could lead to issues if edge array needs to index large\n  // number of nodes.\n  var NodeMatrix = new Float32Array(order * PPN);\n  var EdgeMatrix = new Float32Array(size * PPE);\n\n  // Iterate through nodes\n  j = 0;\n  graph.forEachNode(function (node, attr) {\n    // Node index\n    index[node] = j;\n\n    // Populating byte array\n    NodeMatrix[j] = attr.x;\n    NodeMatrix[j + 1] = attr.y;\n    NodeMatrix[j + 2] = 0; // dx\n    NodeMatrix[j + 3] = 0; // dy\n    NodeMatrix[j + 4] = 0; // old_dx\n    NodeMatrix[j + 5] = 0; // old_dy\n    NodeMatrix[j + 6] = 1; // mass\n    NodeMatrix[j + 7] = 1; // convergence\n    NodeMatrix[j + 8] = attr.size || 1;\n    NodeMatrix[j + 9] = attr.fixed ? 1 : 0;\n    j += PPN;\n  });\n\n  // Iterate through edges\n  j = 0;\n  graph.forEachEdge(function (edge, attr, source, target, sa, ta, u) {\n    var sj = index[source];\n    var tj = index[target];\n\n    // Handling node mass through degree\n    NodeMatrix[sj + 6] += 1;\n    NodeMatrix[tj + 6] += 1;\n\n    // Populating byte array\n    EdgeMatrix[j] = sj;\n    EdgeMatrix[j + 1] = tj;\n    EdgeMatrix[j + 2] = getEdgeWeight(edge, attr, source, target, sa, ta, u);\n    j += PPE;\n  });\n\n  return {\n    nodes: NodeMatrix,\n    edges: EdgeMatrix\n  };\n};\n\n/**\n * Function applying the layout back to the graph.\n *\n * @param {Graph}         graph         - Target graph.\n * @param {Float32Array}  NodeMatrix    - Node matrix.\n * @param {function|null} outputReducer - A node reducer.\n */\nexports.assignLayoutChanges = function (graph, NodeMatrix, outputReducer) {\n  var i = 0;\n\n  graph.updateEachNodeAttributes(function (node, attr) {\n    attr.x = NodeMatrix[i];\n    attr.y = NodeMatrix[i + 1];\n\n    i += PPN;\n\n    return outputReducer ? outputReducer(node, attr) : attr;\n  });\n};\n\n/**\n * Function reading the positions (only) from the graph, to write them in the matrix.\n *\n * @param {Graph}        graph      - Target graph.\n * @param {Float32Array} NodeMatrix - Node matrix.\n */\nexports.readGraphPositions = function (graph, NodeMatrix) {\n  var i = 0;\n\n  graph.forEachNode(function (node, attr) {\n    NodeMatrix[i] = attr.x;\n    NodeMatrix[i + 1] = attr.y;\n\n    i += PPN;\n  });\n};\n\n/**\n * Function collecting the layout positions.\n *\n * @param  {Graph}         graph         - Target graph.\n * @param  {Float32Array}  NodeMatrix    - Node matrix.\n * @param  {function|null} outputReducer - A nodes reducer.\n * @return {object}                      - Map to node positions.\n */\nexports.collectLayoutChanges = function (graph, NodeMatrix, outputReducer) {\n  var nodes = graph.nodes(),\n    positions = {};\n\n  for (var i = 0, j = 0, l = NodeMatrix.length; i < l; i += PPN) {\n    if (outputReducer) {\n      var newAttr = Object.assign({}, graph.getNodeAttributes(nodes[j]));\n      newAttr.x = NodeMatrix[i];\n      newAttr.y = NodeMatrix[i + 1];\n      newAttr = outputReducer(nodes[j], newAttr);\n      positions[nodes[j]] = {\n        x: newAttr.x,\n        y: newAttr.y\n      };\n    } else {\n      positions[nodes[j]] = {\n        x: NodeMatrix[i],\n        y: NodeMatrix[i + 1]\n      };\n    }\n\n    j++;\n  }\n\n  return positions;\n};\n\n/**\n * Function returning a web worker from the given function.\n *\n * @param  {function}  fn - Function for the worker.\n * @return {DOMString}\n */\nexports.createWorker = function createWorker(fn) {\n  var xURL = window.URL || window.webkitURL;\n  var code = fn.toString();\n  var objectUrl = xURL.createObjectURL(\n    new Blob(['(' + code + ').call(this);'], {type: 'text/javascript'})\n  );\n  var worker = new Worker(objectUrl);\n  xURL.revokeObjectURL(objectUrl);\n\n  return worker;\n};\n","/**\n * Graphology ForceAtlas2 Layout Default Settings\n * ===============================================\n */\nmodule.exports = {\n  linLogMode: false,\n  outboundAttractionDistribution: false,\n  adjustSizes: false,\n  edgeWeightInfluence: 1,\n  scalingRatio: 1,\n  strongGravityMode: false,\n  gravity: 1,\n  slowDown: 1,\n  barnesHutOptimize: false,\n  barnesHutTheta: 0.5\n};\n","/**\n * Graphology ForceAtlas2 Layout Supervisor\n * =========================================\n *\n * Supervisor class able to spawn a web worker to run the FA2 layout in a\n * separate thread not to block UI with heavy synchronous computations.\n */\nvar workerFunction = require('./webworker.js');\nvar isGraph = require('graphology-utils/is-graph');\nvar createEdgeWeightGetter =\n  require('graphology-utils/getters').createEdgeWeightGetter;\nvar helpers = require('./helpers.js');\n\nvar DEFAULT_SETTINGS = require('./defaults.js');\n\n/**\n * Class representing a FA2 layout run by a webworker.\n *\n * @constructor\n * @param  {Graph}         graph        - Target graph.\n * @param  {object|number} params       - Parameters:\n * @param  {object}          [settings] - Settings.\n */\nfunction FA2LayoutSupervisor(graph, params) {\n  params = params || {};\n\n  // Validation\n  if (!isGraph(graph))\n    throw new Error(\n      'graphology-layout-forceatlas2/worker: the given graph is not a valid graphology instance.'\n    );\n\n  var getEdgeWeight = createEdgeWeightGetter(params.getEdgeWeight).fromEntry;\n\n  // Validating settings\n  var settings = helpers.assign({}, DEFAULT_SETTINGS, params.settings);\n  var validationError = helpers.validateSettings(settings);\n\n  if (validationError)\n    throw new Error(\n      'graphology-layout-forceatlas2/worker: ' + validationError.message\n    );\n\n  // Properties\n  this.worker = null;\n  this.graph = graph;\n  this.settings = settings;\n  this.getEdgeWeight = getEdgeWeight;\n  this.matrices = null;\n  this.running = false;\n  this.killed = false;\n  this.outputReducer =\n    typeof params.outputReducer === 'function' ? params.outputReducer : null;\n\n  // Binding listeners\n  this.handleMessage = this.handleMessage.bind(this);\n\n  var respawnFrame = undefined;\n  var self = this;\n\n  this.handleGraphUpdate = function () {\n    if (self.worker) self.worker.terminate();\n\n    if (respawnFrame) clearTimeout(respawnFrame);\n\n    respawnFrame = setTimeout(function () {\n      respawnFrame = undefined;\n      self.spawnWorker();\n    }, 0);\n  };\n\n  graph.on('nodeAdded', this.handleGraphUpdate);\n  graph.on('edgeAdded', this.handleGraphUpdate);\n  graph.on('nodeDropped', this.handleGraphUpdate);\n  graph.on('edgeDropped', this.handleGraphUpdate);\n\n  // Spawning worker\n  this.spawnWorker();\n}\n\nFA2LayoutSupervisor.prototype.isRunning = function () {\n  return this.running;\n};\n\n/**\n * Internal method used to spawn the web worker.\n */\nFA2LayoutSupervisor.prototype.spawnWorker = function () {\n  if (this.worker) this.worker.terminate();\n\n  this.worker = helpers.createWorker(workerFunction);\n  this.worker.addEventListener('message', this.handleMessage);\n\n  if (this.running) {\n    this.running = false;\n    this.start();\n  }\n};\n\n/**\n * Internal method used to handle the worker's messages.\n *\n * @param {object} event - Event to handle.\n */\nFA2LayoutSupervisor.prototype.handleMessage = function (event) {\n  if (!this.running) return;\n\n  var matrix = new Float32Array(event.data.nodes);\n\n  helpers.assignLayoutChanges(this.graph, matrix, this.outputReducer);\n  if (this.outputReducer) helpers.readGraphPositions(this.graph, matrix);\n  this.matrices.nodes = matrix;\n\n  // Looping\n  this.askForIterations();\n};\n\n/**\n * Internal method used to ask for iterations from the worker.\n *\n * @param  {boolean} withEdges - Should we send edges along?\n * @return {FA2LayoutSupervisor}\n */\nFA2LayoutSupervisor.prototype.askForIterations = function (withEdges) {\n  var matrices = this.matrices;\n\n  var payload = {\n    settings: this.settings,\n    nodes: matrices.nodes.buffer\n  };\n\n  var buffers = [matrices.nodes.buffer];\n\n  if (withEdges) {\n    payload.edges = matrices.edges.buffer;\n    buffers.push(matrices.edges.buffer);\n  }\n\n  this.worker.postMessage(payload, buffers);\n\n  return this;\n};\n\n/**\n * Method used to start the layout.\n *\n * @return {FA2LayoutSupervisor}\n */\nFA2LayoutSupervisor.prototype.start = function () {\n  if (this.killed)\n    throw new Error(\n      'graphology-layout-forceatlas2/worker.start: layout was killed.'\n    );\n\n  if (this.running) return this;\n\n  // Building matrices\n  this.matrices = helpers.graphToByteArrays(this.graph, this.getEdgeWeight);\n\n  this.running = true;\n  this.askForIterations(true);\n\n  return this;\n};\n\n/**\n * Method used to stop the layout.\n *\n * @return {FA2LayoutSupervisor}\n */\nFA2LayoutSupervisor.prototype.stop = function () {\n  this.running = false;\n\n  return this;\n};\n\n/**\n * Method used to kill the layout.\n *\n * @return {FA2LayoutSupervisor}\n */\nFA2LayoutSupervisor.prototype.kill = function () {\n  if (this.killed) return this;\n\n  this.running = false;\n  this.killed = true;\n\n  // Clearing memory\n  this.matrices = null;\n\n  // Terminating worker\n  this.worker.terminate();\n\n  // Unbinding listeners\n  this.graph.removeListener('nodeAdded', this.handleGraphUpdate);\n  this.graph.removeListener('edgeAdded', this.handleGraphUpdate);\n  this.graph.removeListener('nodeDropped', this.handleGraphUpdate);\n  this.graph.removeListener('edgeDropped', this.handleGraphUpdate);\n};\n\n/**\n * Exporting.\n */\nmodule.exports = FA2LayoutSupervisor;\n","\nimport Sigma from \"sigma\";\nimport Graph from \"graphology\";\nimport FA2Layout from 'graphology-layout-forceatlas2/worker';\n\nconst data = [\n    \"it-cmf\",\n    \"business process management\",\n    \"fabrica de software\",\n    \"dimensions of information quality\",\n    \"information\",\n    \"information quality\",\n    \"technological advancement\",\n    \"environmental awareness\",\n    \"education\",\n    \"classroom\",\n    \"technology adoption\",\n    \"erp\",\n    \"technology usage\",\n    \"tam\",\n    \"it-cmf\",\n    \"business process management\",\n    \"bpm\",\n    \"software development\",\n    \"higher education\",\n    \"competency\",\n    \"project management\",\n    \"it-cmf\",\n    \"capability\",\n    \"competency\",\n    \"graph\",\n    \"information systems\",\n    \"information systems and technology\",\n    \"it-cmf\",\n    \"capability\",\n    \"competency\",\n    \"graph\",\n    \"information systems\",\n    \"information systems and technology\",\n    \"informatioin systems and technology\",\n    \"information systems and technology competency\",\n    \"competency grammar\",\n    \"backus-naur form\",\n    \"competency\",\n    \"information systems\",\n    \"information systems and technology competency\",\n    \"competency mapping\",\n    \"modelos de evoluo\",\n    \"estdios de crescimento\",\n    \"tecnologias e sistemas de informao\",\n    \"modelos de maturidade\",\n    \"organization evolution model\",\n    \"stages of growth\",\n    \"information systems and technologies\",\n    \"maturity models\"\n]\n\nconst container = document.getElementById(\"sigma-container\") as HTMLElement;\nconst graph = new Graph();\n\n// The parameters are the same as for the synchronous version, minus `iterations` of course\nconst layout = new FA2Layout(graph, {\n    settings: { gravity: 1 },\n    getEdgeWeight: 'weight'\n});\n\n// To start the layout\nlayout.start();\n\ndata.map((item, index) => {\n    if (graph.nodes().includes(item) == false) {\n        graph.addNode(item, { \n            label: item, \n            x: 2*Math.random()-1, \n            y: 2*Math.random()-1, \n            size: 10, \n            color: \"#727EE0\" \n        });\n    } else {\n        graph.setNodeAttribute(\n            item,\n            \"size\",\n            ((graph.getNodeAttribute(item, \"size\") as number) + 6)\n            );\n    };\n    if (data.length-1 === index) {\n        const sigma = new Sigma(graph, container);\n    }\n});\n\n// circular_x: L * Math.cos(Math.PI * 2 * i / N),\n// circular_y: L * Math.sin(Math.PI * 2 * i / N),\n\n// Math.cos(Math.PI * 2 * index / 48) * 10\n// Math.sin(Math.PI * 2 * index / 48) * 10\n\n// graph.updateNode(item, {\n//     size: graph.getNodeAttribute(item, 'size') + 1\n// })","var OVERLAY_ID = '__parcel__error__overlay__';\n\nvar OldModule = module.bundle.Module;\n\nfunction Module(moduleName) {\n  OldModule.call(this, moduleName);\n  this.hot = {\n    data: module.bundle.hotData,\n    _acceptCallbacks: [],\n    _disposeCallbacks: [],\n    accept: function (fn) {\n      this._acceptCallbacks.push(fn || function () {});\n    },\n    dispose: function (fn) {\n      this._disposeCallbacks.push(fn);\n    }\n  };\n\n  module.bundle.hotData = null;\n}\n\nmodule.bundle.Module = Module;\nvar checkedAssets, assetsToAccept;\n\nvar parent = module.bundle.parent;\nif ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {\n  var hostname = process.env.HMR_HOSTNAME || location.hostname;\n  var protocol = location.protocol === 'https:' ? 'wss' : 'ws';\n  var ws = new WebSocket(protocol + '://' + hostname + ':' + process.env.HMR_PORT + '/');\n  ws.onmessage = function(event) {\n    checkedAssets = {};\n    assetsToAccept = [];\n\n    var data = JSON.parse(event.data);\n\n    if (data.type === 'update') {\n      var handled = false;\n      data.assets.forEach(function(asset) {\n        if (!asset.isNew) {\n          var didAccept = hmrAcceptCheck(global.parcelRequire, asset.id);\n          if (didAccept) {\n            handled = true;\n          }\n        }\n      });\n\n      // Enable HMR for CSS by default.\n      handled = handled || data.assets.every(function(asset) {\n        return asset.type === 'css' && asset.generated.js;\n      });\n\n      if (handled) {\n        console.clear();\n\n        data.assets.forEach(function (asset) {\n          hmrApply(global.parcelRequire, asset);\n        });\n\n        assetsToAccept.forEach(function (v) {\n          hmrAcceptRun(v[0], v[1]);\n        });\n      } else if (location.reload) { // `location` global exists in a web worker context but lacks `.reload()` function.\n        location.reload();\n      }\n    }\n\n    if (data.type === 'reload') {\n      ws.close();\n      ws.onclose = function () {\n        location.reload();\n      }\n    }\n\n    if (data.type === 'error-resolved') {\n      console.log('[parcel]  Error resolved');\n\n      removeErrorOverlay();\n    }\n\n    if (data.type === 'error') {\n      console.error('[parcel]   ' + data.error.message + '\\n' + data.error.stack);\n\n      removeErrorOverlay();\n\n      var overlay = createErrorOverlay(data);\n      document.body.appendChild(overlay);\n    }\n  };\n}\n\nfunction removeErrorOverlay() {\n  var overlay = document.getElementById(OVERLAY_ID);\n  if (overlay) {\n    overlay.remove();\n  }\n}\n\nfunction createErrorOverlay(data) {\n  var overlay = document.createElement('div');\n  overlay.id = OVERLAY_ID;\n\n  // html encode message and stack trace\n  var message = document.createElement('div');\n  var stackTrace = document.createElement('pre');\n  message.innerText = data.error.message;\n  stackTrace.innerText = data.error.stack;\n\n  overlay.innerHTML = (\n    '<div style=\"background: black; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; opacity: 0.85; font-family: Menlo, Consolas, monospace; z-index: 9999;\">' +\n      '<span style=\"background: red; padding: 2px 4px; border-radius: 2px;\">ERROR</span>' +\n      '<span style=\"top: 2px; margin-left: 5px; position: relative;\"></span>' +\n      '<div style=\"font-size: 18px; font-weight: bold; margin-top: 20px;\">' + message.innerHTML + '</div>' +\n      '<pre>' + stackTrace.innerHTML + '</pre>' +\n    '</div>'\n  );\n\n  return overlay;\n\n}\n\nfunction getParents(bundle, id) {\n  var modules = bundle.modules;\n  if (!modules) {\n    return [];\n  }\n\n  var parents = [];\n  var k, d, dep;\n\n  for (k in modules) {\n    for (d in modules[k][1]) {\n      dep = modules[k][1][d];\n      if (dep === id || (Array.isArray(dep) && dep[dep.length - 1] === id)) {\n        parents.push(k);\n      }\n    }\n  }\n\n  if (bundle.parent) {\n    parents = parents.concat(getParents(bundle.parent, id));\n  }\n\n  return parents;\n}\n\nfunction hmrApply(bundle, asset) {\n  var modules = bundle.modules;\n  if (!modules) {\n    return;\n  }\n\n  if (modules[asset.id] || !bundle.parent) {\n    var fn = new Function('require', 'module', 'exports', asset.generated.js);\n    asset.isNew = !modules[asset.id];\n    modules[asset.id] = [fn, asset.deps];\n  } else if (bundle.parent) {\n    hmrApply(bundle.parent, asset);\n  }\n}\n\nfunction hmrAcceptCheck(bundle, id) {\n  var modules = bundle.modules;\n  if (!modules) {\n    return;\n  }\n\n  if (!modules[id] && bundle.parent) {\n    return hmrAcceptCheck(bundle.parent, id);\n  }\n\n  if (checkedAssets[id]) {\n    return;\n  }\n  checkedAssets[id] = true;\n\n  var cached = bundle.cache[id];\n\n  assetsToAccept.push([bundle, id]);\n\n  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {\n    return true;\n  }\n\n  return getParents(global.parcelRequire, id).some(function (id) {\n    return hmrAcceptCheck(global.parcelRequire, id)\n  });\n}\n\nfunction hmrAcceptRun(bundle, id) {\n  var cached = bundle.cache[id];\n  bundle.hotData = {};\n  if (cached) {\n    cached.hot.data = bundle.hotData;\n  }\n\n  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {\n    cached.hot._disposeCallbacks.forEach(function (cb) {\n      cb(bundle.hotData);\n    });\n  }\n\n  delete bundle.cache[id];\n  bundle(id);\n\n  cached = bundle.cache[id];\n  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {\n    cached.hot._acceptCallbacks.forEach(function (cb) {\n      cb();\n    });\n    return true;\n  }\n}\n"]}